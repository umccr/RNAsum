---
title: 'Patient Transcriptome Summary'
author: 'UMCCR'
date: '`r date()`'
output:
  html_document:
    theme: readable
    toc: true
    toc_float: true
  rmdformats::material:
    highlight: kate
params:
  arriba_dir: '~/UMCCR/data/wts/RNAsum/SBJ05566_MDX240288_L2401281/wts/arriba'
  arriba_pdf: NULL
  arriba_tsv: NULL
  batch_rm: TRUE
  cn_gain: 95
  cn_loss: 5
  dataset: 'PANCAN'
  dataset_name_incl: FALSE
  dragen_fusions: NULL
  dragen_mapping_metrics: NULL
  dragen_wts_dir: '~/UMCCR/data/wts/RNAsum/SBJ05566_MDX240288_L2401281/wts'
  drugs: FALSE
  filter: TRUE
  immunogram: FALSE
  log: TRUE
  sv_tsv: '~/UMCCR/data/wts/RNAsum/SBJ05566_MDX240288_L2401281/wgs/sv/SBJ05566__MDX240287-manta.tsv'
  norm: TMM
  pcgr_splice_vars: TRUE
  pcgr_tier: 4
  pcgr_tiers_tsv: '~/UMCCR/data/wts/RNAsum/SBJ05566_MDX240288_L2401281/wgs/small_variants/SBJ05566__MDX240287-somatic.pcgr.snvs_indels.tiers.tsv'
  project: NULL
  purple_gene_tsv: '~/UMCCR/data/wts/RNAsum/SBJ05566_MDX240288_L2401281/wgs/purple/SBJ05566__MDX240287.purple.cnv.gene.tsv'
  report_dir: '~/UMCCR/data/wts/RNAsum/SBJ05566_MDX240288_L2401281/'
  salmon: NULL
  sample_name: "test_sv"
  sample_source: '-'
  save_tables: TRUE
  scaling: 'gene-wise'
  subject_id: NULL
  top_genes: 5
  transform: 'CPM'
  umccrise: NULL
---

```{r prep_knitr_hooks, echo = FALSE}
# Time chunks during knitting
# https://bookdown.org/yihui/rmarkdown-cookbook/time-chunk.html
all_chunk_runtimes <- list()
knitr::knit_hooks$set(timeit = local({
  now <- NULL
  function(before, options) {
    if (before) {
      now <<- Sys.time()
    } else {
      res <- difftime(Sys.time(), now)
      all_chunk_runtimes[[options$label]] <<- res
    }
  }
}))

knitr::opts_chunk$set(timeit = TRUE, echo = FALSE)
```

```{r echo=FALSE, message=FALSE}
# source(here::here("inst/rmd/params/pd.R")) # for use with 'Run All Chunks Above'
# source(here::here("inst/rmd/params/sk.R")) # for use with 'Run All Chunks Above'

# start with more exotic pkgs, then get to core ones
{
  library(conflicted) # checks for pkg function conflicts
  library(DT, include.only = c("datatable"))
  library(dplyr, include.only = c("mutate", "select", "filter", "if_else"))
  library(EDASeq, include.only = c("plotRLE"))
  library(edgeR, include.only = c("DGEList"))
  library(fs, include.only = c("dir_create"))
  library(glue, include.only = c("glue"))
  library(ggforce, include.only = c("geom_sina"))
  library(ggplot2, include.only = c("ggplot", "aes"))
  library(htmltools, include.only = c("renderTags"))
  library(limma, include.only = c("removeBatchEffect"))
  library(manhattanly, include.only = c("manhattanly"))
  library(plotly, include.only = c("plot_ly"))
  library(preprocessCore, include.only = c("normalize.quantiles"))
  library(purrr, include.only = c("pluck"))
  library(rlang, include.only = c("set_names"))
  library(tibble, include.only = c("tibble"))
  library(RNAsum) # use :: explicitly for all RNAsum pkg funcs
}
```

```{r read_data, message=FALSE, warning=FALSE, comment=NA}
dataset <- toupper(params$dataset)
dataset_name_incl <- if_else(params$dataset_name_incl, glue("_{params$dataset}"), "")
# Define Z-transformation direction
scaling <- if_else(tolower(params$scaling) == "gene-wise", "gene-wise", "group-wise")

##### Grab umccrise SBJ for MySQL insert command.
# TODO (PD): revisit subjectID
subjectID <- ifelse(!is.null(params$subject_id), params$subject_id, "")
subjectID <- ifelse(is.null(params$umccrise), subjectID, basename(params$umccrise))
sample_name <- paste0(
  params$sample_name,
  if_else(dataset_name_incl == "", "", paste0("_", dataset))
)
sample_report_title <- sample_name
results_dir <- file.path(params$report_dir, glue::glue("{sample_name}.results"))
fs::dir_create(results_dir)
#### Annotate transcripts with gene IDs
#### Get genes annotation and genomic locations using AnnotationHub
#### tx_gene_id_105.rds was generated using the ah_edb.R script in rnasum.data pkg
tx_gene_id_105_rds <- system.file("extdata/ensembl/tx_gene_id_105.rds", package = "RNAsum.data")
tx_gene_id_105 <- readr::read_rds(tx_gene_id_105_rds)
tx2ensembl <- tx_gene_id_105 |>
  dplyr::select("TXID", "GENEID") |>
  dplyr::rename(tx_name = "TXID", gene_id = "GENEID")

# reference data
ref_dataset_filepaths <- RNAsum::get_refdata(dataset)
ref_dataset.list <- vector("list", length(dataset)) |> set_names(dataset)
ref_genes.list <- RNAsum::get_refgenes(params)
# sample WTS/WGS data
sample_data.list <- RNAsum::read_sample_data(params, results_dir, tx2gene = tx2ensembl)
arriba_summary_out <- glue("{sample_name}.RNAseq_report.arriba_fusions.txt")
RNAsum::arriba_summary_write(
  sample_data.list[["arriba_pdf"]],
  file = file.path(results_dir, arriba_summary_out)
)

##### Read in reference datasets and merge them with sample data.
# Output list: merged data and merged targets info.
ref_dataset.list[[dataset]] <- RNAsum::combineDatasets(
  sample_name = sample_name,
  sample_counts = sample_data.list[["salmon"]],
  ref_data = ref_dataset_filepaths,
  report_dir = results_dir
)

##### Define internal, external and addition cancer group names based on the targets definition
int_cancer_group <- ref_dataset_filepaths[["int_ref"]][["dataset"]]
ext_cancer_group <- ref_dataset_filepaths[["ext_ref"]][["dataset"]]

add_cancer_group <- NULL
if (length(unique(ref_dataset.list[[dataset]][["sample_annot"]]$Target)) > 3) {
  add_cancer_group <- unique(ref_dataset.list[[dataset]][["sample_annot"]]$Target)[2]
}

##### Define the cancer group to be used to compare per-gene expression values and report in the summary tables
comp_cancer_group <- ext_cancer_group
if (dataset %in% c("PAAD", "PAAD-IPMN", "PAAD-NET", "PAAD-ACC")) {
  comp_cancer_group <- int_cancer_group
}
```

```{r chunk_eval}
# TODO (PD): put all chunks inside a function
runArribaChunk <- !is.null(sample_data.list[["arriba_tsv"]])
runDragenFusionChunk <- !is.null(sample_data.list[["dragen_fusions"]])
runDragenMappingMetricsChunk <- !is.null(sample_data.list[["dragen_mapping_metrics"]])
runFusionChunk <- runArribaChunk || runDragenFusionChunk
runPcgrChunk <- !is.null(sample_data.list[["wgs"]][["pcgr_tiers_tsv"]])
runPurpleChunk <- !is.null(sample_data.list[["wgs"]][["purple_gene_tsv"]])
runSVsChunk <- (!is.null(sample_data.list[["wgs"]][["sv_tsv"]]) &&
  nrow(sample_data.list[["wgs"]][["sv_tsv"]][["melted"]] > 0))
```

```{r dragen_mapping_metrics, eval=runDragenMappingMetricsChunk}
dragen_mapping_metrics <- sample_data.list[["dragen_mapping_metrics"]]
dragen_reads_tot_input <- dragen_mapping_metrics |>
  dplyr::filter(.data$var == "Total input reads") |>
  dplyr::pull(.data$count)
sample_report_title <- glue("{sample_report_title}, Library size: {round(dragen_reads_tot_input / 1e6, 1)} M reads")
```

```{r mysql_populate, message=FALSE, warning=FALSE}
##### Initiate MySQL command to populate RNA-seq data portal
mysql_populate <- paste0(
  "### MySQL command to insert data for sample \"",
  sample_name,
  "\"\nuse piedb;\nINSERT INTO RNAseq_reports ( ID ,Platform, PatientID, SampleID, Cancer, Source, Project, Report, PMID, Analysis, Summary, Date ) VALUES ( 1000000, \"RNA_seq\""
)
mysql_populate_update <- "ON DUPLICATE KEY UPDATE ID=1000000 ,Platform=\"RNA_seq\""

##### Update MySQL command to populate RNA-seq data portal
mysql_populate <- paste0(
  mysql_populate, ", \"",
  subjectID, "\", \"",
  sample_name, "\", \"",
  params$dataset, "\", \"",
  params$sample_source, "\", \"",
  params$project, "\", \"",
  paste0(sample_name, ".RNAseq_report.html"), "\", \"",
  sample_name, "\", \""
)
mysql_populate_update <- paste0(
  mysql_populate_update,
  ", PatientID=\"", subjectID,
  "\", SampleID=\"", sample_name,
  "\", Cancer=\"", params$dataset,
  "\", Source=\"", params$sample_source,
  "\", Project=\"", params$project,
  "\", Report=\"", paste0(sample_name, ".RNAseq_report.html"),
  "\", PMID=\"", sample_name, "\", Analysis=\""
)
```

```{r cancer_genes_prep, comment = NA, message=FALSE, warning=FALSE}
g1 <- ref_genes.list[["genes_oncokb"]] |>
  dplyr::mutate(UMCCR = "No", Oncogene = "-", TSG = "-", Fusion = "-", Germline = "-") |>
  dplyr::rename(occurrence_num = "# of occurence within resources")
##### Flag Oncogenes, TSGs and fusion genes in the UMCCR cancer genes list
ref_genes.list[["genes_cancer"]] <- ref_genes.list[["genes_cancer"]] |>
  dplyr::mutate(
    germ = if_else(.data$germ, "Yes", "-"),
    fusion = if_else(.data$fusion, "Yes", "-"),
    tumorsuppressor = if_else(.data$tumorsuppressor, "Yes", "-"),
    oncogene = if_else(.data$oncogene, "Yes", "-")
  )

for (gene in ref_genes.list[["genes_cancer"]][["symbol"]]) {
  ##### Check if the UMCCR genes is already reported in OncoKB
  if (gene %in% g1$Hugo_Symbol) {
    g1[g1$Hugo_Symbol == gene, ]$UMCCR <- "Yes"
    g1[g1$Hugo_Symbol == gene, ]$Oncogene <- ref_genes.list[["genes_cancer"]]$oncogene[ref_genes.list[["genes_cancer"]]$symbol == gene]
    g1[g1$Hugo_Symbol == gene, ]$TSG <- ref_genes.list[["genes_cancer"]]$tumorsuppressor[ref_genes.list[["genes_cancer"]]$symbol == gene]
    g1[g1$Hugo_Symbol == gene, ]$Fusion <- ref_genes.list[["genes_cancer"]]$fusion[ref_genes.list[["genes_cancer"]]$symbol == gene]
    g1[g1$Hugo_Symbol == gene, ]$Germline <- ref_genes.list[["genes_cancer"]]$germ[ref_genes.list[["genes_cancer"]]$symbol == gene]
    g1[g1$Hugo_Symbol == gene, "occurrence_num"] <- as.integer(g1[g1$Hugo_Symbol == gene, "occurrence_num"]) + 1L
  } else {
    ##### Add if not present
    r1 <- tibble::tibble(
      "Hugo_Symbol" = gene, "occurrence_num" = 1L,
      "OncoKB Annotated" = "No", "OncoKB Oncogene" = "", "OncoKB TSG" = "",
      "MSK-IMPACT" = "", "MSK-HEME" = "", "Foundation One" = "",
      "Foundation One Heme" = "", "Vogelstein" = "", "Sanger CGC" = "",
      "UMCCR" = "Yes", "Oncogene" = "", "TSG" = "", "Fusion" = "", "Germline" = ""
    )
    g1 <- dplyr::bind_rows(g1, r1)
    g1[g1$Hugo_Symbol == gene, ]$Oncogene <- ref_genes.list[["genes_cancer"]]$oncogene[ref_genes.list[["genes_cancer"]]$symbol == gene]
    g1[g1$Hugo_Symbol == gene, ]$TSG <- ref_genes.list[["genes_cancer"]]$tumorsuppressor[ref_genes.list[["genes_cancer"]]$symbol == gene]
    g1[g1$Hugo_Symbol == gene, ]$Fusion <- ref_genes.list[["genes_cancer"]]$fusion[ref_genes.list[["genes_cancer"]]$symbol == gene]
    g1[g1$Hugo_Symbol == gene, ]$Germline <- ref_genes.list[["genes_cancer"]]$germ[ref_genes.list[["genes_cancer"]]$symbol == gene]
  }
}

##### Make the data frame look nicer
colnames(g1) <- c(
  "Gene", "Gene panels no.", "OncoKB", "Oncogene (OncoKB)", "TSG (OncoKB)",
  "MSK-IMPACT", "MSK-HEME", "Foundation One", "Foundation One Heme",
  "Vogelstein", "Sanger CGC", "UMCCR", "Oncogene", "TSG", "Fusion", "Germline"
)
g1 <- g1 |>
  dplyr::select(
    "Gene", "Oncogene", "TSG", "Fusion", "Germline", "Gene panels no.",
    "UMCCR", "OncoKB", "MSK-IMPACT", "MSK-HEME", "Foundation One",
    "Foundation One Heme", "Vogelstein", "Sanger CGC"
  )
g1[g1 == "No" | g1 == ""] <- "-"
ref_genes.list[["genes_cancer"]] <- g1
ref_genes.list[["genes_oncokb"]] <- g1 |>
  dplyr::filter(Gene %in% ref_genes.list[["genes_oncokb"]][["Hugo_Symbol"]])
rm(g1, r1)
```

```{r goi_summary, comment = NA, message=FALSE, warning=FALSE}
##### Record all genes of interest to make sure that these are not filtered out during read counts data processing
# PCGR annotation of mutated genes in given patient based on PCGR report, including only those with variants classified according to user-defined tier
# Also include splice region variants if specified
if (runPcgrChunk) {
  # check if there are any tiered variants in pcgr
  tmp <- sample_data.list[["wgs"]][["pcgr_tiers_tsv"]] |>
    dplyr::filter(.data$TIER %in% 1:params$pcgr_tier)
  if (nrow(tmp) > 0) {
    ref_genes.list[["summary"]]$Mutated <- RNAsum::genes_pcgr_summary(
      pcgr_tbl = sample_data.list[["wgs"]][["pcgr_tiers_tsv"]],
      tiers = 1:params$pcgr_tier,
      splice_vars = params$pcgr_splice_vars
    )
  } else {
    runPcgrChunk <- FALSE
  }
}

# ARRIBA annotation of gene fusion events detected in given patient
if (runFusionChunk) {
  ref_genes.list[["summary"]]$Fusion <- c(
    RNAsum::fusions_summary(sample_data.list[["arriba_tsv"]]),
    RNAsum::fusions_summary(sample_data.list[["dragen_fusions"]])
  ) |>
    unique() |>
    na.omit()
}

# Annotation of structural variants (SVs) with affected genes in given patient based on SV results
if (runSVsChunk) {
  ref_genes.list[["summary"]]$SV <- RNAsum::sv_summary(sample_data.list[["wgs"]][["sv_tsv"]][["melted"]])
}

# PURPLE annotation of copy-number (CN) altered genes in given patient based on
# PURPLE results, including only those with CN values meeting user-defined thresholds.
if (runPurpleChunk) {
  purple_summary <- sample_data.list$wgs[["purple_gene_tsv"]] |>
    RNAsum::purple_cnv_summary(
      cancer_genes_symbol = ref_genes.list[["genes_cancer"]][["Gene"]],
      cn_bottom = params$cn_loss,
      cn_top = params$cn_gain
    )
  ref_genes.list[["summary"]]$CN <- purple_summary[["dat"]]
  cn_bottom <- purple_summary[["cn_bottom"]]
  cn_top <- purple_summary[["cn_top"]]
}

# Immune reponse markers
ref_genes.list[["summary"]]$Immune <- RNAsum::immune_summary(
  tbl_imarkers = ref_genes.list[["genes_immune"]][["genes_immune_markers"]],
  tbl_igram = ref_genes.list[["genes_immune"]][["genes_immunogram"]],
  igram_param = params$immunogram
)

# HRD (homologous recombination deficiency) genes
ref_genes.list[["summary"]]$HRD <- ref_genes.list[["genes_hrd"]] |>
  dplyr::pull("SYMBOL") |>
  na.omit()

# Cancer genes derived from UMCCR Cancer Gene list (https://github.com/vladsaveliev/NGS_Utils/blob/master/ngs_utils/reference_data/key_genes/umccr_cancer_genes.2019-03-20.tsv) and from OncoKB portal (http://oncokb.org/#/cancerGenes)
ref_genes.list[["summary"]]$Cancer <- ref_genes.list[["genes_cancer"]] |>
  dplyr::pull("Gene") |>
  unique() |>
  na.omit()

##### Record all genes of interest
genes2keep <- unlist(ref_genes.list[["summary"]]) |> unique()
```

```{r goi_annotation, comment = NA, message=FALSE, warning=FALSE}
##### Get gene symbols for the genes of interest. These genes will not be filtered out due to low/insufficient expression

##### Get genes genomic coordinates
gene_info <- tx_gene_id_105 |>
  dplyr::select("GENEID", "GENENAME") |>
  dplyr::rename("ENSEMBL" = "GENEID", "SYMBOL" = "GENENAME")

##### Limit genes annotation to the gene of interest, then
##### remove rows with duplicated ENSEMBL IDs
genes2keep <- gene_info |>
  dplyr::filter(.data$SYMBOL %in% genes2keep)
genes2keep <- genes2keep[!duplicated(genes2keep$ENSEMBL), ]
rownames(genes2keep) <- genes2keep$ENSEMBL

##### Remove rows with duplicated gene symbols (Y_RNAs, SNORs, LINC0s etc). Preferably select ENSEMBL ID that is used in the count data
comb_data <- ref_dataset.list[[dataset]][["combined_data"]]
genes2keep.combined_data <- genes2keep |>
  dplyr::filter(.data$ENSEMBL %in% rownames(comb_data))
genes2keep <- genes2keep |>
  dplyr::filter(!.data$SYMBOL %in% genes2keep.combined_data$SYMBOL)
genes2keep <- genes2keep[!duplicated(genes2keep$SYMBOL), ]
genes2keep <- rbind(genes2keep.combined_data, genes2keep)

##### Add column to store info about filtered genes
genes2keep$EXP <- TRUE

##### Clean the space
rm(gene_info)
```

```{r library_size_plot, message = FALSE, warning = FALSE, fig.width = 12, fig.height = 9}
# Generate violin plot for library size. The colours indicate sample groups,
# as provided in *Target* column in the sample annotation file
target <- ref_dataset.list[[dataset]][["sample_annot"]] |>
  mutate(Target = if_else(.data$Target == sample_name, "Patient", .data$Target))
rownames(target)[rownames(target) == sample_name] <- "Patient"

# Prepare data frame
d <- tibble::tibble(
  Sample = rownames(target),
  Library_size = as.numeric(colSums(comb_data) * 1e-6),
  Target = target[["Target"]]
)

patient_libsize <- d |>
  dplyr::filter(Target == "Patient") |>
  dplyr::pull(Library_size)
library_size <- d |>
  ggplot2::ggplot(aes(x = "", y = Library_size)) +
  ggplot2::geom_violin(fill = "transparent", colour = "grey80", alpha = 0.04) +
  ggforce::geom_sina(aes(colour = Target, group = 1), seed = 42, na.rm = TRUE) +
  ggplot2::geom_hline(yintercept = patient_libsize, colour = "blue", alpha = 0.2, linewidth = 1.2) +
  ggplot2::theme_minimal() +
  ggplot2::scale_y_continuous(breaks = scales::breaks_pretty(8))

PlotsDir <- file.path(results_dir, "InputDataPlots") |>
  fs::dir_create()
ggplot2::ggsave(filename = file.path(PlotsDir, "library_size.png"), plot = library_size)
```

```{r data_transformation_filtering, comment = NA, message=FALSE, warning=FALSE}
##### Filtering to remove low expressed genes. For differential expression and related analyses, gene expression is rarely considered at the level of raw counts since libraries sequenced at a greater depth will result in higher counts. Rather, it is common practice to transform raw counts onto a scale that accounts for such library size differences. Genes with very low counts across all libraries provide little evidence for differential expression. In the biological point of view, a gene must be expressed at some minimal level before it is likely to be translated into a protein or to be biologically important. In addition, the pronounced discretenes of these counts interferes with some of the statistical approximations that are used later in the pipeline. These genes should be filtered out prior to further analysis. Users should filter with CPM rather than filtering on the counts directly, as the latter does not account for differences in library sizes between samples. For instance for the CPM-transformed data we keep only genes that have CPM of 1

##### Transformation to CPM or TPM scale (see these blogs for details https://www.rna-seqblog.com/rpkm-fpkm-and-tpm-clearly-explained/ and https://haroldpimentel.wordpress.com/2014/05/08/what-the-fpkm-a-review-rna-seq-expression-units/ ).  CPM = Counts Per Million,  TPM = Transcripts Per Kilobase Million.

##### For counts data processing consider the investigated sample and internal reference cohort as one group  (regardless of the investigated patient tissue origin), and TCGA data (of any cancer type) as another group. This is to facilitate batch-effects (related with technical aspects) correction process
target_mod <- ref_dataset.list[[dataset]][["sample_annot"]] |>
  dplyr::mutate(
    Dataset = if_else(.data$Dataset == sample_name,
      int_cancer_group, .data$Dataset
    )
  )
targets_mod.list <- unique(target_mod$Dataset)

##### Keep info about samples with the lowest and greatest counts for defined CPM threshold
# numerical summary given a max/min function
summarise_comb_data <- function(f, comb_data) {
  stopifnot(is.function(f))
  sums_vec <- colSums(comb_data)
  res <- as.numeric(sums_vec * 1e-6) |>
    f() |>
    round(digits = 0)
  res
}
cpm.min <- summarise_comb_data(min, comb_data)
cpm.max <- summarise_comb_data(max, comb_data)
##### Create lists with processed data each group
y <- vector("list", length(targets_mod.list)) |> purrr::set_names(targets_mod.list)

#### For each group...
for (group in targets_mod.list) {
  target <- target_mod |> dplyr::filter(.data$Dataset == group)
  dat1 <- comb_data
  dat1 <- dat1[, target_mod$Dataset == group]

  ##### CPM transformation and filtering
  if (params$filter && params$transform == "CPM") {
    ##### Create EdgeR DGEList object
    y[[group]] <- edgeR::DGEList(counts = dat1, group = target$Dataset)

    ##### Keep genes with CPM of at least 1 in more than 10% of samples
    filter.threshold <- 1
    keep <- rowSums(edgeR::cpm(y[[group]]) > filter.threshold) >= ncol(dat1) / 10

    ##### Note which genes of interest are not expressed
    genes2keep$EXP[!rownames(genes2keep) %in% names(keep)] <- FALSE

    ##### Keep the genes of interest too
    keep[names(keep) %in% rownames(genes2keep)] <- TRUE
    y[[group]]$filtered <- y[[group]][keep, , keep.lib.sizes = FALSE]

    ##### Transform the raw-scale to CPM. Add small offset to each observation to avoid taking log of zero
    y[[group]]$transformed <- edgeR::cpm(
      y[[group]],
      normalized.lib.sizes = FALSE, log = params$log, prior.count = 0.25
    )
    y[[group]]$filtered.transformed <- edgeR::cpm(
      y[[group]]$filtered,
      normalized.lib.sizes = FALSE, log = params$log, prior.count = 0.25
    )

    ##### CPM transformation without filtering
  } else if (!params$filter && params$transform == "CPM") {
    ##### Create EdgeR DGEList object
    y[[group]] <- edgeR::DGEList(counts = dat1, group = target$Dataset)

    ##### Transform the raw-scale to CPM. Add small offset to each observation to avoid taking log of zero
    y[[group]]$transformed <- edgeR::cpm(
      y[[group]],
      normalized.lib.sizes = FALSE, log = params$log, prior.count = 0.25
    )

    ##### TPM data transformation. We can convert RPKM to TPM in two different ways: from pre-calculated RPKM, by diving by the sum of RPKM values, or directly from the normalized counts. Here we calculate TPM starting from RPKM values computed using edgeR's rpkm function ( from http://luisvalesilva.com/datasimple/rna-seq_units.html )
    ##### TPM transformation with filtering
  } else if (params$filter && params$transform == "TPM") {
    ##### Get genes lengths
    gene.length <- setNames(as.integer(tx_gene_id_105$GENELENGTH), tx_gene_id_105$GENEID)
    # Select distinct gene ids
    gene.length <- gene.length[!duplicated(names(gene.length))]

    ##### Check for which genes the lenght info is not available and remove them from the data
    genes.no_length <- rownames(dat1)[!rownames(dat1) %in% names(gene.length)]
    dat1 <- dat1[!rownames(dat1) %in% genes.no_length, ]

    ##### Create EdgeR DGEList object
    y[[group]] <- edgeR::DGEList(counts = dat1, group = target$Dataset)

    ##### Convert data into RPKM
    y[[group]]$transformed <- edgeR::rpkm(y[[group]], gene.length = gene.length, normalized.lib.sizes = FALSE, log = FALSE)

    ##### ... and then to TPM scale. Add small offset to each observation to avoid taking log of zero
    if (params$log) {
      y[[group]]$transformed <- log2(RNAsum::tpm_from_rpkm(y[[group]]$transformed + 0.25))

      ##### Keep genes with TPM of at least 1 in more than 10% of samples
      filter.threshold <- 1 + 0.25
      keep <- rowSums(y[[group]]$transformed > filter.threshold) >= ncol(y[[group]]$transformed) / 10

      ##### Note which genes of interest are not expressed
      genes2keep$EXP[!rownames(genes2keep) %in% names(keep)] <- FALSE

      ##### Keep the genes of interest too
      keep[names(keep) %in% rownames(genes2keep)] <- TRUE
      y[[group]]$filtered <- y[[group]]$counts[keep, ]
      y[[group]]$filtered.transformed <- y[[group]]$transformed[keep, ]
    } else {
      y[[group]]$transformed <- RNAsum::tpm_from_rpkm(y[[group]]$transformed)

      ##### Keep genes with TPM of at least 1 in more than 10% of samples
      filter.threshold <- 1
      keep <- rowSums(y[[group]]$transformed > filter.threshold) >= ncol(y[[group]]$transformed) / 10

      ##### Note which genes of interest are not expressed
      genes2keep$EXP[!rownames(genes2keep) %in% names(keep)] <- FALSE

      ##### Keep the genes of interest too
      keep[names(keep) %in% rownames(genes2keep)] <- TRUE
      y[[group]]$filtered <- y[[group]]$counts[keep, ]
      y[[group]]$filtered.transformed <- y[[group]]$transformed[keep, ]
    }

    ##### TPM transformation without filtering
  } else if (!params$filter && params$transform == "TPM") {
    ##### Get genes lengths
    gene.length <- setNames(as.integer(tx_gene_id_105$GENELENGTH), tx_gene_id_105$GENEID)
    # Select distinct gene ids
    gene.length <- gene.length[!duplicated(names(gene.length))]

    ##### Check for which genes the lenght info is not available and remove them from the data
    genes.no_length <- rownames(dat1)[!rownames(dat1) %in% names(gene.length)]
    dat1 <- dat1[!rownames(dat1) %in% genes.no_length, ]

    ##### Create EdgeR DGEList object
    y[[group]] <- edgeR::DGEList(counts = dat1, group = target$Dataset)

    ##### Convert data into RPKM
    y[[group]]$transformed <- edgeR::rpkm(y[[group]], gene.length = gene.length, normalized.lib.sizes = FALSE, log = FALSE)

    ##### ... and then to TPM scale. Add small offset to each observation to avoid taking log of zero
    if (params$log) {
      y[[group]]$transformed <- log2(RNAsum::tpm_from_rpkm(y[[group]]$transformed + 0.25))
    } else {
      y[[group]]$transformed <- RNAsum::tpm_from_rpkm(y[[group]]$transformed)
    }
  }
} # for end

##### Now combine DGEList objects created for each group
y[["comb"]]$transformed <- cbind(
  y[[targets_mod.list[1]]]$transformed,
  y[[targets_mod.list[2]]]$transformed
)
y[["comb"]]$samples <- rbind(
  y[[targets_mod.list[1]]]$samples,
  y[[targets_mod.list[2]]]$samples
)

if (params$filter) {
  ##### Keep only genes present in all sets
  genes_mod <- base::intersect(
    rownames(y[[targets_mod.list[1]]]$filtered),
    rownames(y[[targets_mod.list[2]]]$filtered)
  )
  y[[targets_mod.list[1]]]$filtered <- y[[targets_mod.list[1]]]$filtered[rownames(y[[targets_mod.list[1]]]$filtered) %in% genes_mod, ]
  y[[targets_mod.list[2]]]$filtered <- y[[targets_mod.list[2]]]$filtered[rownames(y[[targets_mod.list[2]]]$filtered) %in% genes_mod, ]
  y[[targets_mod.list[1]]]$filtered.transformed <- y[[targets_mod.list[1]]]$filtered.transformed[rownames(y[[targets_mod.list[1]]]$filtered.transformed) %in% genes_mod, ]
  y[[targets_mod.list[2]]]$filtered.transformed <- y[[targets_mod.list[2]]]$filtered.transformed[rownames(y[[targets_mod.list[2]]]$filtered.transformed) %in% genes_mod, ]

  y[["comb"]]$filtered <- cbind(
    y[[targets_mod.list[1]]]$filtered,
    y[[targets_mod.list[2]]]$filtered
  )
  y[["comb"]]$filtered.transformed <- cbind(
    y[[targets_mod.list[1]]]$filtered.transformed,
    y[[targets_mod.list[2]]]$filtered.transformed
  )
}

##### Clean the space
rm(dat1, target, target_mod, genes_mod, keep)
```

```{r data_transformation_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 6, fig.show="hide"}
##### Assign colours to targets and datasets
target <- ref_dataset.list[[dataset]][["sample_annot"]]
targets.colour <- RNAsum::getColours(target$Target)

##### Collect the most extreme density values for set the x-axis and y-axis boundaries
den1 <- density(y[["comb"]]$transformed[, 1])
den.x <- den1$x
den.y <- den1$y

ncol_transformed <- ncol(y[["comb"]]$transformed)
for (i in 2:ncol_transformed) {
  den <- density(y[["comb"]]$transformed[, i])
  den.x <- sort(c(den.x, den$x))
  den.y <- sort(c(den.y, den$y))
}

##### Plot read counts against transformed data
if (params$filter) {
  data.df <- tibble(
    Transformed = y[["comb"]]$transformed[, ncol_transformed],
    Counts = comb_data[, ncol(comb_data)]
  )
  ##### Keep only genes with read counts below the 99th percentile
  ##### Keep only every 25th gene to reduce the size of the plot
  count_quant <- quantile(data.df[["Counts"]], probs = 0.99)
  data.df <- data.df |>
    dplyr::filter(.data$Counts < count_quant) |>
    dplyr::slice(which(dplyr::row_number() %% 25 == 1))

  ##### Generate plot for filtered data
  counts_vs_transformed <- plotly::plot_ly(
    data.df,
    x = ~Transformed, y = ~Counts,
    width = 800, height = 300, color = I("black"),
    marker = list(size = 5), type = "scatter", mode = "markers",
    name = glue("{params$transform} / Counts (Patient)")
  ) |>
    plotly::add_trace(
      x = c(filter.threshold, filter.threshold),
      y = c(0, max(data.df$Counts)),
      mode = "lines+markers", color = I("red"), name = "Filtering threshold"
    ) |>
    plotly::layout(
      title = "", xaxis = list(title = glue("{params$transform}s")),
      yaxis = list(title = "Counts"), showlegend = TRUE
    )

  ##### Save interactive plot as html file
  RNAsum::saveWidgetFix(counts_vs_transformed, file = file.path(PlotsDir, "counts_vs_transformed.html"))

  plot_legend1 <- c(ext_cancer_group, add_cancer_group, int_cancer_group, "Patient")

  ##### Before filtering
  par(mfrow = c(1, 2))

  dens_transformed_all <- vector("list", length = ncol_transformed)
  for (i in seq_len(ncol_transformed)) {
    dens_transformed_all[[i]] <- density(y[["comb"]]$transformed[, i])
  }

  plot(
    dens_transformed_all[[1]],
    xlim = c(den.x[1], max(data.df$Transformed)),
    ylim = c(den.y[1], den.y[length(den.y)]),
    lwd = 2, las = 2, main = "", xlab = "", col = targets.colour[[2]][1]
  )
  title(main = "Transformed data (unfiltered)", xlab = params$transform)
  abline(v = 0, lty = 3)

  for (i in 2:ncol_transformed) {
    den <- dens_transformed_all[[i]]
    lines(den$x, den$y, lwd = 2, col = targets.colour[[2]][i])
  }
  legend("topright",
    legend = plot_legend1, fill = targets.colour[[1]],
    bty = "n", bg = "transparent"
  )

  data_transformation_nonfiltered <- recordPlot()

  ##### After filtering
  ncol_filt_transformed <- ncol(y[["comb"]]$filtered.transformed)
  dens_filt_transformed_all <- vector("list", length = ncol_filt_transformed)
  for (i in seq_len(ncol_filt_transformed)) {
    dens_filt_transformed_all[[i]] <- density(y[["comb"]]$filtered.transformed[, i])
  }

  plot(dens_filt_transformed_all[[1]],
    lwd = 2, xlim = c(den.x[1], max(data.df$Transformed)),
    ylim = c(den.y[1], den.y[length(den.y)]), las = 2, main = "", xlab = "",
    col = targets.colour[[2]][1]
  )
  title(main = "Transformed and filtered data", xlab = params$transform)
  abline(v = 0, lty = 3)

  for (i in 2:ncol_filt_transformed) {
    den <- dens_filt_transformed_all[[i]]
    lines(den$x, den$y, lwd = 2, col = targets.colour[[2]][i])
  }
  legend("topright",
    legend = plot_legend1, fill = targets.colour[[1]],
    bty = "n", bg = "transparent"
  )

  data_transformation_filtered <- recordPlot()
  # TODO (PD): Convert these to ggplot to save into vars and pngs
  # save
  png(file.path(PlotsDir, "filtering.png"), width = 900, height = 400, pointsize = 14)
  par(mfrow = c(1, 2))
  ##### Before filtering
  plot(density(y[["comb"]]$transformed[, 1]),
    lwd = 2, xlim = c(den.x[1], den.x[length(den.x)]),
    ylim = c(den.y[1], den.y[length(den.y)]),
    las = 2, main = "", xlab = "", col = targets.colour[[2]][1]
  )
  title(main = "Transformed data (unfiltered)", xlab = params$transform)
  abline(v = 0, lty = 3)

  for (i in 2:ncol(y[["comb"]]$transformed)) {
    den <- density(y[["comb"]]$transformed[, i])
    lines(den$x, den$y, lwd = 2, col = targets.colour[[2]][i])
  }
  legend("topright",
    legend = plot_legend1, fill = targets.colour[[1]],
    cex = 0.7, bty = "n", bg = "transparent"
  )

  ##### After filtering
  plot(
    density(y[["comb"]]$filtered.transformed[, 1]),
    lwd = 2, xlim = c(den.x[1], den.x[length(den.x)]),
    ylim = c(den.y[1], den.y[length(den.y)]), las = 2, main = "", xlab = "",
    col = targets.colour[[2]][1]
  )
  title(main = "Transformed and filtered data", xlab = params$transform)
  abline(v = 0, lty = 3)

  for (i in 2:ncol(y[["comb"]]$filtered.transformed)) {
    den <- density(y[["comb"]]$filtered.transformed[, i])
    lines(den$x, den$y, lwd = 2, col = targets.colour[[2]][i])
  }
  legend("topright",
    legend = plot_legend1, fill = targets.colour[[1]],
    cex = 0.7, bty = "n", bg = "transparent"
  )
  invisible(dev.off())

  ##### Without filtering
} else {
  plot(
    density(y[["comb"]]$transformed[, 1]),
    lwd = 2, xlim = c(den.x[1], den.x[length(den.x)]),
    ylim = c(den.y[1], den.y[length(den.y)]), las = 2, main = "", xlab = "",
    col = targets.colour[[2]][1]
  )
  title(main = "Transformed data (unfiltered)", xlab = params$transform)
  abline(v = 0, lty = 3)

  for (i in 2:ncol(y[["comb"]]$transformed)) {
    den <- density(y[["comb"]]$transformed[, i])
    lines(den$x, den$y, lwd = 2, col = targets.colour[[2]][i])
  }
  legend("topright",
    legend = plot_legend1, fill = targets.colour[[1]],
    bty = "n", bg = "transparent"
  )

  data_transformation_nonfiltered <- recordPlot()

  ##### Save the plot as png file
  png(file.path(PlotsDir, "filtering.png"), width = 900, height = 400, pointsize = 14)
  plot(density(y[["comb"]]$transformed[, 1]),
    lwd = 2,
    xlim = c(den.x[1], den.x[length(den.x)]),
    ylim = c(den.y[1], den.y[length(den.y)]),
    las = 2, main = "", xlab = "", col = targets.colour[[2]][1]
  )
  title(main = "Transformed data (unfiltered)", xlab = params$transform)
  abline(v = 0, lty = 3)

  for (i in 2:ncol(y[["comb"]]$transformed)) {
    den <- density(y[["comb"]]$transformed[, i])
    lines(den$x, den$y, lwd = 2, col = targets.colour[[2]][i])
  }
  legend("topright",
    legend = plot_legend1, fill = targets.colour[[1]],
    cex = 0.7, bty = "n", bg = "transparent"
  )
  invisible(dev.off())
}

##### Clean the space
rm(data.df, target, den.x, den.y, comb_data)
```

```{r data_normalisation, comment = NA, message=FALSE, warning=FALSE }
##### During the sample preparation or sequencing process, external factors that are not of biological interest can affect the expression of individual samples. For example, samples processed in the first batch of an experiment can have higher expression overall when compared to samples processed in a second batch. It is assumed that all samples should have a similar range and distribution of expression values. Normalisation for sample-specific effects is required to ensure that the expression distributions of each sample are similar across the entire experiment.

##### TMM normalsation. Trimmed mean of M-values (https://www.ncbi.nlm.nih.gov/pubmed/20196867) (TMM) is performed using the calcNormFactors function in edgeR. The normalisation factors calculated here are used as a scaling factor for the library sizes. TMM is the recommended for most RNA-Seq data where the majority (more than half) of the genes are believed not differentially expressed between any pair of the samples. It adjusts for RNA composition effect, calculates scaling factors for the library sizes with calcNormFactors function using trimmed mean of M-values (TMM) between each pair of samples. Note, that the raw read counts are used to calculate the normalisation factors

#### For each group...
for (group in targets_mod.list) {
  if (params$transform == "CPM") {
    ##### Calculate normalization factors and transformations from the raw-scale to CPM and normalisation using user-defined method
    if (params$filter) {
      y[[group]]$noNorm <- y[[group]]$filtered.transformed
      y[[group]]$filtered$samples["norm.factors"] <- edgeR::calcNormFactors(y[[group]]$filtered, method = params$norm)$samples["norm.factors"]
      y[[group]]$norm <- edgeR::cpm(y[[group]]$filtered, normalized.lib.sizes = TRUE, log = params$log, prior.count = 0.25)
    } else {
      y[[group]]$noNorm <- y[[group]]$transformed
      y[[group]]$samples["norm.factors"] <- edgeR::calcNormFactors(y[[group]], method = params$norm)$samples["norm.factors"]
      y[[group]]$norm <- edgeR::cpm(y[[group]], normalized.lib.sizes = TRUE, log = params$log, prior.count = 0.25)
    }

    ##### Quantile normalsation (from https://www.biostars.org/p/296992/ )
  } else if (params$transform == "TPM") {
    ##### Normalisation using quantile method
    if (params$filter) {
      y[[group]]$noNorm <- y[[group]]$filtered.transformed
      y[[group]]$filtered.transformed <- data.matrix(y[[group]]$filtered.transformed)

      if (tolower(params$norm) != "none") {
        y[[group]]$norm <- preprocessCore::normalize.quantiles(y[[group]]$filtered.transformed, copy = TRUE)
        colnames(y[[group]]$norm) <- colnames(y[[group]]$filtered.transformed)
        rownames(y[[group]]$norm) <- rownames(y[[group]]$filtered.transformed)
      } else {
        y[[group]]$norm <- y[[group]]$filtered.transformed
      }
    } else {
      y[[group]]$noNorm <- y[[group]]$transformed
      y[[group]]$transformed <- data.matrix(y[[group]]$transformed)

      if (tolower(params$norm) != "none") {
        y[[group]]$norm <- preprocessCore::normalize.quantiles(y[[group]]$transformed, copy = TRUE)
        colnames(y[[group]]$norm) <- colnames(y[[group]]$transformed)
        rownames(y[[group]]$norm) <- rownames(y[[group]]$transformed)
      } else {
        y[[group]]$norm <- y[[group]]$transformed
      }
    }
  }
}

##### Combine DGEList objects created for each group
y[["comb"]]$noNorm <- cbind(
  y[[targets_mod.list[1]]]$noNorm,
  y[[targets_mod.list[2]]]$noNorm
)
y[["comb"]]$norm <- cbind(
  y[[targets_mod.list[1]]]$norm,
  y[[targets_mod.list[2]]]$norm
)

ref_dataset.list[[dataset]][["combined_data_processed"]] <- y[["comb"]] |>
  purrr::pluck(if_else(tolower(params$norm) != "none", "norm", "noNorm"))

##### Clean the space
rm(targets_mod.list)
```

```{r data_normalisation_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 6, fig.show="hide"}
##### Plot expression distribution of samples for unnormalised and normalised data
par(mfrow = c(2, 1), mar = c(2, 5, 3, 2))

##### Unnormalised data
boxplot(y[["comb"]]$noNorm,
  las = 2, col = targets.colour[[2]],
  main = "", pch = "", xaxt = "n", outline = FALSE
)
title(main = "Unnormalised data", ylab = params$transform)
legend("topright",
  legend = plot_legend1, fill = targets.colour[[1]],
  horiz = TRUE, bg = "transparent", box.col = "transparent"
)

data_nonnormalised <- recordPlot()

##### Normalised data
boxplot(y[["comb"]]$norm,
  las = 2, col = targets.colour[[2]],
  main = "", pch = "", xaxt = "n", outline = FALSE
)
title(main = glue("Normalised data ({params$norm})"), ylab = params$transform)
legend("topright",
  legend = plot_legend1, fill = targets.colour[[1]],
  horiz = TRUE, bg = "transparent", box.col = "transparent"
)

data_normalised <- recordPlot()

##### Save the plot as png file
# TODO (PD): remove duplicated code chunks, use ggplot objects
png(file.path(PlotsDir, "normalisation.png"), width = 900, height = 700, pointsize = 14)
par(mfrow = c(2, 1), mar = c(2, 5, 3, 2))

##### Unnormalised data
boxplot(y[["comb"]]$noNorm,
  las = 2, col = targets.colour[[2]],
  main = "", pch = "", xaxt = "n", outline = FALSE
)
title(main = "Unnormalised data", ylab = params$transform)
legend("topright",
  legend = plot_legend1, fill = targets.colour[[1]],
  horiz = TRUE, bg = "transparent", cex = 0.7, box.col = "transparent"
)

##### Normalised data
boxplot(y[["comb"]]$norm,
  las = 2, col = targets.colour[[2]], main = "",
  pch = "", xaxt = "n", outline = FALSE
)
title(main = paste0("Normalised data (", params$norm, ")"), ylab = params$transform)
legend("topright",
  legend = plot_legend1, fill = targets.colour[[1]],
  horiz = TRUE, bg = "transparent", cex = 0.7, box.col = "transparent"
)
invisible(dev.off())

##### Clean the space
rm(den, y)
```

```{r batch_effect_correction, comment = NA, message=FALSE, warning=FALSE, eval=params$batch_rm}
##### The strategy for correcting data for batch effects is to consider the investigated sample and internal reference cohort as one group (batch) (regardless of the investigated patient tissue origin), and TCGA data (of any cancer type) as another batch. The objective is to remove as much as possible data variation due to technical factors.
batches <- as.character(ref_dataset.list[[dataset]][["sample_annot"]]$Dataset)

##### Change the sample dataset name to internal reference cohort
batches[match(sample_name, batches)] <- int_cancer_group

##### Perform batch-effect correctrion using limma
ref_dataset.list[[dataset]][["batch_effect_corrected"]] <- limma::removeBatchEffect(
  ref_dataset.list[[dataset]][["combined_data_processed"]],
  batch = batches
)
```

```{r pca, comment = NA, message=FALSE, warning=FALSE}
##### Perform principal component analysis (PCA) using combined-only data and batch-effect corrected data
##### Loop through combined datasets and perform PCA
for (dataset in names(ref_dataset.list)) {
  target <- ref_dataset.list[[dataset]][["sample_annot"]] |>
    dplyr::mutate(
      Dataset = if_else(.data$Dataset == sample_name, "Patient", .data$Dataset),
      Target = if_else(.data$Target == sample_name, "Patient", .data$Target),
    )

  if (params$batch_rm) {
    ref_dataset.list[[dataset]][["pca_combined_data_processed"]] <- RNAsum::pca(
      data = ref_dataset.list[[dataset]][["combined_data_processed"]],
      targets = target, title = "Before batch-effects correction",
      report_dir = results_dir, suffix = "_before_batch_rm"
    )
    ref_dataset.list[[dataset]][["pca_batch_effect_corrected"]] <- RNAsum::pca(
      data = ref_dataset.list[[dataset]][["batch_effect_corrected"]],
      targets = target, title = "After batch-effects correction",
      report_dir = results_dir, suffix = "_after_batch_rm"
    )
    ref_dataset.list[[dataset]][["data_to_report"]] <- ref_dataset.list[[dataset]][["batch_effect_corrected"]]
  } else {
    ref_dataset.list[[dataset]][["pca_combined_data_processed"]] <- RNAsum::pca(
      data = ref_dataset.list[[dataset]][["combined_data_processed"]],
      targets = target, report_dir = results_dir
    )
    ref_dataset.list[[dataset]][["data_to_report"]] <- ref_dataset.list[[dataset]][["combined_data_processed"]]
  }
}

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())
```

```{r rle, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 6, fig.show="hide"}
##### Generate relative log expression (RLE) plot using combined-only data and batch-effect corrected data
##### Loop through combined datasets and generate RLE plot
for (dataset in names(ref_dataset.list)) {
  target <- ref_dataset.list[[dataset]][["sample_annot"]] |>
    dplyr::mutate(
      Dataset = if_else(.data$Dataset == sample_name, "Patient", .data$Dataset),
      Target = if_else(.data$Target == sample_name, "Patient", .data$Target),
    )

  if (params$batch_rm) {
    par(mfrow = c(2, 1), mar = c(2, 5, 3, 2))

    ##### Before batch-effects correction
    EDASeq::plotRLE(ref_dataset.list[[dataset]][["combined_data_processed"]],
      col = targets.colour[[2]], main = "", pch = "", las = 3,
      xaxt = "n", outline = FALSE
    )
    title(main = "Before batch-effects correction", ylab = "RLE")
    legend("topright",
      legend = levels(factor(target$Target)),
      fill = targets.colour[[1]], horiz = TRUE, bg = "transparent",
      box.col = "transparent"
    )

    ref_dataset.list[[dataset]][["rle_combined_data_processed"]] <- recordPlot()

    ##### After batch-effects correction
    EDASeq::plotRLE(ref_dataset.list[[dataset]][["batch_effect_corrected"]],
      col = targets.colour[[2]], main = "", pch = "", las = 3,
      xaxt = "n", outline = FALSE
    )
    title(main = "After batch-effects correction", ylab = "RLE")
    legend("topright",
      legend = levels(factor(target$Target)),
      fill = targets.colour[[1]], horiz = TRUE, bg = "transparent",
      box.col = "transparent"
    )

    ref_dataset.list[[dataset]][["rle_batch_effect_corrected"]] <- recordPlot()


    # TODO (PD): de-duplicate plotting code
    ##### Save the plot as png file
    png(file.path(PlotsDir, "rle.png"), width = 900, height = 700, pointsize = 14)
    par(mfrow = c(2, 1), mar = c(2, 5, 3, 2))

    ##### Before batch-effects correction
    EDASeq::plotRLE(ref_dataset.list[[dataset]][["combined_data_processed"]],
      col = targets.colour[[2]], main = "", pch = "", las = 3,
      xaxt = "n", outline = FALSE
    )
    title(main = "Before batch-effects correction", ylab = "RLE")
    legend("topright",
      legend = levels(factor(target$Target)),
      fill = targets.colour[[1]], horiz = TRUE, bg = "transparent",
      box.col = "transparent"
    )

    ##### After batch-effects correction
    EDASeq::plotRLE(ref_dataset.list[[dataset]][["batch_effect_corrected"]],
      col = targets.colour[[2]], main = "", pch = "", las = 3,
      xaxt = "n", outline = FALSE
    )
    title(main = "After batch-effects correction", ylab = "RLE")
    legend("topright",
      legend = levels(factor(target$Target)),
      fill = targets.colour[[1]], horiz = TRUE, bg = "transparent",
      box.col = "transparent"
    )
    invisible(dev.off())
  } else {
    EDASeq::plotRLE(ref_dataset.list[[dataset]][["combined_data_processed"]],
      col = targets.colour[[2]], main = "", pch = "", las = 3,
      xaxt = "n", outline = FALSE
    )
    title(main = "", ylab = "RLE")
    legend("topright",
      legend = levels(factor(target$Target)),
      fill = targets.colour[[1]], horiz = TRUE, bg = "transparent",
      box.col = "transparent"
    )

    ref_dataset.list[[dataset]][["rle_combined_data_processed"]] <- recordPlot()

    ##### Save the plot as png file
    png(file.path(PlotsDir, "rle.png"), width = 900, height = 450, pointsize = 14)

    EDASeq::plotRLE(ref_dataset.list[[dataset]][["combined_data_processed"]],
      col = targets.colour[[2]], main = "", pch = "", las = 3,
      xaxt = "n", outline = FALSE
    )
    title(main = "", ylab = "RLE")
    legend("topright",
      legend = levels(factor(target$Target)),
      fill = targets.colour[[1]], horiz = TRUE, bg = "transparent",
      box.col = "transparent"
    )
    invisible(dev.off())
  }
}

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())

##### Clean the space
rm(target, targets.colour)
```

```{r gene_annot_count_data, comment = NA, message=FALSE, warning=FALSE}
##### Loop through combined, BUT NOT PROCESSED, datasets and annotate ALL genes. This part is mainly required for biotype detection step
for (dataset in names(ref_dataset.list)) {
  ##### Convert data into a data frame to make the Ensembl ID and gene symbol matches (with merge function)
  dat1 <- ref_dataset.list[[dataset]][["combined_data"]]
  data.df <- as.data.frame(cbind(rownames(dat1), dat1))
  colnames(data.df)[1] <- "ENSEMBL"

  ##### Get genes genomic coordiantes
  ##### Limit genes annotation to those genes for which sample expression measurements are available
  gene_info <- tx_gene_id_105 |>
    dplyr::select(
      "GENEID", "GENEBIOTYPE", "GENENAME", "SEQNAME",
      "GENESEQSTART", "GENESEQEND"
    ) |>
    dplyr::rename("ENSEMBL" = "GENEID", "SYMBOL" = "GENENAME") |>
    dplyr::filter(.data$ENSEMBL %in% data.df$ENSEMBL)

  ##### Remove rows with duplicated ENSEMBL IDs
  gene_info <- gene_info[!duplicated(gene_info$ENSEMBL), ]
  rownames(gene_info) <- gene_info$ENSEMBL

  ##### Remove rows with duplicated gene symbols (Y_RNAs, SNORs, LINC0s etc)
  gene_info <- gene_info[!duplicated(gene_info$SYMBOL), ]

  ##### Add info about immune response markers
  gene_info.immune_markers <- merge(
    gene_info, ref_genes.list[["genes_immune"]]$genes_immune_markers,
    by = "SYMBOL", all.x = TRUE
  )

  ##### Keep only immune response markers for which there is available annotation
  ref_genes.list[["genes_immune"]]$immune_markers <- ref_genes.list[["genes_immune"]]$genes_immune_markers |>
    dplyr::filter(.data$SYMBOL %in% gene_info.immune_markers$SYMBOL)

  ##### Add info about immunogram genes
  if (params$immunogram) {
    gene_info.immunogram <- merge(
      gene_info, ref_genes.list[["genes_immune"]]$genes_immunogram,
      by = "SYMBOL", all.x = TRUE
    )
    gene_info.immunogram <- gene_info.immunogram[!duplicated(gene_info.immunogram[, "ENSEMBL"]), ]

    ##### Keep only immunogram genes for which there is available annotation
    ref_genes.list[["genes_immune"]]$immunogram <- ref_genes.list[["genes_immune"]]$genes_immunogram |>
      dplyr::filter(.data$SYMBOL %in% gene_info.immunogram$SYMBOL)

    ##### Merge genes annotations for immunogram genes and immune markers
    gene_info <- merge(gene_info.immunogram, gene_info.immune_markers[, c("ENSEMBL", "Immune_Cycle_Role")], by = "ENSEMBL")
  } else {
    gene_info <- gene_info.immune_markers
  }

  ##### Merge genes genomic coordinates info with their annotation and expression data
  data.annot <- merge(gene_info, data.df, by = "ENSEMBL", all.x = FALSE)
  rownames(data.annot) <- data.annot$ENSEMBL

  ##### Get data matrix with gene symbols
  imm_cols_select <- c("SYMBOL", "GENEBIOTYPE", "ENSEMBL", "SEQNAME", "GENESEQSTART", "GENESEQEND", "CIC", "Immune_Cycle_Role")
  if (!params$immunogram) {
    imm_cols_select <- imm_cols_select[imm_cols_select != "CIC"]
  }
  ref_dataset.list[[dataset]][["gene_annot_all"]] <- data.annot[, imm_cols_select]

  ##### Save the combined expression matrix, genes list and associated targets into txt files
  write.table(
    RNAsum::prepare2write(ref_dataset.list[[dataset]][["combined_data"]]),
    file = file.path(results_dir, glue("{sample_name}.RNAseq_report.combined_data.txt")),
    sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE, append = FALSE
  )
  write.table(
    RNAsum::prepare2write(ref_dataset.list[[dataset]][["gene_annot_all"]]),
    file = file.path(results_dir, glue("{sample_name}.RNAseq_report.gene_annot_all.txt")),
    sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE, append = FALSE
  )
}

##### Clean the space
rm(dat1, data.df)
```

```{r gene_annot_processed_data, comment = NA, message=FALSE, warning=FALSE}
##### Loop through combined datasets and annotate genes
for (dataset in names(ref_dataset.list)) {
  ##### Convert data into a data frame to make the Ensembl ID and gene symbol matches (with merge function)
  dat1 <- ref_dataset.list[[dataset]][["data_to_report"]]
  data.df <- as.data.frame(cbind(rownames(dat1), dat1))
  colnames(data.df)[1] <- "ENSEMBL"

  ##### Merge genes genomic coordinates info with their annotation and expression data
  data.annot <- merge(gene_info, data.df, by = "ENSEMBL", all.x = FALSE)

  ##### Keep only genes fo which gene symbol is available
  data.annot <- data.annot[!(is.na(data.annot$SYMBOL) | data.annot$SYMBOL == ""), ]
  rownames(data.annot) <- data.annot$SYMBOL

  ##### Get data matrix with gene symbols
  ref_dataset.list[[dataset]][["data_to_report"]] <- apply(data.annot[, colnames(dat1)], 2, as.numeric)
  rownames(ref_dataset.list[[dataset]][["data_to_report"]]) <- data.annot$SYMBOL
  ref_dataset.list[[dataset]][["gene_annot"]] <- data.annot |>
    dplyr::select("SYMBOL", "GENEBIOTYPE", "ENSEMBL", "SEQNAME", "GENESEQSTART", "GENESEQEND", "Immune_Cycle_Role")

  ##### Save the combined expression matrix, genes list and associated targets into txt files
  write.table(
    RNAsum::prepare2write(ref_dataset.list[[dataset]][["data_to_report"]]),
    file = file.path(results_dir, glue("{sample_name}.RNAseq_report.combined_data_processed.txt")),
    sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE, append = FALSE
  )
  write.table(
    RNAsum::prepare2write(toupper(rownames(ref_dataset.list[[dataset]][["data_to_report"]]))),
    file = file.path(results_dir, glue("{sample_name}.RNAseq_report.combined_data_processed.genes.txt")),
    sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE, append = FALSE
  )
  write.table(
    RNAsum::prepare2write(ref_dataset.list[[dataset]][["sample_annot"]]),
    file = file.path(results_dir, glue("{sample_name}.RNAseq_report.sample_annot.txt")),
    sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE, append = FALSE
  )
}

##### Clean the space
rm(dat1, data.df, gene_info)
```

```{r gene_annot_processed_data_save, comment = NA, message=FALSE, warning=FALSE, eval=params$save_tables}
##### Save the entire expression data for all genes measured in patient's sample with cancer genes annotation as a data table html file
##### Generate expression summary table for mutated genes
targets <- ref_dataset.list[[dataset]][["sample_annot"]]
dat1 <- ref_dataset.list[[dataset]][["data_to_report"]]

##### Percentiles
genes.expr.perc <- RNAsum::exprTable(
  type = "perc",
  data = dat1,
  genes = rownames(dat1),
  keep_all = TRUE,
  targets = targets,
  sampleName = sample_name,
  ext_cancer = ext_cancer_group,
  int_cancer = int_cancer_group,
  comp_cancer = comp_cancer_group,
  add_cancer = add_cancer_group,
  genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
  oncokb_annot = ref_genes.list[["genes_oncokb"]],
  cancer_genes = ref_genes.list[["genes_cancer"]],
  scaling = scaling,
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
)

##### Z-scores
genes.expr.z <- RNAsum::exprTable(
  type = "z",
  data = dat1,
  genes = rownames(dat1),
  keep_all = TRUE,
  targets = targets,
  sampleName = sample_name,
  ext_cancer = ext_cancer_group,
  int_cancer = int_cancer_group,
  comp_cancer = comp_cancer_group,
  add_cancer = add_cancer_group,
  genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
  oncokb_annot = ref_genes.list[["genes_oncokb"]],
  cancer_genes = ref_genes.list[["genes_cancer"]],
  scaling = scaling,
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
)

##### Create directory for saving tables
exprTableDir <- file.path(results_dir, "exprTables")
fs::dir_create(exprTableDir)

# TODO (PD): where do these widgets get sucked into the report??
##### Save the expression tables as html file
RNAsum::saveWidgetFix(widget = genes.expr.perc[[1]], file = file.path(exprTableDir, "genes.expr.perc.html"))
RNAsum::saveWidgetFix(widget = genes.expr.z[[1]], file = file.path(exprTableDir, "genes.expr.z.html"))

##### Clean the space
rm(dat1, targets, genes.expr.z, genes.expr.perc)
```

```{r cn_expr_data_prep, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Combine expression data with mutation and CN data if available
expr_data <- ref_dataset.list[[dataset]][["data_to_report"]]
targets <- ref_dataset.list[[dataset]][["sample_annot"]]

##### ...percentiles
expr_data.perc <- RNAsum::exprTable(
  type = "perc",
  data = expr_data,
  genes = rownames(expr_data),
  keep_all = TRUE,
  targets = targets,
  sampleName = sample_name,
  ext_cancer = ext_cancer_group,
  int_cancer = int_cancer_group,
  comp_cancer = comp_cancer_group,
  add_cancer = add_cancer_group,
  scaling = scaling,
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
)[[2]]

expr_genes <- expr_data.perc[["SYMBOL"]]

##### Get the "Diff" (Patient vs [comp_cancer]) Z-scores
expr_data.z <- RNAsum::exprTable(
  type = "z",
  data = expr_data,
  genes = expr_genes,
  keep_all = TRUE,
  targets = targets,
  sampleName = sample_name,
  ext_cancer = ext_cancer_group,
  int_cancer = int_cancer_group,
  comp_cancer = comp_cancer_group,
  add_cancer = add_cancer_group,
  scaling = scaling,
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
)[[2]]

col1 <- "Diff"
if (comp_cancer_group == int_cancer_group) {
  col1 <- paste0("Patient vs ", comp_cancer_group)
}
expr_sel <- function(d) {
  d |>
    tibble::as_tibble() |>
    dplyr::select(c("SYMBOL", dplyr::all_of(col1))) |>
    dplyr::arrange(.data$SYMBOL)
}

expr_data.perc <- expr_sel(expr_data.perc)
expr_data.z <- expr_sel(expr_data.z)

# make sure we have same names in order
stopifnot(all(expr_data.perc[["SYMBOL"]] == expr_data.z[["SYMBOL"]]))

##### Calculate the mean CN for each gene
##### Deal with negative CN values
##### Remove entries with missing gene symbol (mainly variants in intergenic regions)
##### Select just gene and mean cn
cn_data <- sample_data.list[["wgs"]][["purple_gene_tsv"]] |>
  dplyr::mutate(
    MeanCopyNumber = rowMeans(cbind(.data$minCopyNumber, .data$maxCopyNumber)),
    MeanCopyNumber = if_else(.data$MeanCopyNumber < 0, 0, .data$MeanCopyNumber)
  ) |>
  dplyr::filter(.data$gene != "") |>
  dplyr::select("gene", "MeanCopyNumber")

##### Keep only altered genes with CN values below loss threshold (default 5th percentile) and above gain threshold (default 95th percentile)
cn_data.all <- cn_data

##### Get the percentiles from from the CN values
cn_data.all.percent <- quantile(cn_data.all$MeanCopyNumber, probs = seq(0, 1, .05), na.rm = TRUE)

##### Keep only genes with available expression data
cn_data <- cn_data |>
  dplyr::filter(.data$gene %in% expr_data.z[["SYMBOL"]])

##### Add mutation data if available. If PCGR is NULL, returns NULL for gene.mut
##### and unmodified expr_data.z/perc
pcgr_expr1 <- RNAsum::pcgr_expr(
  pcgr = sample_data.list[["wgs"]][["pcgr_tiers_tsv"]],
  expr_data.z = expr_data.z,
  expr_data.perc = expr_data.perc
)

# Prepare CN table
cn_data.sub <- RNAsum::cn_subset(
  gene.mut = pcgr_expr1[["gene.mut"]],
  cn_data = cn_data,
  expr_data.perc = pcgr_expr1[["expr_data.perc"]],
  expr_data.z = pcgr_expr1[["expr_data.z"]]
)
ref_dataset.list[[dataset]][["expr_mut_cn_data_all"]] <- cn_data.sub

##### Limit the data to include only cancer genes
##### Keep genes meeting the user-defined CN values thresholds
ref_dataset.list[[dataset]][["expr_mut_cn_data"]] <- cn_data.sub |>
  dplyr::filter(.data$Gene %in% ref_genes.list[["genes_cancer"]][["Gene"]]) |>
  dplyr::filter(.data$CN <= cn_bottom | .data$CN >= cn_top)

##### Clean the space
rm(cn_data, cn_data.sub, expr_data, targets, expr_data.z, expr_data.perc, expr_genes, pcgr_expr1)
```

```{r cn_data_distribution, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Draw histogram of CN data with percentile vertical thresholds
cn_dist_plot <- plotly::plot_ly(
  x = cn_data.all[["MeanCopyNumber"]], type = "histogram", name = "CN data",
  width = 800, height = 300
) |>
  plotly::add_lines(
    y = seq(0, 1000, 100), x = rep(cn_data.all.percent["5%"], 11),
    line = list(color = "black", dash = "dash"), opacity = 0.4,
    name = "5th percentile", showlegend = TRUE
  ) |>
  plotly::add_lines(
    y = seq(0, 1000, 100), x = rep(cn_data.all.percent["50%"], 11),
    line = list(color = "black", dash = "dash"), opacity = 0.7,
    name = "50th percentile", showlegend = TRUE
  ) |>
  ##### Add 95th percentile threshold
  plotly::add_lines(
    y = seq(0, 1000, 100), x = rep(cn_data.all.percent["95%"], 11),
    line = list(color = "black", dash = "dash"), opacity = 1,
    name = "95th percentile", showlegend = TRUE
  ) |>
  plotly::layout(
    xaxis = list(title = "CN values"), yaxis = list(title = "Frequency"),
    margin = list(l = 50, r = 50, b = 50, t = 50, pad = 4), autosize = FALSE
  )

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())

##### Clean the space
rm(cn_data.all, cn_data.all.percent)
```

```{r known_fusions_prep, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
known_translocations <- RNAsum::known_trans(
  kt_fusiongdb = ref_genes.list[["FusionGDB"]],
  kt_cgi = ref_genes.list[["cancer_biomarkers_trans"]]
)
```

```{r fusions_arriba_processing, comment = NA, message=FALSE, warning=FALSE}
##### Read in the arriba fusion calls
fusions_arriba <- NULL
if (runArribaChunk) {
  fusions_arriba <- RNAsum::arriba_process(
    arriba.fusions = sample_data.list[["arriba_tsv"]],
    known_translocations = known_translocations,
    genes_cancer = ref_genes.list[["genes_cancer"]][["Gene"]]
  )
}
```

```{r fusions_dragen_processing, comment = NA, message=FALSE, warning=FALSE}
##### Read in the dragen fusion calls
fusions_dragen <- NULL
if (runDragenFusionChunk) {
  fusions_dragen <- RNAsum::dragen_fusions_process(
    dragen.fusions = sample_data.list[["dragen_fusions"]],
    known_translocations = known_translocations,
    genes_cancer = ref_genes.list[["genes_cancer"]][["Gene"]]
  )
}
```

```{r fusions_merge, eval = runFusionChunk}
# NULL gets ignored with bind_rows
fusions <- dplyr::bind_rows(fusions_arriba, fusions_dragen)
##### Annotate fusion genes
fusions_ann <- RNAsum::fusions_annot(
  fusions = fusions,
  gene_ann = ref_dataset.list[[dataset]][["gene_annot_all"]]
)
```

```{r fusions_and_sv_data_prep, comment = NA, message=FALSE, warning=FALSE, eval = runSVsChunk}
sv <- sample_data.list[["wgs"]][["sv_tsv"]] |>
  RNAsum::sv_process()

##### Compare fusion genes called by SV caller
##### First limit SV output to fusions only
if (runFusionChunk) {
  sv_fusions <- sv[["melted_variants"]] |>
    dplyr::filter(.data$is_fusion) |>
    dplyr::filter(.data$Genes %in% unique(c(fusions[["geneA"]], fusions[["geneB"]]))) |>
    dplyr::pull(.data$Genes) |>
    unique()

  ##### Flag fusions that were also reported in MANTA
  cond1 <- length(sv_fusions) > 0
  fusions <- fusions |>
    dplyr::rowwise() |>
    dplyr::mutate(
      geneA_dna_support = dplyr::if_else(cond1, .data$geneA %in% sv_fusions, FALSE),
      geneB_dna_support = dplyr::if_else(cond1, .data$geneB %in% sv_fusions, FALSE)
    ) |>
    dplyr::ungroup() |>
    # use desc since values are True (1) / False (0), so go from high (1) to low (0)
    dplyr::arrange(
      dplyr::desc(.data$geneA_dna_support),
      dplyr::desc(.data$geneB_dna_support),
      dplyr::desc(.data$reported_fusion),
      dplyr::desc(.data$fusions_cancer),
      dplyr::desc(.data$split_reads),
      .data$fusion_caller
    )
  fusions_ann <- fusions_ann |>
    dplyr::rowwise() |>
    dplyr::mutate(
      geneA_dna_support = dplyr::if_else(cond1, .data$geneA %in% sv_fusions, FALSE),
      geneB_dna_support = dplyr::if_else(cond1, .data$geneB %in% sv_fusions, FALSE)
    ) |>
    dplyr::ungroup()
  rm(sv_fusions, cond1)
}
```

```{r fusions_circos, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
##### Indicate which fusions have genomic coordinates and can be presented on circos plot
##### Take into account only reported fusions or those with both genes supported by DNA
if (runSVsChunk) {
  fusion_annot_top <- fusions_ann |>
    dplyr::filter(
      .data$reported_fusion | .data$geneA_dna_support | .data$geneB_dna_support
    )
} else {
  fusion_annot_top <- fusions_ann |>
    dplyr::filter(.data$reported_fusion)
}

fusions <- fusions |>
  dplyr::mutate(
    circos = .data$gene_pair %in% fusion_annot_top[["gene_pair"]]
  )
```

```{r immunogram_table_prep, comment = NA, message=FALSE, warning=FALSE, eval = FALSE}
####### TODO: CHANGE eval above to params$immunogram
##### Extract data for Immunogram genes
dat1 <- ref_dataset.list[[dataset]][["data_to_report"]]
dat1 <- dat1[rownames(dat1) %in% ref_genes.list[["genes_immune"]][["genes_immunogram"]][["SYMBOL"]], ]

##### Create lists with calculation results for each individual Cancer-Immunity Cycle (CIC) step
CIC.list <- vector("list", length(unique(ref_genes.list[["genes_immune"]][["genes_immunogram"]][["CIC"]])))
names(CIC.list) <- unique(ref_genes.list[["genes_immune"]][["genes_immunogram"]][["CIC"]])

##### Calculate average expression for each Cancer-Immunity Cycle (CIC) step
for (cic_step in unique(ref_genes.list[["genes_immune"]][["genes_immunogram"]][["CIC"]])) {
  genes <- ref_genes.list[["genes_immune"]][["genes_immunogram"]][["SYMBOL"]][ref_genes.list[["genes_immune"]][["genes_immunogram"]][["CIC"]] %in% cic_step]
  data.sub <- dat1[rownames(dat1) %in% genes, ]
  CIC.list[[cic_step]] <- colMeans(data.sub)
}

##### Convert the list into dataframe
ref_genes.list[["genes_immune"]][["immunogram.df"]] <- t(data.frame(matrix(unlist(CIC.list), nrow = length(CIC.list), byrow = TRUE), stringsAsFactors = FALSE))
colnames(ref_genes.list[["genes_immune"]][["immunogram.df"]]) <- names(CIC.list)
rownames(ref_genes.list[["genes_immune"]][["immunogram.df"]]) <- colnames(data.sub)
rm(dat1)
```

```{r ref_cohorts_summary, comment = NA, message=FALSE, warning=FALSE}
##### Summarise the reference cohorts samples
target <- ref_dataset.list[[dataset]][["sample_annot"]]
ref_ext_cancer <- table(target$Target)[names(table(target$Target)) == ext_cancer_group]
ref_int_cancer <- table(target$Target)[names(table(target$Target)) == int_cancer_group]

if (!is.null(add_cancer_group)) {
  ref_ext_cancer <- table(target$Target)[names(table(target$Target)) == c(ext_cancer_group)] + table(target$Target)[names(table(target$Target)) == c(add_cancer_group)]
}
```

```{r goi_summary_update, comment = NA, message=FALSE, warning=FALSE}
##### Update altered genes in ...
##### ...gene fusion section: Include only those which are DNA-supported (see Structural variants section) or reported in FusionGDB
ref_genes.list[["summary"]]$Fusion <- NULL
if (runFusionChunk) {
  ref_genes.list[["summary"]]$Fusion <- fusions |>
    dplyr::filter(.data$reported_fusion | .data$geneA_dna_support | .data$geneB_dna_support) |>
    dplyr::select("geneA", "geneB") |>
    unlist() |>
    unique()
}

##### ...copy-number (CN) section: include only genes with CN values > 3 or < 0.5
if (runPurpleChunk) {
  #### Keep only genes with user-defined CN values
  ref_genes.list[["summary"]]$CN <- ref_dataset.list[[dataset]][["expr_mut_cn_data"]] |>
    dplyr::filter(.data$CN <= cn_bottom | .data$CN >= cn_top) |>
    dplyr::pull("Gene")
}

##### ...immune markers section: include only genes with available annotation
ref_genes.list[["summary"]]$Immune <- unique(ref_genes.list[["genes_immune"]][["immune_markers"]][["SYMBOL"]])
if (params$immunogram) {
  ref_genes.list[["summary"]]$Immune <- unique(
    c(
      ref_genes.list[["genes_immune"]][["genes_immunogram"]][["SYMBOL"]],
      ref_genes.list[["genes_immune"]][["immune_markers"]][["SYMBOL"]]
    )
  )
}
```

```{r goi_sunburst, comment = NA, message=FALSE, warning=FALSE}
##### Prepare dataframe for Sunburst plot summarising all altered genes
alt_genes.all.list <- ref_genes.list[["summary"]]

##### Don't show cancer genes list (too long)
alt_genes.all.list$Cancer <- NULL

##### Note all altered genes
alt_genes.all <- sort(table(unlist(alt_genes.all.list)), decreasing = TRUE)

for (alt in names(alt_genes.all.list)) {
  ##### Add only alteration type which has at least one alteration detected
  if (length(alt_genes.all[names(alt_genes.all) %in% alt_genes.all.list[[alt]]]) > 0) {
    alt_genes.all.list[[alt]] <- alt_genes.all[names(alt_genes.all) %in% alt_genes.all.list[[alt]]]
  } else {
    alt_genes.all.list[[alt]] <- NULL
  }
}

sunburst.all.df <- tibble::tibble(
  ids = names(alt_genes.all.list),
  labels = names(alt_genes.all.list),
  parents = "",
  values = as.numeric(lengths(alt_genes.all.list)) / 100
)

for (alt in names(alt_genes.all.list)) {
  ##### Add only alteration type which has at least one alteration detected
  if (length(alt_genes.all[names(alt_genes.all) %in% names(alt_genes.all.list[[alt]])]) > 0) {
    sunburst.all.df <- rbind(
      sunburst.all.df,
      tibble::tibble(
        ids = paste(alt, names(alt_genes.all.list[[alt]]), sep = " - "),
        labels = paste0("\t\t", names(alt_genes.all.list[[alt]]), "\t\t"),
        parents = alt,
        values = as.numeric(alt_genes.all.list[[alt]])
      )
    )
  }
}

sunburst_plot <- NULL
sunburst_plot[[1]] <- plotly::plot_ly(
  sunburst.all.df,
  ids = ~ids, labels = ~labels,
  parents = ~parents, values = ~values,
  type = "sunburst", width = 600, height = 600
)

##### Now include only Identify genes that appear in more then two lists
alt_genes.list <- alt_genes.all.list
alt_genes <- alt_genes.all[alt_genes.all > 1]

for (alt in names(alt_genes.list)) {
  ##### Add only alteration type which has at least one alteration detected
  if (length(alt_genes[names(alt_genes) %in% names(alt_genes.list[[alt]])]) > 0) {
    alt_genes.list[[alt]] <- alt_genes[names(alt_genes) %in% names(alt_genes.list[[alt]])]
  } else {
    alt_genes.list[[alt]] <- NULL
  }
}

sunburst.df <- tibble::tibble(
  ids = names(alt_genes.list),
  labels = names(alt_genes.list),
  parents = "",
  values = as.numeric(lengths(alt_genes.list)) / 100
)

for (alt in names(alt_genes.list)) {
  sunburst.df <- rbind(
    sunburst.df,
    tibble::tibble(
      ids = paste(alt, names(alt_genes.list[[alt]]), sep = " - "),
      labels = paste0("\t\t", names(alt_genes.list[[alt]]), "\t\t"),
      parents = alt,
      values = as.numeric(alt_genes.list[[alt]])
    )
  )
}

sunburst_plot[[2]] <- NA
if (nrow(sunburst.df) > 0) {
  sunburst_plot[[2]] <- plotly::plot_ly(
    sunburst.df,
    ids = ~ids, labels = ~labels, parents = ~parents,
    values = ~values, type = "sunburst", width = 600, height = 600
  )
}

##### Create directory for the plots
summaryPlotsDir <- file.path(results_dir, "summaryPlots")
fs::dir_create(summaryPlotsDir)

##### Save interactive plot as html file
RNAsum::saveWidgetFix(widget = sunburst_plot[[1]], file = file.path(summaryPlotsDir, "sunburst_plot_all.html"))

is_sunburst2 <- inherits(sunburst_plot[[2]], "htmlwidget")
if (is_sunburst2) {
  RNAsum::saveWidgetFix(widget = sunburst_plot[[2]], file = file.path(summaryPlotsDir, "sunburst_plot.html"))
}

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())

##### Clean the space
rm(sunburst.all.df, sunburst.df)
```

```{r goi_summary_table, comment = NA, message=FALSE, warning=FALSE}
##### Prepare dataframe for a table summarising all altered genes
##### Create lists with alterations detected in each gene
genes.list <- names(alt_genes.all)
summary_table.list <- vector("list", length(genes.list))
names(summary_table.list) <- genes.list

##### Go through all alterated genes and note the alteration types
for (gene in names(alt_genes.all)) {
  for (alt in names(alt_genes.all.list)) {
    if (gene %in% names(alt_genes.all.list[[alt]])) {
      summary_table.list[[gene]] <- c(summary_table.list[[gene]], "Yes")
    } else {
      summary_table.list[[gene]] <- c(summary_table.list[[gene]], "-")
    }
  }

  ##### Add links to external resources
  ##### Provide link to VICC meta-knowledgebase ( https://search.cancervariants.org )
  summary_table.list[[gene]] <- c(
    summary_table.list[[gene]],
    paste0("<a href='https://search.cancervariants.org/#", gene, "' >VICC</a>")
  )

  ##### Provide link to OncoKB
  if (gene %in% ref_genes.list[["genes_oncokb"]][["Gene"]]) {
    if (
      all(
        ref_genes.list[["genes_oncokb"]] |>
          dplyr::filter(.data$Gene == gene) |>
          dplyr::pull("OncoKB") == "Yes"
      )
    ) {
      summary_table.list[[gene]][length(summary_table.list[[gene]])] <- paste(
        summary_table.list[[gene]][length(summary_table.list[[gene]])],
        paste0("<a href='http://oncokb.org/#/gene/", gene, "' >OncoKB</a>"),
        sep = ", "
      )
    }
  }

  ##### Provide link to CIViC database druggable genes ( https://civicdb.org )
  if (gene %in% ref_genes.list[["civic_clin_evid"]][["gene"]]) {
    summary_table.list[[gene]][length(summary_table.list[[gene]])] <- paste(
      summary_table.list[[gene]][length(summary_table.list[[gene]])],
      paste0(
        "<a href='",
        unique(ref_genes.list[["civic_clin_evid"]][ref_genes.list[["civic_clin_evid"]][["gene"]] == gene, "gene_civic_url"]),
        "' >CIViC</a>"
      ),
      sep = ", "
    )
  }
}

##### Convert the list into data frame
##### Add gene names and number of section in which individual genes are reported
##### Add GeneCards links
summary_table.df <- data.frame(
  matrix(
    unlist(summary_table.list),
    nrow = length(summary_table.list), byrow = TRUE
  )
) |>
  rlang::set_names(c(names(alt_genes.all.list), "Resources")) |>
  dplyr::mutate(
    Gene = names(summary_table.list),
    Count = as.numeric(alt_genes.all),
    Gene = glue("<a href='https://www.genecards.org/cgi-bin/carddisp.pl?gene={.data$Gene}'>{.data$Gene}</a>")
  ) |>
  dplyr::select("Gene", dplyr::any_of(c("Mutated", "Fusion", "SV", "CN", "Immune", "HRD", "Resources", "Count")), dplyr::everything())

##### Clean the space and return output
rm(summary_table.list)
```

Transcriptome summary for patient sample **`r sample_report_title`**.

------------------------------------------------------------------------

<details>

<summary>Input data summary</summary>

**Reference patient cohorts**

The following reference patient cohorts were used for the analysis:

-   **`r glue("{ref_ext_cancer} {ext_cancer_group}")`** samples from [The Cancer Genome Atlas][tcga] project ([related publication][tcga-pub])
-   **`r glue("{ref_int_cancer} {int_cancer_group}")`** samples from [The University of Melbourne Centre for Cancer Research][umccr]

[tcga]: https://umccr.github.io/RNAsum/articles/tcga_projects_summary.html
[tcga-pub]: https://www.nature.com/articles/ng.2764
[umccr]: https://mdhs.unimelb.edu.au/centre-for-cancer-research

**Input genes**

Out of the `r nrow(ref_dataset.list[[dataset]][["combined_data"]])` input genes **`r nrow(data.annot)`** are used for analyses:

-   **`r if (params$filter) { nrow(data.annot) - nrow(genes2keep[ !genes2keep$EXP, ]) } else { ("0") }`** have reliably detected expression
-   **`r if (params$filter) { nrow(genes2keep[ !genes2keep$EXP, ]) } else { ("0") }`** are not expressed but are of interest and are included in analyses
-   `r if (params$filter) { nrow(ref_dataset.list[[dataset]][["combined_data"]]) - nrow(ref_dataset.list[[dataset]][["data_to_report"]]) } else { ("0") }` are either not expressed or their expression level is too low to be detected
-   `r if (params$filter) { nrow(ref_dataset.list[[dataset]][["data_to_report"]]) - nrow(data.annot) } else { nrow(ref_dataset.list[[dataset]][["combined_data"]]) - nrow(data.annot) }` genes were ignored due to lack of [HGNC](https://www.genenames.org/)-approved gene symbol

NOTE, the `r if (params$filter) { nrow(ref_dataset.list[[dataset]][["combined_data"]]) - nrow(ref_dataset.list[[dataset]][["data_to_report"]]) + nrow(genes2keep[ !genes2keep$EXP, ]) } else { ("0") }` genes with no/low expression are indicated in [BLANK]{style="color:#808080"} cells with missing values in *expression summary tables* in [Mutated genes], [Structural variants], [CN altered genes], [Immune markers], [HRD genes] and [Cancer genes] sections.

**Library size**

Violin plot illustrating library size for each sample.

```{r library_size, comment = NA, message=FALSE, warning=FALSE, fig.width = 5, fig.height = 5}
library_size
```

**Data filtering and transformation**

The read count data were converted into **`r params$transform`**s using [*edgeR*](https://bioconductor.org/packages/release/bioc/html/edgeR.html) functions. `r if ( !params$filter ) { c("The option for filtering out genes with low counts is switched OFF") } else if ( params$filter ) { c("Genes with low counts were filtered out") }`. `r if ( !params$log ) { c("The data were not log-transformed") } else if ( params$log ) { c("The data were log2-transformed") }`.

`r if ( params$transform == "CPM" ) { paste0("The CPM of 1 (cut-off for removing low expressed genes) corresponds to ", cpm.min, " reads in sample with the lowest sequencing depth, and ", cpm.max, " reads in sample with the greatest sequencing depth. The plot below presents the relation between read counts and the corresponding ", params$transform, " values in the patient data. The red vertical line indicates the threshold for filtering genes with low counts.") } else { paste0("The plot below presents the relation between read counts and the corresponding ", params$transform, " values in the patient data. The red vertical line indicates the threshold for filtering genes with low counts.") }`

```{r counts_vs_transformed, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = params$filter}
counts_vs_transformed
```

Plot(s) below present `r params$transform` data distribution `r if ( params$filter ) { c(" before and after filtering genes with low counts.") } else { cat(".")}`

```{r data_transformation_display, fig.width = 12, fig.height = 5}
data_transformation_nonfiltered

if (params$filter) {
  data_transformation_filtered
}
```

**Data normalisation**

During the sample preparation or sequencing process, external factors that are not of biological interest can affect the expression of individual samples. It is assumed that all samples should have a similar range and distribution of expression values. Normalisation for sample-specific effects is required to ensure that the expression distributions of each sample are similar across the entire experiment. Normalisation is performed using **`r params$norm`** method.

Box-plots below present `r params$transform` data for individual samples, coloured by sample groups, before and after `r params$norm` normalisation.

```{r data_normalisation_display, fig.width = 12, fig.height = 9}
data_nonnormalised

if (params$norm != "none") {
  data_normalised
}
```

**Exploratory data analysis**

`r if ( params$batch_rm ) { paste0("The expression data produced by different studies are confounded by non-biological experimental variances that prevent direct comparison of samples from different studies. In order to minimise the variance caused by confounding factors [limma removeBatchEffect](http://web.mit.edu/~r/current/arch/i386_linux26/lib/R/library/limma/html/removeBatchEffect.html) method was used to adjust expression measurements for potential batch effects. In brief, the strategy is to consider the investigated sample and the ", paste(ref_int_cancer, int_cancer_group, sep=" "), " samples as one batch (regardless of the investigated sample tissue origin) and ", paste(ref_ext_cancer, ext_cancer_group, sep=" "), " samples (of any cancer type) as another batch. The objective is to remove as much data variation due to technical factors as possible.") }`

Principal component analysis (PCA) was performed to reduce the dimensionality of data to visually assess similarities and differences between samples. This exploratory analysis facilitates identification of the key factors affecting the variability in the expression data.

-   **PCA plot**

`r if ( params$batch_rm ) { paste0("Scatter-plots of the first 2 principal components (PCs) constituting the primary source of variation in the data before and after batch effects correction.") } else { paste0("Scatter-plot of the first 2 principal components (PCs) constituting the primary source of variation in the data.") }`

```{r pca_combined_data_display, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 8 }
ref_dataset.list[[dataset]][["pca_combined_data_processed"]][[2]]

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())
```

```{r pca_batch_effect_corrected_display, comment = NA, message=FALSE, warning=FALSE, eval=params$batch_rm, fig.width = 8, fig.height = 8 }
ref_dataset.list[[dataset]][["pca_batch_effect_corrected"]][[2]]

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())
```

-   **Scree-plot**

`r if ( params$batch_rm ) { paste0("Scree-plots presenting the fraction of total variance (*y-axis*) attributed to each PC (*x-axis*) before and after batch effects correction. The PCs are ordered by decreasing order of contribution to total variance.") } else { paste0("Scree-plot presenting the fraction of total variance (*y-axis*) attributed to each PC (*x-axis*). The PCs are ordered by decreasing order of contribution to total variance. ") }`

```{r scree_combined_data_display, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 5 }
ref_dataset.list[[dataset]][["pca_combined_data_processed"]][[3]]

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())
```

`r if ( params$batch_rm ) { cat("* After batch-effects correction") } else { cat(" ") }`

```{r scree_batch_effect_corrected_display, comment = NA, message=FALSE, warning=FALSE, eval=params$batch_rm, fig.width = 12, fig.height = 5 }
ref_dataset.list[[dataset]][["pca_batch_effect_corrected"]][[3]]

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())
```

-   **RLE plot**

The relative log expression (RLE) plot is a useful diagnostic tool to visualise the differences between the distributions of read counts across samples. It shows boxplot of the log-ratios of the gene-level read counts (*y-axis*) of each sample to those of a reference sample (defined as the median across the samples). Ideally, the distributions should be centered around the zero line and as tight as possible. Clear deviations indicate the need for normalisation and/or the presence of outlying samples.

```{r rle_display, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 9}
ref_dataset.list[[dataset]][["rle_combined_data_processed"]]

if (params$norm != "none") {
  ref_dataset.list[[dataset]][["rle_batch_effect_corrected"]]
}
```

</details>

------------------------------------------------------------------------

## Findings summary {.tabset}

### Per-alteration plot

`r if (is_sunburst2) { c("**Genes** listed **in at least two sections** of this report") } else { c("**All altered genes**")  }` are summarised in the plot below. `r if (is_sunburst2) { c("These genes may be of particular interest given that the evidence for their alteration is derived from multiple sources.")  }` The number next to each gene indicates the number of times it appears across the following report sections: `r if ( runPcgrChunk ) { c("[Mutated genes], ") }` `r if ( runFusionChunk ) { c("[Fusion genes] (supported by genomic data or reported in FusionGDB), ") }` `r if ( runSVsChunk ) { c("[Structural variants], ") }` `r if ( runPurpleChunk ) { paste0("[CN altered genes] (CN values =< ", cn_bottom, " or >= ", cn_top, " and reported as cancer genes)") }` [Immune markers] or [HRD genes]. That number is also reflected by the *width* of corresponding branches. Click on the category of interest to expand corresponding branches. Genes within each category are ordered by the number of report sections in which they appear and then alphabetically.

`r if (!is_sunburst2) { c("<span style=\"color:#ff0000\">NOTE</span>, no genes are listed in more then one section.") }`

```{r findings_summary_plot, comment = NA, message=TRUE, warning=FALSE, fig.width = 8, fig.height = 6 }
# TODO (PD): sunburst plots are lovely, but would searchable tables be more practical?
##### Update MySQL commend to populate RNA-seq data portal
mysql_populate <- paste0(mysql_populate, "Findings summary")
mysql_populate_update <- paste0(mysql_populate_update, "Findings summary")

##### Present per-alteration findings summary sunburst plot for all altered genes
if (is_sunburst2) {
  sunburst_plot[[2]]
} else {
  sunburst_plot[[1]]
}

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())
```

`r if (is_sunburst2) { c("<details>\n<summary>Show all altered genes</summary>") }`

```{r findings_summary_all_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 6 }
##### Present per-alteration findings summary sunburst plot for altered genes listed in at least two report sections
if (is_sunburst2) {
  sunburst_plot[[1]]
}

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())
```

`r if (is_sunburst2) { c("</details>") }`

```{r clear_space, comment = NA, message=FALSE, warning=FALSE }
rm(
  counts_vs_transformed, data_transformation_nonfiltered, data_transformation_filtered,
  data_nonnormalised, data_normalised, data.annot
)
```

------------------------------------------------------------------------

### Per-gene table

Table summarising **all altered genes** listed across following report sections: `r if ( runPcgrChunk ) { c("[Mutated genes], ") }` `r if ( runFusionChunk ) { c("[Fusion genes] (supported by genomic data or reported in FusionGDB), ") }` `r if ( runSVsChunk ) { c("[Structural variants], ") }` `r if ( runPurpleChunk ) { paste0("[CN altered genes] (CN values =< ", cn_bottom, " or >= ", cn_top, " and reported as cancer genes)") }` [Immune markers] or [HRD genes]. The *Resources* column contains links to databases that may provide additional source of evidence for the altered genes' clinical significance. Genes ordered by the number of report sections they appear in (*Count* column) and then alphabetically.

`r if (!is_sunburst2) { c("<span style=\"color:#ff0000\">NOTE</span>, no genes are listed in more then one section.") }`

```{r findings_summary_table, comment = NA, message=FALSE, warning=FALSE }
##### Present per-gene findings summary table
findings.summary <- DT::datatable(
  data = summary_table.df, filter = "none", rownames = FALSE,
  extensions = c("Buttons", "Scroller"),
  options = list(
    pageLength = 10, dom = "Bfrltip",
    buttons = c("excel", "csv", "pdf", "copy", "colvis"),
    scrollX = TRUE, deferRender = TRUE, scrollY = "333px", scroller = TRUE
  ),
  width = 800, height = 455, escape = FALSE,
  caption = htmltools::tags$caption(
    style = "caption-side: top; text-align: left; color:grey; font-size:100%"
  )
) |>
  DT::formatStyle(columns = colnames(summary_table.df), `font-size` = "12px", "text-align" = "center") |>
  ##### Colour cells according to evidence level and trust rating
  DT::formatStyle(
    columns = colnames(summary_table.df)[c(2:ncol(summary_table.df) - 2)],
    backgroundColor = DT::styleEqual(c("-", "Yes"), c("transparent", "black")),
    color = DT::styleEqual(c("-", "Yes"), c("black", "white"))
  )

findings.summary

##### Create directory for tables
summaryTableDir <- file.path(results_dir, "summaryTables")
fs::dir_create(summaryTableDir)
RNAsum::saveWidgetFix(widget = findings.summary, file = paste(summaryTableDir, "findings.summary.html", sep = "/"), selfcontained = TRUE)

##### Clean the space
rm(summary_table.df, findings.summary, sunburst_plot)
```

------------------------------------------------------------------------

## Mutated genes

mRNA expression levels of genes containing single nucleotide variants (SNVs) or insertions/deletions (indels), obtained from the [PCGR](https://github.com/sigven/pcgr) report, in patient's sample and their average mRNA expression in samples from cancer cohorts. NOTE, only PCGR tiers 1-`r params$pcgr_tier` `r if ( params$pcgr_splice_vars ) { c("and non-coding splice region " ) }` variants are reported.

`r if ( !runPcgrChunk ) { c("Mutation data for this sample are **NOT AVAILABLE**.") }`

### - Summary table {.tabset}

Out of the `r length(unique(sample_data.list[["wgs"]][["pcgr_tiers_tsv"]][["SYMBOL"]]))` mutated genes,
`r length(unique(sample_data.list[["wgs"]][["pcgr_tiers_tsv"]][ sample_data.list[["wgs"]][["pcgr_tiers_tsv"]][["TIER"]] %in% c(1:params$pcgr_tier), ]$SYMBOL))`
include tier 1-`r params$pcgr_tier` variants
`r if ( params$pcgr_splice_vars ) { paste0("and ", length(ref_genes.list[["summary"]]$Mutated) - length(unique(sample_data.list[["wgs"]][["pcgr_tiers_tsv"]][ sample_data.list[["wgs"]][["pcgr_tiers_tsv"]]$TIER %in% c(1:params$pcgr_tier), ]$SYMBOL)), " non-coding splice region variant" ) }`.
Of these, the expression of
**`r length(which(ref_genes.list[["summary"]]$Mutated %in% rownames(ref_dataset.list[[dataset]][["data_to_report"]])))`**
was reliably measured in the patient's sample. The remaining
`r length(which(!ref_genes.list[["summary"]]$Mutated %in% rownames(ref_dataset.list[[dataset]][["data_to_report"]])))`
genes are either not expressed or their expression level is too low to be
detected (indicated in [BLANK]{style="color:#808080"} cells with missing values).

#### Percentiles

```{r mut_genes_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = runPcgrChunk}
##### Update MySQL commend to populate RNA-seq data portal
mysql_populate <- paste0(mysql_populate, ",Mutated genes")
mysql_populate_update <- paste0(mysql_populate_update, ",Mutated genes")

##### Generate expression summary table for mutated genes (based on PCGR report)
targets <- ref_dataset.list[[dataset]][["sample_annot"]]
dat1 <- ref_dataset.list[[dataset]][["data_to_report"]]

##### Consider only genes with mutations classified within user-defined tiers
genes <- ref_genes.list[["summary"]]$Mutated

##### Deal with no genes or when more than 10 genes are of interest
if (length(genes) == 0) {
  genes <- NULL
  limit_genes <- FALSE
  genes_no <- 0
} else if (length(genes) > params$top_genes) {
  limit_genes <- TRUE
  genes_no <- params$top_genes
} else {
  limit_genes <- FALSE
  genes_no <- length(genes)
}

mut_genes.expr.perc <- RNAsum::exprTable(
  type = "perc",
  data = dat1,
  genes = genes,
  targets = targets,
  sampleName = sample_name,
  ext_cancer = ext_cancer_group,
  int_cancer = int_cancer_group,
  comp_cancer = comp_cancer_group,
  add_cancer = add_cancer_group,
  genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
  mut_annot = sample_data.list[["wgs"]][["pcgr_tiers_tsv"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")],
  oncokb_annot = ref_genes.list[["genes_oncokb"]],
  cancer_genes = ref_genes.list[["genes_cancer"]][, c("Gene", "Oncogene", "TSG", "Fusion", "Germline")],
  scaling = scaling,
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
)

##### Present the expression summary table
mut_genes.expr.perc[[1]]

##### Save the expression table as html file
##### Create directory for tables
if (params$save_tables) {
  RNAsum::saveWidgetFix(widget = mut_genes.expr.perc[[1]], file = file.path(exprTableDir, "mut_genes.expr.perc.html"), selfcontained = TRUE)
}
```

<details>

<summary>Table legend</summary>

<font size="2">

The [RED]{style="color:#ff0000"} colour range indicate relatively **high expression** (percentile) values and [BLUE]{style="color:#0000ff"} colour range indicate relatively **low expression** (percentile) values in individual sample group. The [BLANK]{style="color:#808080"} cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each mutated gene. Variants' tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided based on information from [PCGR](https://github.com/sigven/pcgr) report. In case of multiple varaints detected in single gene the variant with the lowest tier is reported and other potential consequences are listed in column *CONSEQUENCE_OTHER*. Genes are ordered by **increasing variants TIER** and then by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column.

</font>

</details>

`r if ( runPcgrChunk && length(genes) > 2000 ) { c(paste0("<span style=\"color:#ff0000\">NOTE</span>, the table was truncated to 2000 entries.")) } else { cat("") }`

------------------------------------------------------------------------

#### Z-scores

```{r mut_genes_table, comment = NA, message=FALSE, warning=FALSE, eval = runPcgrChunk, results = "asis"}
mut_genes.expr.z <- RNAsum::exprTable(
  type = "z",
  data = dat1,
  genes = genes,
  targets = targets,
  sampleName = sample_name,
  ext_cancer = ext_cancer_group,
  int_cancer = int_cancer_group,
  comp_cancer = comp_cancer_group,
  add_cancer = add_cancer_group,
  genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
  mut_annot = sample_data.list[["wgs"]][["pcgr_tiers_tsv"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")],
  oncokb_annot = ref_genes.list[["genes_oncokb"]],
  cancer_genes = ref_genes.list[["genes_cancer"]][, c("Gene", "Oncogene", "TSG", "Fusion", "Germline")],
  scaling = scaling,
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
)[[1]]

##### Present the expression summary table
mut_genes.expr.z

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(widget = mut_genes.expr.z, file = file.path(exprTableDir, "mut_genes.expr.z.html"), selfcontained = TRUE)
}

##### Clean the space
rm(mut_genes.expr.z)
```

<details>

<summary>Table legend</summary>

<font size="2">

The [RED]{style="color:#ff0000"} colour range indicate relatively **high expression** (Z-score) values and [BLUE]{style="color:#0000ff"} colour range indicate relatively **low expression** (Z-score) values in individual sample group. The [BLANK]{style="color:#808080"} cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each mutated gene. Variants' tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided based on information from [PCGR](https://github.com/sigven/pcgr) report. In case of multiple varaints detected in single gene the variant with the lowest tier is reported and other potential consequences are listed in column *CONSEQUENCE_OTHER*. Genes are ordered by **increasing variants TIER** and then by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column.

</font>

</details>

`r if ( runPcgrChunk && length(genes) > 2000 ) { c(paste0("<span style=\"color:#ff0000\">NOTE</span>, the table was truncated to 2000 entries.")) } else { cat("") }`

------------------------------------------------------------------------

### - Expression profiles {.tabset}

`r if (exists("limit_genes")) { if (limit_genes) { c(paste0("Expression profiles for ", genes_no, " mutated genes with variants annotated with the lowest [tier](https://pcgr.readthedocs.io/en/latest/tier_systems.html#tier-model-2-pcgr-acmg) and demonstrating the greatest difference in mRNA expression (percentile) values between patient's sample and the average mRNA expression in samples from cancer patients.")) } else { cat(" ") }}`

```{r cdf_plots_mut, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk, results="asis"}
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level for the genes of interest in the context of the overall mRNA expression distribution
output_cdf <- list()
output_counts <- list()
output_density <- list()
genes <- mut_genes.expr.perc[[2]]$SYMBOL

##### For each gene generate:
##### (1) CDF plot and add boxplot below to show the data variance for selected gene in individual groups,
##### (2) bar-plot of read count data across all samples and
##### (3) density plot to demonstrate expression distribution in investigated sample
for (i in 1:genes_no) {
  if (genes_no > 0 && genes[i] %in% rownames(dat1)) {
    ##### CDF plot
    output_cdf[[i]] <- RNAsum::cdfPlot(
      gene = genes[i], data = dat1, targets = targets, sampleName = sample_name,
      ext_cancer = ext_cancer_group, int_cancer = int_cancer_group,
      comp_cancer = comp_cancer_group, add_cancer = add_cancer_group,
      addBoxPlot = TRUE, scaling = scaling, report_dir = results_dir
    )

    ##### Bar-plot of read counts
    ##### First map the gene symbol to Ensembl ID (used in the counts data)
    genes.ENSEMBL <- ref_dataset.list[[dataset]][["gene_annot_all"]] |>
      dplyr::filter(.data$SYMBOL == genes[i]) |>
      dplyr::pull(.data$ENSEMBL) |>
      unique()

    output_counts[[i]] <- RNAsum::barPlot(
      gene = genes.ENSEMBL, data = ref_dataset.list[[dataset]][["combined_data"]],
      y_title = "Counts", targets = targets, sampleName = sample_name,
      ext_cancer = ext_cancer_group, int_cancer = int_cancer_group,
      add_cancer = add_cancer_group
    )

    ##### Density plot - expression distribution
    output_density[[i]] <- RNAsum::densityPlot(
      gene = genes[i], data = dat1, main_title = "", x_title = "Z-score",
      sampleName = sample_name, distributions = c("normal", "bimodal"),
      scaling = scaling
    )
  }

  #### Clear plots to free up some memory
  if (!is.null(dev.list())) invisible(dev.off())
}

##### Now once the plots are ready show them in separate tabs
if (genes_no != 0) {
  for (i in 1:genes_no) {
    if (genes[i] %in% rownames(dat1)) {
      cat("\n#### ", genes[i], "\n")
      cat(renderTags(output_cdf[[i]])$html)
      cat("\n<details>\n")
      cat("\n<summary>Plot legend</summary>\n")
      cat("<font size=\"2\">\n")
      cat(paste0("**Top panel**: distribution of percentile values (*y-axis*) as a function of expression levels (Z-scores, *x-axis*) for *", genes[i], "* in patient's sample (*black dot*) and other reference cancer cohort(s) (median value(s)).\n\n"))
      cat(paste0("**Bottom panel**: box-plot presenting expression level (Z-score) of *", genes[i], "* in patient's sample (*black dot*) and its expression levels observed across samples from other reference cancer cohort(s).\n"))
      cat("\n</font>\n")
      cat("\n</details>\n")
      cat("\n<details>\n")
      cat("\n<summary>Read counts</summary>\n")
      cat(renderTags(output_counts[[i]])$html)
      cat("<font size=\"2\">\n")
      cat(paste0("Bar-plot illustrating read counts for *", genes[i], "* across all samples. The *", genes[i], "* read count in patient's sample is indicated by *black bar*.\n"))
      cat("\n</font>\n")
      cat("\n</details>\n")
      cat("\n<details>\n")
      cat("\n<summary>Expression distribution patterns</summary>\n")
      cat(renderTags(output_density[[i]])$html)
      cat("<font size=\"2\">\n")
      cat(paste0("Plot illustrating distribution of expression levels (Z-scores) of *", genes[i], "* *observed* across all samples along with simulated *normal* and *bimodal* distributions. The *", genes[i], "* expression level observed in patient's sample is indicated by *black dot* in each distribution.\n"))
      cat("\n</font>\n")
      cat("\n</details>\n")
      cat("\n</details>\n")
      cat("\n***\n")
    } else {
      cat("\n#### ", genes[i], "\n")
      cat("\n<span style=\"color:#ff0000\">NOTE</span>, expression data is not available for that gene.\n")
      cat("\n***\n")
    }
  }
  #### Clear plots to free up some memory
  if (!is.null(dev.list())) invisible(dev.off())
} else {
  cat("\nNo alterations were reported.\n")
  cat("\n***\n")
}


##### Clean the space
rm(list = ls(pattern = "^output*"))
rm(limit_genes, dat1)
```

`r if ( !runPcgrChunk ) { c("***") } else { c(" ") }`

## Fusion genes

<details>

<summary>Fusion genes prioritisation</summary>

Fusion genes detected in transcriptome data are prioritised in the following order:

1.  Involvement of fusion gene(s) **detected in genomic data** (if [Structural variants] results are available)
2.  **Detected in transcriptome data** by [Arriba](https://arriba.readthedocs.io/en/latest/)
3.  **Reported** fusion event according to [FusionGDB](https://ccsm.uth.edu/FusionGDB) database
4.  Decreasing number of **split reads**
5.  Decreasing number of **pair reads**
6.  Involvement of **cancer gene(s)** (see [Cancer genes] section)

</details>

<details>

<summary>Fusion genes filtering</summary>

Fusion genes detected in transcriptome data are reported if **at least one** of the following criteria is met:

1.  Involvement of fusion gene(s) **detected in genomic data** (if [Structural variants] results are available)
2.  **Reported** fusion event according to [FusionGDB](https://ccsm.uth.edu/FusionGDB) database
3.  Involvement of **cancer gene(s)** (see [Cancer genes] section)
4.  **Split reads** \> 1
5.  **Pair reads** \> 1 and **split reads** \> 1

</details>

`r if ( !runFusionChunk ) { c("Fusion genes information for this sample is **NOT AVAILABLE**.") }`


### - Summary

Out of the `r if ( runFusionChunk ) { nrow(fusions) } else { c("0") }` fusion event(s) [**`r if ( runFusionChunk ) { nrow(fusions[ fusions$geneA_dna_support | fusions$geneB_dna_support, ]) } else { c("0") }`**]{style="color:#ff0000"} involve **DNA-supported** fusion genes (see [Structural variants] section), [**`r if ( runFusionChunk ) { nrow(fusions[ fusions$reported_fusion, ]) } else { c("0") }`**]{style="color:#02d653"} are **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB)** and [**`r if ( runFusionChunk ) { nrow(fusions[ fusions$fusions_cancer, ]) } else { c("0") }`**]{style="color:#767689"} involve **[Cancer genes]**.

**`r if ( !runFusionChunk ) { c("No fusion genes were detected!") }`**

```{r fusions_summary_table, comment = NA, message=FALSE, warning=FALSE}
##### Create a nice table output (with dataTable)
if (runFusionChunk) {
  ##### Update MySQL command to populate RNA-seq data portal
  mysql_populate <- paste0(mysql_populate, ",Fusion genes")
  mysql_populate_update <- paste0(mysql_populate_update, ",Fusion genes")

  ##### Present gene fusion events in a table
  fusions.summary <- RNAsum::fusions_table(fusions = fusions)
  fusions.summary
} else {
  ##### Create empty table
  cnames <- c(
    "Gene A", "Gene B", "Split reads", "Pair reads", "DNA support (A)",
    "DNA support (B)", "Reported fusion", "Cancer gene(s)", "Fusion gene (A)",
    "Fusion gene (B)", "Breakpoint (A)", "Breakpoint (B)", "Genomic view"
  )
  fusions.table <- RNAsum::empty_tbl(cnames)
  ##### Present gene fusion events in a table
  fusions.summary <- DT::datatable(
    data = fusions.table, filter = "none", rownames = FALSE,
    options = list(
      dom = "Bfrtip", scrollX = TRUE, deferRender = TRUE, scrollY = "100px", scroller = TRUE
    ),
    width = 800, height = 490
  ) |>
    DT::formatStyle(columns = colnames(fusions.table), `font-size` = "12px", "text-align" = "center")
  fusions.summary
}

##### Save the table as html file
if (params$save_tables) {
  ##### Create directory for tables
  fusionsTableDir <- file.path(results_dir, "fusionsTables")
  fs::dir_create(fusionsTableDir)
  RNAsum::saveWidgetFix(widget = fusions.summary, file = file.path(fusionsTableDir, "fusions.summary.html"), selfcontained = TRUE)
}

##### Clean the space and return output
rm(fusions.summary)
```


<details>
<summary>Table legend</summary>
<font size="2">

Cells in [RED]{style="color:#ff0000"} indicate **DNA-supported** fusion genes (see [Structural variants] section), cells in [GREEN]{style="color:#02d653"} indicate fusion events **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB)**, and cells in [GREY]{style="color:#767689"} indicate fusions containing **[Cancer genes]**. Gene fusions reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB) are hyperlinked. Genes known to be involved in gene fusions are flagged based on information provided in [FusionGDB](https://ccsm.uth.edu/FusionGDB) and [Cancer Genome Interpreter](https://www.cancergenomeinterpreter.org/biomarkers) (CGI) databases. *Breakpoint (A/B)* - genomic coordinates of the breakpoints in gene A/B; *Site (A/B)* - location of the breakpoints in gene A/B; *Type* - type of event based on the orientation of the supporting reads and the coordinates of breakpoints

Fusion events are ordered by the following columns:

- **DNA support (A/B)**: DNA-supported fusion gene(s) (see [Structural variants] section).
- **Reported fusion**: fusion event reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB).
- **Cancer gene(s)**: gene fusion events involving [Cancer genes].
- **Split count**: the total number of supporting split reads.
- **Fusion caller**: Arriba first, then DRAGEN.

</font>

</details>

------------------------------------------------------------------------

### - Genomic view

[**`r if ( runFusionChunk ) { nrow(fusions[ (fusions$geneA_dna_support | fusions$geneB_dna_support) & fusions$circos, ]) } else { c("0") }`**]{style="color:#ff0000"} **DNA-supported** fusion genes (see [Structural variants] section) and [**`r if ( runFusionChunk ) { nrow(fusions[ fusions$reported_fusion & fusions$circos, ]) } else { c("0") }`**]{style="color:#02d653"} fusions events **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB)** are presented in the genomic context. [*Red*]{style="color:#ff0000"} is used for links between positions of same chromosomes and [*blue*]{style="color:#0000ff"} for links between different chromosomes. The table at the bottom contains genomic coordinates of individual fusion genes sorted by their genomic location.

[NOTE]{style="color:#ff0000"}:
**`r if ( runFusionChunk ) { nrow(fusions[ (fusions$geneA_dna_support | fusions$geneB_dna_support) & fusions$circos, ]) } else { c("0") }`** of such fusions do not have genomic information available and are not presented on the *circos plot* (see *Genomic view* column in the [- Summary] table).

`r if ( !runSVsChunk ) { c("Genomic data for this sample is **NOT AVAILABLE**.") }`

```{r circos_prep, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 8, eval = runFusionChunk}
##### Keep only reported fusions or those with cancer genes involved
if (runSVsChunk) {
  fusion_annot_top <- fusions_ann[fusions_ann$reported_fusion | fusions_ann$geneA_dna_support | fusions_ann$geneB_dna_support, ]
} else {
  fusion_annot_top <- fusions_ann[fusions_ann$reported_fusion, ]
}

if (nrow(fusion_annot_top) > 0) {
  ##### Create folder for fusion plots
  fusionsPlotDir <- file.path(results_dir, "fusionsPlot")
  fs::dir_create(fusionsPlotDir)
  cyto.info <- RNAsum::rcircos_cyto_info38()
  fusion_annot_top.circos.pairs <- fusion_annot_top |>
    dplyr::select(
      "SEQNAME.geneA", "GENESEQSTART.geneA", "GENESEQEND.geneA",
      Gene.geneA = "geneA",
      "SEQNAME.geneB", "GENESEQSTART.geneB", "GENESEQEND.geneB",
      Gene.geneB = "geneB"
    ) |>
    dplyr::mutate(
      SEQNAME.geneA = paste0("chr", .data$SEQNAME.geneA),
      SEQNAME.geneB = paste0("chr", .data$SEQNAME.geneB)
    ) |>
    dplyr::filter(
      .data$SEQNAME.geneA %in% cyto.info[["Chromosome"]],
      .data$SEQNAME.geneB %in% cyto.info[["Chromosome"]]
    ) |>
    tidyr::drop_na() |>
    as.data.frame()
  colnames(fusion_annot_top.circos.pairs) <- sub("(.*).gene[AB]", "\\1", colnames(fusion_annot_top.circos.pairs))
  colnames(fusion_annot_top.circos.pairs) <- sub("SEQNAME", "Chromosome", colnames(fusion_annot_top.circos.pairs))
  colnames(fusion_annot_top.circos.pairs) <- sub("GENESEQSTART", "chromStart", colnames(fusion_annot_top.circos.pairs))
  colnames(fusion_annot_top.circos.pairs) <- sub("GENESEQEND", "chromEnd", colnames(fusion_annot_top.circos.pairs))
  fusion_annot_top.circos <- rbind(
    fusion_annot_top.circos.pairs[, 1:4],
    fusion_annot_top.circos.pairs[, 5:8]
  ) |> as.data.frame()
  fusion_annot_top.circos.pairs <- fusion_annot_top.circos.pairs[, !colnames(fusion_annot_top.circos.pairs) == "Gene"]

  ##### Generate circos for viewing in HTML report
  RNAsum::rcircos_plot(
    df_circos = fusion_annot_top.circos, df_circos_pairs = fusion_annot_top.circos.pairs, cyto.info = cyto.info
  )
  ##### Generate and save circos into a png file
  png(filename = file.path(fusionsPlotDir, "circosPlot.png"), width = 800, height = 800, units = "px", pointsize = 24)
  RNAsum::rcircos_plot(
    df_circos = fusion_annot_top.circos, df_circos_pairs = fusion_annot_top.circos.pairs, cyto.info = cyto.info
  )
  invisible(dev.off())
  rm(fusion_annot_top.circos, fusion_annot_top.circos.pairs)
} else {
  cat("None of the transcriptome-based fusion events have supporting evidence from DNA data or was previously reported.")
}
```

```{r genomic_view_circos_table_fusions, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
if (nrow(fusion_annot_top) > 0) {
  ##### Clean the table for better presentation
  ##### Dragen + Arriba
  cols1 <- c(
    "geneA", "SEQNAME.geneA", "GENESEQSTART.geneA", "GENESEQEND.geneA",
    "geneB", "SEQNAME.geneB", "GENESEQSTART.geneB", "GENESEQEND.geneB",
    "breakpointA", "breakpointB",
    "split_reads",
    "split_readsA", "split_readsB", "discordant_mates",
    "geneA_dna_support", "geneB_dna_support",
    "reported_fusion", "fusions_cancer"
  )

  # order fusions based on chrom + start
  fusion_annot_top.clean <- fusion_annot_top |>
    dplyr::select(dplyr::any_of(cols1))
  fusions.genomicView <- fusion_annot_top.clean |>
    DT::datatable(
      filter = "none", rownames = FALSE, extensions = c("Buttons", "Scroller"),
      options = list(
        pageLength = 10, dom = "Bfrtip", deferRender = TRUE,
        buttons = c("excel", "csv", "pdf", "copy", "colvis"),
        scroller = TRUE, scrollX = TRUE, scrollY = "167px"
      ),
      width = 800, height = 318, escape = FALSE
    ) |>
    DT::formatStyle(
      columns = names(fusion_annot_top.clean), `font-size` = "12px", "text-align" = "center"
    ) |>
    ##### Highlight rows with fusions involving cancer genes (grey)
    DT::formatStyle(
      "fusions_cancer",
      backgroundColor = DT::styleEqual(
        c(FALSE, TRUE), c("transparent", "lightgrey")
      )
    ) |>
    DT::formatStyle(
      grepl("dna_support", colnames(fusion_annot_top.clean)),
      backgroundColor = DT::styleEqual(
        c(FALSE, TRUE), c("transparent", "coral")
      )
    ) |>
    DT::formatStyle(
      "reported_fusion",
      backgroundColor = DT::styleEqual(
        c(FALSE, TRUE), c("transparent", "lightgreen")
      )
    )
  rm(fusion_annot_top.clean)
  fusions.genomicView
}
```

<details>

<summary>Table legend</summary>

<font size="2">

Cells in [RED]{style="color:#ff0000"} indicate **DNA-supported** fusion genes (see [Structural variants] section), cells in [GREEN]{style="color:#02d653"} indicate gene fusions **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB)**, and cells hihglighted in [GREY]{style="color:#767689"} indicate fusions containing **[Cancer genes]**. Genes known to be involved in gene fusions are flagged based on information provided in [FusionGDB](https://ccsm.uth.edu/FusionGDB) and [Cancer Genome Interpreter](https://www.cancergenomeinterpreter.org/biomarkers) (CGI) databases. Fusion events are ordered by **genomic coordinates** of **Gene A** and then **Gene B**. *DNA support (gene A/B)* - DNA-supported fusion gene(s) (see) [Structural variants] section); *Reported fusion* - fusion event reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB); *Cancer gene(s)* - gene fusion events involving [Cancer genes]

</font>

</details>

```{r genomic_view_table_fusions_save, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
##### Save the table as html file
if (nrow(fusion_annot_top) > 0 && params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = fusions.genomicView, selfcontained = TRUE,
    file = file.path(fusionsTableDir, "fusions.genomicView.html")
  )
  rm(fusions.genomicView)
}
```

------------------------------------------------------------------------

### - Top hits {.tabset}

Expression profiles for gene fusion events involving **DNA-supported fusion** genes (see [Structural variants] section), gene fusions **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB)** or **[Cancer genes]**, indicated in [green]{style="color:#02d653"}, [red]{style="color:#ff0000"} and [grey]{style="color:#767689"} columns in the [Fusion genes] table, respectively, and with the highest *Split count* and *Pair count* values.

[NOTE]{style="color:#ff0000"}: the *visualisation* is available only for fusion genes detected by
[Arriba](https://arriba.readthedocs.io/en/latest/) (see the [- Summary] table).

```{r top_hits_fusions, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
##### Provide detailed expression info for the top ranked fusion events
targets <- ref_dataset.list[[dataset]][["sample_annot"]]
dat1 <- ref_dataset.list[[dataset]][["data_to_report"]]
genes <- as.character(fusions[["geneA"]])

##### Create lists to store
output_cdf_A <- list()
output_cdf_B <- list()
output_counts_A <- list()
output_counts_B <- list()
output_density_A <- list()
output_density_B <- list()
output_table_Z <- list()
output_table_perc <- list()

##### Deal with no genes or when more than X genes are of interest
# This assumes the fusions df has been sorted accordingly
if (length(genes) == 0) {
  genes <- NULL
  genes_no <- 0
} else if (length(genes) > params$top_genes) {
  genes_no <- params$top_genes
} else {
  genes_no <- length(genes)
}

##### Add genes B to the fusions gene list
genes <- c(genes, as.character(fusions$geneB))

##### Collect info and plots for each of the top fusions
for (i in seq_len(genes_no)) {
  geneA <- fusions[["geneA"]][i]
  geneB <- fusions[["geneB"]][i]

  ##### For each gene generate:
  ##### (1) CDF plot and add boxplot below to show the data variance for selected gene in individual groups
  ##### (2) bar-plot of read count data across all samples
  ##### (3) density plot to demonstrate expression distribution in investigated sample
  ##### Gene A
  if (geneA %in% rownames(dat1)) {
    ##### CDF plot
    output_cdf_A[[i]] <- RNAsum::cdfPlot(
      gene = geneA, data = dat1, targets = targets, sampleName = sample_name,
      ext_cancer = ext_cancer_group, int_cancer = int_cancer_group,
      comp_cancer = comp_cancer_group, add_cancer = add_cancer_group,
      addBoxPlot = FALSE, scaling = scaling, report_dir = results_dir
    )
    ##### Bar-plot of read counts
    ##### First map the gene symbol to Ensembl ID (used in the counts data)
    genes.ENSEMBL <- ref_dataset.list[[dataset]][["gene_annot_all"]] |>
      dplyr::filter(.data$SYMBOL == geneA) |>
      dplyr::pull(.data$ENSEMBL)
    output_counts_A[[i]] <- RNAsum::barPlot(
      gene = genes.ENSEMBL, data = ref_dataset.list[[dataset]][["combined_data"]],
      y_title = "Counts", targets = targets, sampleName = sample_name,
      ext_cancer = ext_cancer_group, int_cancer = int_cancer_group,
      add_cancer = add_cancer_group
    )
    ##### Density plot - expression distribution
    output_density_A[[i]] <- RNAsum::densityPlot(
      gene = geneA, data = dat1, main_title = "",
      x_title = "Z-score", sampleName = sample_name,
      distributions = c("normal", "bimodal"), scaling = scaling
    )
  }
  ##### Gene B
  if (geneB %in% rownames(dat1) && geneB != geneA) {
    ##### CDF plot
    output_cdf_B[[i]] <- RNAsum::cdfPlot(
      gene = geneB, data = dat1, targets = targets, sampleName = sample_name,
      ext_cancer = ext_cancer_group, int_cancer = int_cancer_group,
      comp_cancer = comp_cancer_group, add_cancer = add_cancer_group,
      addBoxPlot = FALSE, scaling = scaling, report_dir = results_dir
    )
    ##### Bar-plot of read counts
    ##### First map the gene symbol to Ensembl ID (used in the counts data)
    genes.ENSEMBL <- ref_dataset.list[[dataset]][["gene_annot_all"]] |>
      dplyr::filter(.data$SYMBOL == geneB) |>
      dplyr::pull(.data$ENSEMBL)
    output_counts_B[[i]] <- RNAsum::barPlot(
      gene = genes.ENSEMBL, data = ref_dataset.list[[dataset]][["combined_data"]],
      y_title = "Counts", targets = targets, sampleName = sample_name,
      ext_cancer = ext_cancer_group, int_cancer = int_cancer_group,
      add_cancer = add_cancer_group
    )
    ##### Density plot - expression distribution
    output_density_B[[i]] <- RNAsum::densityPlot(
      gene = geneB, data = dat1, main_title = "",
      x_title = "Z-score", sampleName = sample_name,
      distributions = c("normal", "bimodal"), scaling = scaling
    )
  }

  ##### Generate expression summary tables
  genes <- c(geneA, geneB)

  ##### Z-scores
  output_table_Z[[i]] <- RNAsum::exprTable(
    type = "z",
    data = dat1,
    genes = unique(genes),
    targets = targets,
    sampleName = sample_name,
    ext_cancer = ext_cancer_group,
    int_cancer = int_cancer_group,
    comp_cancer = comp_cancer_group,
    add_cancer = add_cancer_group,
    genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
    oncokb_annot = ref_genes.list[["genes_oncokb"]],
    cancer_genes = ref_genes.list[["genes_cancer"]][, c("Gene", "Oncogene", "TSG", "Germline")],
    fusion_genes = unique(c(known_translocations$geneA, known_translocations$geneB)),
    scaling = scaling,
    civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
  )[[1]]

  ##### Percentiles
  output_table_perc[[i]] <- RNAsum::exprTable(
    type = "perc",
    data = dat1,
    genes = unique(genes),
    targets = targets,
    sampleName = sample_name,
    ext_cancer = ext_cancer_group,
    int_cancer = int_cancer_group,
    comp_cancer = comp_cancer_group,
    add_cancer = add_cancer_group,
    genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
    oncokb_annot = ref_genes.list[["genes_oncokb"]],
    cancer_genes = ref_genes.list[["genes_cancer"]][, c("Gene", "Oncogene", "TSG", "Germline")],
    fusion_genes = unique(c(known_translocations$geneA, known_translocations$geneB)),
    scaling = scaling,
    civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
  )[[1]]
}
#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())
```

```{r top_hits_fusions_display, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 2.5, eval = runFusionChunk, results="asis"}
##### Now once the plots are ready show them in separate tabs
if (genes_no == 0) {
  cat("\nNo alterations were reported.\n")
  cat("\n***\n")
}
# this will do nothing if genes_no = 0
for (i in seq_len(genes_no)) {
  geneA <- fusions[["geneA"]][i]
  geneB <- fusions[["geneB"]][i]
  breakpointA <- fusions[["breakpointA"]][i]
  breakpointB <- fusions[["breakpointB"]][i]

  cat("\n#### ", paste(geneA, geneB, sep = "-"), "\n")

  ##### Check if Arriba fusion plot exists. Skip this section if it doesn't
  png1 <- gsub(":", ".", paste0(results_dir, "/arriba/", make.names(paste(geneA, geneB, sep = "__")), "_", breakpointA, "_", breakpointB, ".png"))
  if (file.exists(png1)) {
    cat("\n##### Fusion genes visualisation\n")
    ##### Present Arriba plots in the report
    cat(glue("![]({png1})"), "\n")
    cat("\n***\n")
  }

  cat("\n##### Fusion genes expression\n")
  cat("\nmRNA expression levels of fusion genes detected in patient's sample and their average mRNA expression (Z-score) in samples from cancer cohorts.\n")

  ##### Display CDF plots for each fusion gene pair
  if (geneA %in% rownames(dat1)) {
    cat(renderTags(output_cdf_A[[i]])$html)
    cat("\n<details>\n")
    cat("\n<summary>Plot legend</summary>\n")
    cat("<font size=\"2\">\n")
    cat(paste0("Distribution of percentile values (*y-axis*) as a function of expression levels (Z-scores, *x-axis*) of *", geneA, "* in patient's sample (*black dot*) and other reference cancer cohort(s) (median value(s)).\n"))
    cat("\n</font>\n")
    cat("\n</details>\n")
    cat("\n<details>\n")
    cat("\n<summary>Read counts</summary>\n")
    cat(renderTags(output_counts_A[[i]])$html)
    cat("<font size=\"2\">\n")
    cat(paste0("Bar-plot illustrating read counts for *", geneA, "* across all samples. The *", geneA, "* read count in patient's sample is indicated by *black bar*.\n"))
    cat("\n</font>\n")
    cat("\n</details>\n")
    cat("\n<details>\n")
    cat("\n<summary>Expression distribution patterns</summary>\n")
    cat(renderTags(output_density_A[[i]])$html)
    cat("<font size=\"2\">\n")
    cat(paste0("Plot illustrating distribution of expression levels (Z-scores) of *", geneA, "* *observed* across all samples along with simulated *normal* and *bimodal* distributions. The *", geneA, "* expression level observed in patient's sample is indicated by *black dot* in each distribution.\n"))
    cat("\n</font>\n")
    cat("\n</details>\n")
    cat("<br />")
  } else {
    cat(paste0("\n<span style=\"color:#ff0000\">NOTE</span>, expression data is not available for ", geneA, ".\n"))
  }

  if (geneB == geneA) {
    cat(paste0("\n"))
  } else if (geneB %in% rownames(dat1)) {
    cat(renderTags(output_cdf_B[[i]])$html)
    cat("\n<details>\n")
    cat("\n<summary>Plot legend</summary>\n")
    cat("<font size=\"2\">\n")
    cat(paste0("Distribution of percentile values (*y-axis*) as a function of expression levels (Z-scores, *x-axis*) of *", geneB, "* in patient's sample (*black dot*) and other reference cancer cohort(s) (median value(s)).\n"))
    cat("\n</font>\n")
    cat("\n</details>\n")
    cat("\n<details>\n")
    cat("\n<summary>Read counts</summary>\n")
    cat(renderTags(output_counts_B[[i]])$html)
    cat("<font size=\"2\">\n")
    cat(paste0("Bar-plot illustrating read counts for *", geneB, "* across all samples. The *", geneB, "* read count in patient's sample is indicated by *black bar*.\n"))
    cat("\n</font>\n")
    cat("\n</details>\n")
    cat("\n<details>\n")
    cat("\n<summary>Expression distribution patterns</summary>\n")
    cat(renderTags(output_density_B[[i]])$html)
    cat("<font size=\"2\">\n")
    cat(paste0("Plot illustrating distribution of expression levels (Z-scores) of *", geneB, "* *observed* across all samples along with simulated *normal* and *bimodal* distributions. The *", geneB, "* expression level observed in patient's sample is indicated by *black dot* in each distribution.\n"))
    cat("\n</font>\n")
    cat("\n</details>\n")
    cat("\n***\n")
  } else {
    cat(paste0("\n<span style=\"color:#ff0000\">NOTE</span>, expression data is not available for ", geneB, ".\n"))
  }

  cat("\n##### Summary table {.tabset}\n")
  cat("\n###### Percentiles\n")
  cat(renderTags(output_table_perc[[i]])$html)
  cat("<br />")
  cat("\n<details>\n")
  cat("\n<summary>Table legend</summary>\n")
  cat("\n<font size=\"2\">\n")
  cat("\nThe <span style=\"color:#ff0000\">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style=\"color:#0000ff\">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The **Diff** (**Patient vs ", comp_cancer_group, " **) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes) database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs ", comp_cancer_group, "**) column. *TSG* - tumour suppressor gene\n")
  cat("\n</font>\n")
  cat("\n</details>\n")

  if (length(genes) > 2000) {
    cat(paste0("<span style=\"color:#ff0000\">NOTE</span>, the table was truncated to 2000 entries."))
  }

  cat("\n***\n")

  cat("\n###### Z-scores\n")
  cat(renderTags(output_table_Z[[i]])$html)
  cat("<br />")
  cat("\n<details>\n")
  cat("\n<summary>Table legend</summary>\n")
  cat("\n<font size=\"2\">\n")
  cat(paste0("\nThe <span style=\"color:#ff0000\">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style=\"color:#0000ff\">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The **Diff** (**Patient vs ", comp_cancer_group, "**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes) database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs ", comp_cancer_group, "**) column. *TSG* - tumour suppressor gene\n"))
  cat("\n</font>\n")
  cat("\n</details>\n")

  if (length(genes) > 2000) {
    cat(paste0("<span style=\"color:#ff0000\">NOTE</span>, the table was truncated to 2000 entries."))
  }

  cat("\n***\n")
}
if (!is.null(dev.list())) invisible(dev.off())
rm(list = ls(pattern = "^output*"))
```

------------------------------------------------------------------------
## Structural variants

mRNA expression levels of genes located within detected structural variants (SVs),
obtained from the [Manta](https://github.com/Illumina/manta) SV caller,
in the patient's sample and their average mRNA expression in samples from cancer cohorts.

`r if ( !runSVsChunk ) { c("SVs information for this sample is **NOT AVAILABLE**") }`

### - Summary table {.tabset}

Out of the `r if ( runSVsChunk ) { nrow(manta_sv$genes_all) }` genes affected by `r if ( runSVsChunk ) { manta_sv$total_variants }` SVs, the expression of **`r if ( runSVsChunk ) { sum(manta_sv$genes_all$Genes %in% rownames(ref_dataset.list[[dataset]][["data_to_report"]])) } else { length(NULL) }`** was reliably measured in the patient's sample. The remaining `r if ( runSVsChunk ) { sum(!manta_sv$genes_all$Genes %in% rownames(ref_dataset.list[[dataset]][["data_to_report"]])) }` genes are either not expressed or their expression level is too low to be detected (indicated in [BLANK]{style="color:#808080"} cells with missing values).

#### Percentiles

```{r sv_genes_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = runSVsChunk}
##### Update MySQL commend to populate RNA-seq data portal
mysql_populate <- paste0(mysql_populate, ",Structural variants")
mysql_populate_update <- paste0(mysql_populate_update, ",Structural variants")

##### Generate expression summary table for cancer genes from OncoKB and UMCCR (https://github.com/vladsaveliev/NGS_Utils/blob/master/ngs_utils/reference_data/key_genes/umccr_cancer_genes.2019-03-20.tsv)
targets <- ref_dataset.list[[dataset]][["sample_annot"]]
dat1 <- ref_dataset.list[[dataset]][["data_to_report"]]

##### Consider only SVs with known genes and those in SV output for which the expression levels were measured
genes <- sv$genes_all$Genes
genes <- genes[genes %in% ref_dataset.list[[dataset]][["gene_annot_all"]]$SYMBOL]

##### Deal with no genes or when more than 10 genes are of interest
if (length(genes) == 0) {
  genes <- NULL
  limit_genes <- FALSE
  genes_no <- 0
} else if (length(genes) > params$top_genes) {
  limit_genes <- TRUE
  genes_no <- params$top_genes
} else {
  limit_genes <- FALSE
  genes_no <- length(genes)
}

sv_genes.expr.perc <- RNAsum::exprTable(
  type = "perc",
  data = dat1,
  genes = genes,
  sv_data = sv[["melted_variants"]],
  targets = targets,
  sampleName = sample_name,
  ext_cancer = ext_cancer_group,
  int_cancer = int_cancer_group,
  comp_cancer = comp_cancer_group,
  add_cancer = add_cancer_group,
  genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
  oncokb_annot = ref_genes.list[["genes_oncokb"]],
  cancer_genes = ref_genes.list[["genes_cancer"]][, c("Gene", "Oncogene", "TSG", "Fusion", "Germline")],
  scaling = scaling,
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
)

##### Present the expression summary table
sv_genes.expr.perc[[1]]

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = sv_genes.expr.perc[[1]], selfcontained = TRUE,
    file = file.path(exprTableDir, "sv_genes.expr.perc.html")
  )
}
```

<details>

<summary>Table legend</summary>

<font size="2">

The [RED]{style="color:#ff0000"} colour range indicate relatively **high expression** (percentile) values and [BLUE]{style="color:#0000ff"} colour range indicate relatively **low expression** (percentile) values in individual sample group. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes) database, are also indicated. Genes are ordered by **increasing SV score** and then by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) columns. *TSG* - tumour suppressor gene

**Tier**: SV priority score based on AstraZeneca [simple_sv_annotation.py](https://github.com/AstraZeneca-NGS/simple_sv_annotation/blob/master/simple_sv_annotation.py#L21-L36) script; *1 = high* and *4 = low priority*

</font>

</details>

`r if ( runSVsChunk && length(genes) > 2000 ) { c(paste0("<span style=\"color:#ff0000\">NOTE</span>, the table was truncated to 2000 entries.")) } else { cat("") }`

------------------------------------------------------------------------

#### Z-scores

```{r sv_genes_table, comment = NA, message=FALSE, warning=FALSE, eval = runSVsChunk}
##### Generate expression summary table for cancer genes from OncoKB and UMCCR (https://github.com/vladsaveliev/NGS_Utils/blob/master/ngs_utils/reference_data/key_genes/umccr_cancer_genes.2019-03-20.tsv)
sv_genes.expr.z <- RNAsum::exprTable(
  type = "z",
  data = dat1,
  genes = genes,
  sv_data = sv[["melted_variants"]],
  targets = targets,
  sampleName = sample_name,
  ext_cancer = ext_cancer_group,
  int_cancer = int_cancer_group,
  comp_cancer = comp_cancer_group,
  add_cancer = add_cancer_group,
  genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
  cancer_genes = ref_genes.list[["genes_cancer"]][, c("Gene", "Oncogene", "TSG", "Fusion", "Germline")],
  oncokb_annot = ref_genes.list[["genes_oncokb"]],
  scaling = scaling,
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
)

##### Present the expression summary table
sv_genes.expr.z[[1]]

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = sv_genes.expr.z[[1]], selfcontained = TRUE,
    file = file.path(exprTableDir, "sv_genes.expr.z.html")
  )
}

##### Clean the space
rm(sv_genes.expr.z)
```

<details>

<summary>Table legend</summary>

<font size="2">

The [RED]{style="color:#ff0000"} colour range indicate relatively **high expression** (Z-score) values and [BLUE]{style="color:#0000ff"} colour range indicate relatively **low expression** (Z-score) values in individual sample group. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes) database, are also indicated. Genes are ordered by **increasing SV score** and then by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. *TSG* - tumour suppressor gene

**Tier**: SV priority score based on AstraZeneca [simple_sv_annotation.py](https://github.com/AstraZeneca-NGS/simple_sv_annotation/blob/master/simple_sv_annotation.py#L21-L36) script; **1 = high** and **4 = low priority**

</font>

</details>

`r if ( runSVsChunk && length(genes) > 2000 ) { c(paste0("<span style=\"color:#ff0000\">NOTE</span>, the table was truncated to 2000 entries.")) } else { cat("") }`

------------------------------------------------------------------------

### - Expression profiles {.tabset}

`r if ( exists("limit_genes") ) { if ( limit_genes ) { c(paste0("Expression profiles for ", genes_no, " SVs-affected genes with the highest priority (low [tier](https://github.com/AstraZeneca-NGS/simple_sv_annotation/blob/master/simple_sv_annotation.py#L21-L36)) and demonstrating the greatest difference in mRNA expression (percentile) values between patient's sample and the average mRNA expression in samples from cancer patients.")) } else { cat(" ") }}`

```{r cdf_plots_sv, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk, results="asis"}
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level for the genes of interest in the context of the overall mRNA expression distribution
output_cdf <- list()
output_counts <- list()
output_density <- list()
genes <- unique(sv_genes.expr.perc[[2]]$SYMBOL)

##### For each gene generate (1) CDF plot and add boxplot below to show the data variance for selected gene in individual groups, (2) bar-plot of read count data across all samples and (3) density plot to demonstrate expression distribution in investigated sample
for (i in 1:genes_no) {
  if (genes_no > 0 && genes[i] %in% rownames(dat1)) {
    ##### CDF plot
    output_cdf[[i]] <- RNAsum::cdfPlot(
      gene = genes[i], data = dat1, targets = targets,
      sampleName = sample_name, ext_cancer = ext_cancer_group,
      int_cancer = int_cancer_group, comp_cancer = comp_cancer_group,
      add_cancer = add_cancer_group, addBoxPlot = TRUE,
      scaling = scaling, report_dir = results_dir
    )

    ##### Bar-plot of read counts
    ##### First map the gene symbol to Ensmebl ID (used in the counts data)
    genes.ENSEMBL <- ref_dataset.list[[dataset]][["gene_annot_all"]] |>
      dplyr::filter(.data$SYMBOL == genes[i]) |>
      dplyr::pull(.data$ENSEMBL)

    output_counts[[i]] <- RNAsum::barPlot(
      gene = genes.ENSEMBL, data = ref_dataset.list[[dataset]][["combined_data"]],
      y_title = "Counts", targets = targets, sampleName = sample_name,
      ext_cancer = ext_cancer_group, int_cancer = int_cancer_group, add_cancer = add_cancer_group
    )

    ##### Density plot - expression distribution
    output_density[[i]] <- RNAsum::densityPlot(
      gene = genes[i], data = dat1, main_title = "", x_title = "Z-score",
      sampleName = sample_name, distributions = c("normal", "bimodal"), scaling = scaling
    )
  }
}

##### Now once the plots are ready show them in separate tabs
if (genes_no != 0) {
  for (i in 1:genes_no) {
    if (genes[i] %in% rownames(dat1)) {
      cat("\n#### ", genes[i], "\n")
      cat(renderTags(output_cdf[[i]])$html)
      cat("\n<details>\n")
      cat("\n<summary>Plot legend</summary>\n")
      cat("<font size=\"2\">\n")
      cat(paste0("**Top panel**: distribution of percentile values (*y-axis*) as a function of expression levels (Z-scores, *x-axis*) for *", genes[i], "* in patient's sample (*black dot*) and other reference cancer cohort(s) (median value(s)).\n\n"))
      cat(paste0("**Bottom panel**: box-plot presenting expression level (Z-score) of *", genes[i], "* in patient's sample (*black dot*) and its expression levels observed across samples from other reference cancer cohort(s).\n"))
      cat("\n</font>\n")
      cat("\n</details>\n")
      cat("\n<details>\n")
      cat("\n<summary>Read counts</summary>\n")
      cat(renderTags(output_counts[[i]])$html)
      cat("<font size=\"2\">\n")
      cat(paste0("Bar-plot illustrating read counts for *", genes[i], "* across all samples. The *", genes[i], "* read count in patient's sample is indicated by *black bar*.\n"))
      cat("\n</font>\n")
      cat("\n</details>\n")
      cat("\n<details>\n")
      cat("\n<summary>Expression distribution patterns</summary>\n")
      cat(renderTags(output_density[[i]])$html)
      cat("<font size=\"2\">\n")
      cat(paste0("Plot illustrating distribution of expression levels (Z-scores) of *", genes[i], "* *observed* across all samples along with simulated *normal* and *bimodal* distributions. The *", genes[i], "* expression level observed in patient's sample is indicated by *black dot* in each distribution.\n"))
      cat("\n</font>\n")
      cat("\n</details>\n")
      cat("\n***\n")
    } else {
      cat("\n#### ", genes[i], "\n")
      cat("\n<span style=\"color:#ff0000\">NOTE</span>, expression data is not available for that gene.\n")
      cat("\n***\n")
    }
  }
  #### Clear plots to free up some memory
  if (!is.null(dev.list())) invisible(dev.off())
} else {
  cat("\nNo alterations were reported.\n")
  cat("\n***\n")
}

##### Clean the space
rm(list = ls(pattern = "^output*"))
rm(limit_genes)
```

`r if ( !runSVsChunk ) { c("***") } else { c(" ") }`

## CN altered genes

Section overlaying the mRNA expression data with per-gene somatic copy-number (CN) data (from [PURPLE](https://github.com/hartwigmedical/hmftools/tree/master/purple)), as well as SNVs/indels and SV data, if available.

`r if ( !runPurpleChunk ) { c("CN information for this sample is **NOT AVAILABLE**.") }`

### - Genomic view

`r if (runPurpleChunk) { nrow(ref_dataset.list[[dataset]][["expr_mut_cn_data_all"]])} else { cat("0") }` genes with available CN data (*y-axis*) are presented in the genomic context (*x-axis*). **`r if (runPurpleChunk) { nrow(ref_dataset.list[[dataset]][["expr_mut_cn_data"]]) } else { length(NULL) }`** of them (indicated by [*red*]{style="color:#FF0000"}) are [Cancer genes] and are gained `r if ( runPurpleChunk ) { paste0("(CN values >= ", cn_top, ")") }` or lost `r if ( runPurpleChunk ) { paste0("(CN values <= ", cn_bottom, ")") }`. All other genes are marked in [*gray*]{style="color:#808080"}/*black* (alternating per chromosome).

```{r cn_genomic_view, comment = NA, message=FALSE, warning=FALSE, fig.width = 8.3, fig.height = 4, eval = runPurpleChunk}
##### Update MySQL commend to populate RNA-seq data portal
mysql_populate <- paste0(mysql_populate, ",CN altered genes")
mysql_populate_update <- paste0(mysql_populate_update, ",CN altered genes")

##### Generate genomic view plot with per-gene CN values (y-axis) along chromosomal coordinates (x-axis)
dat1 <- ref_dataset.list[[dataset]][["expr_mut_cn_data_all"]]
data.sub <- ref_dataset.list[[dataset]][["expr_mut_cn_data"]]

##### Add fusion genes
if (runFusionChunk) {
  dat1 <- dat1 |>
    dplyr::mutate(
      Alterations = dplyr::if_else(
        .data$Gene %in% c(fusions[["geneA"]], fusions[["geneB"]]),
        paste0(.data$Alterations, "; Fusion"),
        .data$Alterations
      )
    )
  data.sub <- data.sub |>
    dplyr::mutate(
      Alterations = dplyr::if_else(
        .data$Gene %in% c(fusions[["geneA"]], fusions[["geneB"]]),
        paste0(.data$Alterations, "; Fusion"),
        .data$Alterations
      )
    )
}

##### Add SV genes
if (runSVsChunk) {
  dat1 <- dat1 |>
    dplyr::mutate(
      Alterations = dplyr::if_else(
        .data$Gene %in% sv[["melted_variants"]][["Genes"]],
        paste0(.data$Alterations, "; SV"),
        .data$Alterations
      )
    )
  data.sub <- data.sub |>
    dplyr::mutate(
      Alterations = dplyr::if_else(
        .data$Gene %in% sv[["melted_variants"]][["Genes"]],
        paste0(.data$Alterations, "; SV"),
        .data$Alterations
      )
    )
}

##### Remove altaration status "None" for gene which are not mutated but are involved in fusions or SVs
dat1$Alterations <- gsub("None", "CN", dat1$Alterations)
data.sub$Alterations <- gsub("None", "CN", data.sub$Alterations)

##### Prepare dataframe for manhattanly
##### Keep only genes for which both genes have gene symbol (and genomics location) available
dat1 <- dat1 |>
  dplyr::filter(.data$Gene %in% ref_dataset.list[[dataset]][["gene_annot"]][["SYMBOL"]])
names(dat1)[match("CN", names(dat1))] <- "P"

##### Merge genes genomic coordinates info with their annotation and expression data
data.annot <- merge(dat1, ref_dataset.list[[dataset]][["gene_annot"]], by.x = "Gene", by.y = "SYMBOL", all.x = FALSE)
# need to change X, Y, MT to 23, 24, 25.
data.annot <- data.annot |>
  dplyr::mutate(
    SEQNAME = dplyr::case_when(
      .data$SEQNAME == "X" ~ "23",
      .data$SEQNAME == "Y" ~ "24",
      .data$SEQNAME %in% c("M", "MT") ~ "25",
      .default = as.character(.data$SEQNAME)
    ),
    SEQNAME = as.integer(.data$SEQNAME)
  )

if (nrow(data.annot) > 0) {
  ##### Get plot results first to extract x-axis coordinated to annotate genes of interest
  manhattanr.res <- manhattanly::manhattanr(
    x = data.annot, chr = "SEQNAME", bp = "GENESEQSTART",
    p = "P", snp = "Gene", gene = "Diff_Z_score", annotation1 = "Diff_Perc",
    annotation2 = "Alterations", logp = FALSE
  )

  ##### Restrict the results to the genes of interest
  manhattanr.res$data <- manhattanr.res$data |>
    dplyr::filter(.data$Gene %in% data.sub$Gene)

  p <- manhattanly::manhattanly(
    x = data.annot, chr = "SEQNAME", bp = "GENESEQSTART",
    p = "P", snp = "Gene", gene = "Diff_Z_score",
    annotation1 = "Diff_Perc", annotation2 = "Alterations",
    suggestiveline = cn_top, genomewideline = cn_bottom,
    suggestiveline_color = "gray", genomewideline_color = "gray",
    ylab = "CN value", showgrid = FALSE, title = "", logp = FALSE
  ) |>
    plotly::add_trace(
      y = manhattanr.res$data$P,
      x = manhattanr.res$data$pos,
      name = manhattanr.res$data$Gene,
      text = paste0(
        "Gene: ", manhattanr.res$data$Gene,
        "\nDiff_Z_score: ", manhattanr.res$data$Diff_Z_score,
        "\nDiff_Perc: ", manhattanr.res$data$Diff_Perc,
        "\nAlterations: ", manhattanr.res$data$Alterations,
        "\nchr: ", manhattanr.res$data$CHR
      ),
      marker = list(
        color = "red",
        size = 10,
        opacity = 0.5,
        line = list(
          color = "black",
          width = 1
        )
      ),
      type = "scatter",
      mode = "markers",
      inherit = FALSE
    )

  ##### Create directory for the plots
  PlotDir <- file.path(results_dir, "cn_genomic_view")
  fs::dir_create(PlotDir)

  ##### Save interactive plot as html file
  RNAsum::saveWidgetFix(widget = p, file = file.path(PlotDir, "cn_genomic_view.html"))

  #### Clear plots to free up some memory
  if (!is.null(dev.list())) invisible(dev.off())
} else {
  cat("None of the genes of interest are affected by changes in CN.")
  p <- NULL
}

p
```

------------------------------------------------------------------------

<details>

<summary>CN data distribution</summary>

`r if ( runPurpleChunk ) { c(" ") } else { c("CN information for this sample is NOT AVAILABLE.") }`

```{r cn_data_distribution_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 12, fig.height = 4, eval = runPurpleChunk }
##### Generate a histogram illustrating CN data distribution
cn_dist_plot

##### Create directory for the plots
PlotDir <- file.path(results_dir, "cn_dist_plot")
fs::dir_create(PlotDir)
##### Save interactive plot as html file
RNAsum::saveWidgetFix(widget = cn_dist_plot, file = file.path(PlotDir, "cn_dist_plot.html"))

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())
```

</details>

------------------------------------------------------------------------

### - Expression vs CN {.tabset}

Scatterplot comparing the per-gene difference in **mRNA expression** of [Cancer genes] between patient's sample and cancer individuals (*y-axis*), and **CN values** (*x-axis*, from [PURPLE](https://github.com/hartwigmedical/hmftools/tree/master/purple)).

#### Percentiles

```{r cn_expr_data_plot_perc, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 4, eval = runPurpleChunk}
##### Generate scatterplot with per-gene expression values (y-axis), CN values (x-axis) and mutation status info (colours)
cn_genes <- data.sub$Gene

if (runPcgrChunk && length(cn_genes) > 0) {
  RNAsum::mutCNexprPlot(
    data = data.sub, alt_data = TRUE, cn_bottom = cn_bottom, cn_top = cn_top,
    comp_cancer = comp_cancer_group, type = "perc", report_dir = results_dir
  )
} else if (length(cn_genes) > 0) {
  data.sub <- data.sub[data.sub$Gene %in% cn_genes, ]
  RNAsum::mutCNexprPlot(
    data = data.sub, alt_data = FALSE, cn_bottom = cn_bottom, cn_top = cn_top,
    comp_cancer = comp_cancer_group, type = "perc", report_dir = results_dir
  )
} else {
  cn_genes <- NULL
  cat("None of the genes of interest are affected by changes in CN.")
}
if (!is.null(dev.list())) invisible(dev.off())
```

------------------------------------------------------------------------

#### Z-scores

```{r cn_expr_data_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 4, eval = runPurpleChunk}
##### Generate scatterplot with per-gene expression values (y-axis), CN values (x-axis) and mutation status info (colours)
if (runPcgrChunk && length(cn_genes) > 0) {
  data.sub <- data.sub[data.sub$Gene %in% cn_genes, ]
  RNAsum::mutCNexprPlot(
    data = data.sub, alt_data = TRUE, cn_bottom = cn_bottom, cn_top = cn_top,
    comp_cancer = comp_cancer_group, type = "z", report_dir = results_dir
  )
} else if (length(cn_genes) > 0) {
  data.sub <- data.sub[data.sub$Gene %in% cn_genes, ]
  RNAsum::mutCNexprPlot(
    data = data.sub, alt_data = FALSE, cn_bottom = cn_bottom, cn_top = cn_top,
    comp_cancer = comp_cancer_group, type = "z", report_dir = results_dir
  )
} else {
  cn_genes <- NULL
  cat("None of the genes of interest are affected by changes in CN.")
}
#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())
```

------------------------------------------------------------------------

### - Summary table {.tabset}

Out of the `r if (runPurpleChunk) { ref_dataset.list[[dataset]][["expr_mut_cn_data_all"]] |> dplyr::filter(CN <= cn_bottom | CN >= cn_top) |> nrow() } else { cat("0") }` genes within
gained `r if ( runPurpleChunk ) { paste0("(CN values >= ", cn_top, ")") }` or
lost `r if ( runPurpleChunk ) { paste0("(CN values =< ", cn_bottom, ")") }`
regions `r if (runPurpleChunk) { nrow(ref_dataset.list[[dataset]][["expr_mut_cn_data"]]) } else { length(NULL) }` are [Cancer genes].
The expression of **`r if (runPurpleChunk) { ref_dataset.list[[dataset]][["expr_mut_cn_data"]] |> dplyr::filter(Gene %in% rownames(ref_dataset.list[[dataset]][["data_to_report"]])) |> nrow() } else { length(NULL) }`**
of these genes was reliably measured in the patient's sample. The remaining
`r if (runPurpleChunk) { length(which(!cn_genes %in% rownames(ref_dataset.list[[dataset]][["data_to_report"]]))) } else { length(NULL) }` genes are either not expressed or their expression level is too low to be detected (indicated in [BLANK]{style="color:#808080"} cells with missing values).

#### Gains {.tabset}

Table summarising the **mRNA expression** values in cancer and patient samples for genes with **CN** values \>= `r if ( runPurpleChunk ) { cn_top } else { c("(NA)") }` (**gains**), based on patient's genomic data (from [PURPLE](https://github.com/hartwigmedical/hmftools/tree/master/purple)), and mutation status if available (from [PCGR](https://github.com/sigven/pcgr)).

##### Percentiles

```{r cn_expr_data_table_gains_perc, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Generate expression summary table for per-gene expression values CN values and mutation status info (colours)
##### Keep only genes within CN gains
cn_data <- ref_dataset.list[[dataset]][["expr_mut_cn_data"]] |>
  dplyr::filter(.data$CN >= cn_top) |>
  dplyr::select("Gene", "CN")
genes_gains <- as.character(cn_genes[cn_genes %in% cn_data[["Gene"]]])

##### Deal with no genes
if (length(genes_gains) == 0) {
  genes_gains <- NULL
  genes_gains_no <- 0
} else if (length(genes_gains) > params$top_genes) {
  genes_gains_no <- params$top_genes
} else {
  genes_gains_no <- length(genes_gains)
}

##### Get expression data
dat1 <- ref_dataset.list[[dataset]][["data_to_report"]]

if (runPcgrChunk && runPurpleChunk) {
  cn_expr_genes.expr.gains.perc <- RNAsum::exprTable(
    type = "perc",
    data = dat1,
    genes = genes_gains,
    cn_data = cn_data,
    cn_decrease = TRUE,
    targets = targets,
    sampleName = sample_name,
    ext_cancer = ext_cancer_group,
    int_cancer = int_cancer_group,
    comp_cancer = comp_cancer_group,
    add_cancer = add_cancer_group,
    genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
    mut_annot = sample_data.list[["wgs"]][["pcgr_tiers_tsv"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")],
    oncokb_annot = ref_genes.list[["genes_oncokb"]],
    cancer_genes = ref_genes.list[["genes_cancer"]][, c("Gene", "Oncogene", "TSG", "Fusion", "Germline")],
    scaling = scaling,
    civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
  )

  ##### Generate expression summary table for per-gene expression values and CN values
} else if (runPurpleChunk) {
  cn_expr_genes.expr.gains.perc <- RNAsum::exprTable(
    type = "perc",
    data = dat1,
    genes = genes_gains,
    cn_data = cn_data,
    cn_decrease = TRUE,
    targets = targets,
    sampleName = sample_name,
    ext_cancer = ext_cancer_group,
    int_cancer = int_cancer_group,
    comp_cancer = comp_cancer_group,
    add_cancer = add_cancer_group,
    genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
    oncokb_annot = ref_genes.list[["genes_oncokb"]],
    cancer_genes = ref_genes.list[["genes_cancer"]][, c("Gene", "Oncogene", "TSG", "Fusion", "Germline")],
    scaling = scaling,
    civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
  )
}

##### Present the expression, CN and mutation data summary table
cn_expr_genes.expr.gains.perc[[1]]

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = cn_expr_genes.expr.gains.perc[[1]],
    file = file.path(exprTableDir, "cn_expr_genes.expr.gains.perc.html")
  )
}
```

<details>

<summary>Table legend</summary>

<font size="2">

The [RED]{style="color:#ff0000"} colour range indicate relatively **high expression** (percentile) values and [BLUE]{style="color:#0000ff"} colour range indicate relatively **low expression** (percentile) values in individual sample group. The [BLANK]{style="color:#808080"} cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each gene. The **CN values** based on patient's genomic data are presented in *Patient (CN)* column with a horizontal blue bar indicating the CN value of each gene in the context of other genes. If mutation data is availbale, then the variants' tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided on right-hand side based on information from [PCGR](https://github.com/sigven/pcgr) report (similar to [Mutated genes] section). Genes are ordered by **Patient (CN)** and then by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) columns. *CN* - copy-number

</font>

</details>

`r if ( runPurpleChunk && length(genes_gains) > 2000 ) { c(paste0("<span style=\"color:#ff0000\">NOTE</span>, the table was truncated to 2000 entries.")) } else { cat("") }`

------------------------------------------------------------------------

##### Z-scores

```{r cn_expr_data_table_gains, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
##### Generate expression summary table for per-gene expression values CN values and mutation status info (colours)
if (runPcgrChunk && runPurpleChunk) {
  cn_expr_genes.expr.gains.z <- RNAsum::exprTable(
    type = "z",
    genes = genes_gains,
    data = dat1,
    cn_data = cn_data,
    cn_decrease = TRUE,
    targets = targets,
    sampleName = sample_name,
    ext_cancer = ext_cancer_group,
    int_cancer = int_cancer_group,
    comp_cancer = comp_cancer_group,
    add_cancer = add_cancer_group,
    genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
    mut_annot = sample_data.list[["wgs"]][["pcgr_tiers_tsv"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")],
    oncokb_annot = ref_genes.list[["genes_oncokb"]],
    cancer_genes = ref_genes.list[["genes_cancer"]][, c("Gene", "Oncogene", "TSG", "Fusion", "Germline")],
    scaling = scaling,
    civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
  )

  ##### Generate expression summary table for per-gene expression values and CN values
} else if (runPurpleChunk) {
  cn_expr_genes.expr.gains.z <- RNAsum::exprTable(
    type = "z",
    data = dat1,
    genes = genes_gains,
    cn_data = cn_data,
    cn_decrease = TRUE,
    targets = targets,
    sampleName = sample_name,
    ext_cancer = ext_cancer_group,
    int_cancer = int_cancer_group,
    comp_cancer = comp_cancer_group,
    add_cancer = add_cancer_group,
    genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
    cancer_genes = ref_genes.list[["genes_cancer"]][, c("Gene", "Oncogene", "TSG", "Fusion", "Germline")],
    scaling = scaling,
    civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
  )
}

##### Present the expression, CN and mutation data summary table
cn_expr_genes.expr.gains.z[[1]]

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = cn_expr_genes.expr.gains.z[[1]],
    file = file.path(exprTableDir, "cn_expr_genes.expr.gains.z.html")
  )
}

##### Clean the space
rm(cn_expr_genes.expr.gains.z, cn_data)
```

<details>

<summary>Table legend</summary>

<font size="2">

The [RED]{style="color:#ff0000"} colour range indicate relatively **high expression** (Z-score) values and [BLUE]{style="color:#0000ff"} colour range indicate relatively **low expression** (Z-score) values in individual sample group. The [BLANK]{style="color:#808080"} cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each gene. The **CN values** based on patient's genomic data are presented in *Patient (CN)* column with a horizontal blue bar indicating the CN value of each gene in the context of other genes. If mutation data is availbale, then the variants' tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided on right-hand side based on information from [PCGR](https://github.com/sigven/pcgr) report (similar to [Mutated genes] section). Genes are ordered by **Patient (CN)** and then by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) columns. *CN* - copy-number

</font>

</details>

`r if ( runPurpleChunk && length(genes_gains) > 2000 ) { c(paste0("<span style=\"color:#ff0000\">NOTE</span>, the table was truncated to 2000 entries.")) } else { cat("") }`

------------------------------------------------------------------------

#### Losses {.tabset}

Table summarising the **mRNA expression** values in cancer and patient samples for genes with **CN** values =\< `r if ( runPurpleChunk ) { cn_bottom } else { c("(NA)") }` (**losses**), based on patient's genomic data (from [PURPLE](https://github.com/hartwigmedical/hmftools/tree/master/purple)), and mutation status if available (from [PCGR](https://github.com/sigven/pcgr)).

##### Percentiles

```{r cn_expr_data_table_losses_perc, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Generate expression summary table for per-gene expression values CN values and mutation status info (colours)
##### Keep only genes within CN losses
cn_data <- ref_dataset.list[[dataset]][["expr_mut_cn_data"]] |>
  dplyr::filter(.data$CN <= cn_bottom) |>
  dplyr::select("Gene", "CN")
genes_losses <- as.character(cn_genes[cn_genes %in% cn_data[["Gene"]]])

##### Deal with no genes or when more than 10 genes are of interest
if (length(genes_losses) == 0) {
  genes_losses <- NULL
  genes_losses_no <- 0
} else if (length(genes_losses) > params$top_genes) {
  genes_losses_no <- params$top_genes
} else {
  genes_losses_no <- length(genes_losses)
}

if (genes_gains_no + genes_losses_no > params$top_genes) {
  limit_genes <- TRUE
} else {
  limit_genes <- FALSE
}

##### Get expression data
dat1 <- ref_dataset.list[[dataset]][["data_to_report"]]

if (runPcgrChunk && runPurpleChunk) {
  cn_expr_genes.expr.losses.perc <- RNAsum::exprTable(
    type = "perc",
    genes = genes_losses,
    data = dat1,
    cn_data = cn_data,
    cn_decrease = FALSE,
    targets = targets,
    sampleName = sample_name,
    ext_cancer = ext_cancer_group,
    int_cancer = int_cancer_group,
    comp_cancer = comp_cancer_group,
    add_cancer = add_cancer_group,
    genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
    mut_annot = sample_data.list[["wgs"]][["pcgr_tiers_tsv"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")],
    oncokb_annot = ref_genes.list[["genes_oncokb"]],
    cancer_genes = ref_genes.list[["genes_cancer"]][, c("Gene", "Oncogene", "TSG", "Fusion", "Germline")],
    scaling = scaling,
    civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
  )

  ##### Generate expression summary table for per-gene expression values and CN values
} else if (runPurpleChunk) {
  cn_expr_genes.expr.losses.perc <- RNAsum::exprTable(
    type = "perc",
    data = dat1,
    genes = genes_losses,
    cn_data = cn_data,
    cn_decrease = FALSE,
    targets = targets,
    sampleName = sample_name,
    ext_cancer = ext_cancer_group,
    int_cancer = int_cancer_group,
    comp_cancer = comp_cancer_group,
    add_cancer = add_cancer_group,
    genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
    oncokb_annot = ref_genes.list[["genes_oncokb"]],
    cancer_genes = ref_genes.list[["genes_cancer"]][, c("Gene", "Oncogene", "TSG", "Fusion", "Germline")],
    scaling = scaling,
    civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
  )
}

##### Present the expression, CN and mutation data summary table
cn_expr_genes.expr.losses.perc[[1]]

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = cn_expr_genes.expr.losses.perc[[1]],
    file = file.path(exprTableDir, "cn_expr_genes.expr.losses.perc.html")
  )
}
```

<details>

<summary>Table legend</summary>

<font size="2">

The [RED]{style="color:#ff0000"} colour range indicate relatively **high expression** (percentile) values and [BLUE]{style="color:#0000ff"} colour range indicate relatively **low expression** (percentile) values in individual sample group. The [BLANK]{style="color:#808080"} cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each gene. The **CN values** based on patient's genomic data are presented in *Patient (CN)* column with a horizontal blue bar indicating the CN value of each gene in the context of other genes. If mutation data is availbale, then the variants' tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided on right-hand side based on information from [PCGR](https://github.com/sigven/pcgr) report (similar to [Mutated genes] section). Genes are ordered by **Patient (CN)** and then by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) columns. *CN* - copy-number

</font>

</details>

`r if ( runPurpleChunk && length(genes_losses) > 2000 ) { c(paste0("<span style=\"color:#ff0000\">NOTE</span>, the table was truncated to 2000 entries.")) } else { cat("") }`

------------------------------------------------------------------------

##### Z-scores

```{r cn_expr_data_table_losses, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Generate expression summary table for per-gene expression values CN values and mutation status info (colours)
if (runPcgrChunk && runPurpleChunk) {
  cn_expr_genes.expr.losses.z <- RNAsum::exprTable(
    type = "z",
    data = dat1,
    genes = genes_losses,
    cn_data = cn_data,
    cn_decrease = FALSE,
    targets = targets,
    sampleName = sample_name,
    ext_cancer = ext_cancer_group,
    int_cancer = int_cancer_group,
    comp_cancer = comp_cancer_group,
    add_cancer = add_cancer_group,
    genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
    mut_annot = sample_data.list[["wgs"]][["pcgr_tiers_tsv"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")],
    oncokb_annot = ref_genes.list[["genes_oncokb"]],
    cancer_genes = ref_genes.list[["genes_cancer"]][, c("Gene", "Oncogene", "TSG", "Fusion", "Germline")],
    scaling = scaling,
    civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
  )

  ##### Generate expression summary table for per-gene expression values and CN values
} else if (runPurpleChunk) {
  cn_expr_genes.expr.losses.z <- RNAsum::exprTable(
    type = "z",
    data = dat1,
    genes = genes_losses,
    cn_data = cn_data,
    cn_decrease = FALSE,
    targets = targets,
    sampleName = sample_name,
    ext_cancer = ext_cancer_group,
    int_cancer = int_cancer_group,
    comp_cancer = comp_cancer_group,
    add_cancer = add_cancer_group,
    genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
    oncokb_annot = ref_genes.list[["genes_oncokb"]],
    cancer_genes = ref_genes.list[["genes_cancer"]][, c("Gene", "Oncogene", "TSG", "Fusion", "Germline")],
    scaling = scaling,
    civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
  )
}

##### Present the expression, CN and mutation data summary table
cn_expr_genes.expr.losses.z[[1]]

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = cn_expr_genes.expr.losses.z[[1]],
    file = file.path(exprTableDir, "cn_expr_genes.expr.losses.z.html")
  )
}

##### Clean the space and return output
rm(cn_data, cn_expr_genes.expr.losses.z)
```

<details>

<summary>Table legend</summary>

<font size="2">

The [RED]{style="color:#ff0000"} colour range indicate relatively **high expression** (Z-score) values and [BLUE]{style="color:#0000ff"} colour range indicate relatively **low expression** (Z-score) values in individual sample group. The [BLANK]{style="color:#808080"} cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each gene. The **CN values** based on patient's genomic data are presented in *Patient (CN)* column with a horizontal blue bar indicating the CN value of each gene in the context of other genes. If mutation data is availbale, then the variants' tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided on right-hand side based on information from [PCGR](https://github.com/sigven/pcgr) report (similar to [Mutated genes] section). Genes are ordered by **Patient (CN)** and then by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) columns. *CN* - copy-number

</font>

</details>

`r if ( runPurpleChunk && length(genes_losses) > 2000 ) { c(paste0("<span style=\"color:#ff0000\">NOTE</span>, the table was truncated to 2000 entries.")) } else { cat("") }`

------------------------------------------------------------------------

### - Expression profiles {.tabset}

`r if ( exists("limit_genes") && exists("genes_gains_no") ) { if ( limit_genes ) { c(paste0("Expression profiles for ", genes_gains_no, " genes with the highest (**gains**) and ", genes_losses_no, " genes with the lowest (**losses**) CN values and the greatest difference in mRNA expression (percentile) values between patient's sample and the average mRNA expression in samples from cancer patients.")) } else { cat(" ") }}`

#### Gains {.tabset}

```{r cdf_plot_cn_expr_gains, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk, results="asis"}
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level for the genes of interest in the context of the overall mRNA expression distribution
output_cdf <- list()
output_counts <- list()
output_density <- list()
genes <- cn_expr_genes.expr.gains.perc[[2]][["SYMBOL"]]

##### For each gene generate (1) CDF plot and add boxplot below to show the data variance for selected gene in individual groups, (2) bar-plot of read count data across all samples and (3) density plot to demonstrate expression distribution in investigated sample
for (i in 1:genes_gains_no) {
  if (genes_gains_no > 0 && genes[i] %in% rownames(dat1)) {
    ##### CDF plot
    output_cdf[[i]] <- RNAsum::cdfPlot(
      gene = genes[i], data = dat1, targets = targets, sampleName = sample_name,
      ext_cancer = ext_cancer_group, int_cancer = int_cancer_group,
      comp_cancer = comp_cancer_group, add_cancer = add_cancer_group,
      addBoxPlot = TRUE, scaling = scaling, report_dir = results_dir
    )

    ##### Bar-plot of read counts
    ##### First map the gene symbol to Ensmebl ID (used in the counts data)
    genes.ENSEMBL <- ref_dataset.list[[dataset]][["gene_annot_all"]] |>
      dplyr::filter(.data$SYMBOL == genes[i]) |>
      dplyr::pull(.data$ENSEMBL)
    output_counts[[i]] <- RNAsum::barPlot(
      gene = genes.ENSEMBL, data = ref_dataset.list[[dataset]][["combined_data"]],
      y_title = "Counts", targets = targets, sampleName = sample_name,
      ext_cancer = ext_cancer_group, int_cancer = int_cancer_group,
      add_cancer = add_cancer_group
    )
    ##### Density plot - expression distribution
    output_density[[i]] <- RNAsum::densityPlot(
      gene = genes[i], data = dat1, main_title = "", x_title = "Z-score",
      sampleName = sample_name, distributions = c("normal", "bimodal"),
      scaling = scaling
    )
  }
}

##### Now once the plots are ready show them in separate tabs
if (genes_gains_no != 0) {
  for (i in 1:genes_gains_no) {
    if (genes[i] %in% rownames(dat1)) {
      cat("\n##### ", genes[i], "\n")
      cat(renderTags(output_cdf[[i]])$html)
      cat("\n<details>\n")
      cat("\n<summary>Plot legend</summary>\n")
      cat("<font size=\"2\">\n")
      cat(paste0("**Top panel**: distribution of percentile values (*y-axis*) as a function of expression levels (Z-scores, *x-axis*) for *", genes[i], "* in patient's sample (*black dot*) and other reference cancer cohort(s) (median value(s)).\n\n"))
      cat(paste0("**Bottom panel**: box-plot presenting expression level (Z-score) of *", genes[i], "* in patient's sample (*black dot*) and its expression levels observed across samples from other reference cancer cohort(s).\n"))
      cat("\n</font>\n")
      cat("\n</details>\n")
      cat("\n<details>\n")
      cat("\n<summary>Read counts</summary>\n")
      cat(renderTags(output_counts[[i]])$html)
      cat("<font size=\"2\">\n")
      cat(paste0("Bar-plot illustrating read counts for *", genes[i], "* across all samples. The *", genes[i], "* read count in patient's sample is indicated by *black bar*.\n"))
      cat("\n</font>\n")
      cat("\n</details>\n")
      cat("\n<details>\n")
      cat("\n<summary>Expression distribution patterns</summary>\n")
      cat(renderTags(output_density[[i]])$html)
      cat("<font size=\"2\">\n")
      cat(paste0("Plot illustrating distribution of expression levels (Z-scores) of *", genes[i], "* *observed* across all samples along with simulated *normal* and *bimodal* distributions. The *", genes[i], "* expression level observed in patient's sample is indicated by *black dot* in each distribution.\n"))
      cat("\n</font>\n")
      cat("\n</details>\n")
      cat("\n***\n")
    } else {
      cat("\n#### ", genes[i], "\n")
      cat("\n<span style=\"color:#ff0000\">NOTE</span>, expression data is not available for that gene.\n")
      cat("\n***\n")
    }
    #### Clear plots to free up some memory
    if (!is.null(dev.list())) invisible(dev.off())
  }
} else {
  cat("\nNo alterations were reported.\n")
  cat("\n***\n")
}

##### Clean the space
rm(list = ls(pattern = "^output*"))
```

------------------------------------------------------------------------

#### Losses {.tabset}

```{r cdf_plot_cn_expr_losses, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk, results="asis"}
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level for the genes of interest in the context of the overall mRNA expression distribution
output_cdf <- list()
output_counts <- list()
output_density <- list()
genes <- cn_expr_genes.expr.losses.perc[[2]][["SYMBOL"]]

##### For each gene generate (1) CDF plot and add boxplot below to show the data variance for selected gene in individual groups, (2) bar-plot of read count data across all samples and (3) density plot to demonstrate expression distribution in investigated sample
for (i in 1:genes_losses_no) {
  if (genes_losses_no > 0 && genes[i] %in% rownames(dat1)) {
    ##### CDF plot
    output_cdf[[i]] <- RNAsum::cdfPlot(
      gene = genes[i], data = dat1, targets = targets, sampleName = sample_name,
      ext_cancer = ext_cancer_group, int_cancer = int_cancer_group,
      comp_cancer = comp_cancer_group, add_cancer = add_cancer_group,
      addBoxPlot = TRUE, scaling = scaling, report_dir = results_dir
    )

    ##### Bar-plot of read counts
    ##### First map the gene symbol to Ensmebl ID (used in the counts data)
    genes.ENSEMBL <- ref_dataset.list[[dataset]][["gene_annot_all"]] |>
      dplyr::filter(.data$SYMBOL == genes[i]) |>
      dplyr::pull(.data$ENSEMBL)

    output_counts[[i]] <- RNAsum::barPlot(
      gene = genes.ENSEMBL, data = ref_dataset.list[[dataset]][["combined_data"]],
      y_title = "Counts", targets = targets, sampleName = sample_name,
      ext_cancer = ext_cancer_group, int_cancer = int_cancer_group,
      add_cancer = add_cancer_group
    )

    ##### Density plot - expression distribution
    output_density[[i]] <- RNAsum::densityPlot(
      gene = genes[i], data = dat1, main_title = "", x_title = "Z-score",
      sampleName = sample_name, distributions = c("normal", "bimodal"),
      scaling = scaling
    )
  }
}

##### Now once the plots are ready show them in separate tabs
if (genes_losses_no != 0) {
  for (i in 1:genes_losses_no) {
    if (genes[i] %in% rownames(dat1)) {
      cat("\n##### ", genes[i], "\n")
      cat(renderTags(output_cdf[[i]])$html)
      cat("\n<details>\n")
      cat("\n<summary>Plot legend</summary>\n")
      cat("<font size=\"2\">\n")
      cat(paste0("**Top panel**: distribution of percentile values (*y-axis*) as a function of expression levels (Z-scores, *x-axis*) for *", genes[i], "* in patient's sample (*black dot*) and other reference cancer cohort(s) (median value(s)).\n\n"))
      cat(paste0("**Bottom panel**: box-plot presenting expression level (Z-score) of *", genes[i], "* in patient's sample (*black dot*) and its expression levels observed across samples from other reference cancer cohort(s).\n"))
      cat("\n</font>\n")
      cat("\n</details>\n")
      cat("\n<details>\n")
      cat("\n<summary>Read counts</summary>\n")
      cat(renderTags(output_counts[[i]])$html)
      cat("<font size=\"2\">\n")
      cat(paste0("Bar-plot illustrating read counts for *", genes[i], "* across all samples. The *", genes[i], "* read count in patient's sample is indicated by *black bar*.\n"))
      cat("\n</font>\n")
      cat("\n</details>\n")
      cat("\n<details>\n")
      cat("\n<summary>Expression distribution patterns</summary>\n")
      cat(renderTags(output_density[[i]])$html)
      cat("<font size=\"2\">\n")
      cat(paste0("Plot illustrating distribution of expression levels (Z-scores) of *", genes[i], "* *observed* across all samples along with simulated *normal* and *bimodal* distributions. The *", genes[i], "* expression level observed in patient's sample is indicated by *black dot* in each distribution.\n"))
      cat("\n</font>\n")
      cat("\n</details>\n")
      cat("\n***\n")
    } else {
      cat("\n#### ", genes[i], "\n")
      cat("\n<span style=\"color:#ff0000\">NOTE</span>, expression data is not available for that gene.\n")
      cat("\n***\n")
    }
  }
  #### Clear plots to free up some memory
  if (!is.null(dev.list())) invisible(dev.off())
} else {
  cat("\nNo alterations were reported.\n")
  cat("\n***\n")
}

##### Clean the space
rm(list = ls(pattern = "^output*"))
rm(limit_genes)
```

`r if ( !runPurpleChunk ) { c("***") } else { c(" ") }`

## Immune markers

Section presenting expression levels of immune markers to assess pre-existing anti-cancer immunity and likelihood of response to immunotherapy. Their mRNA expression levels are presented in patient's sample along their average mRNA expression in samples from cancer cohorts.

Out of the `r length(unique(unlist(ref_genes.list[["genes_immune"]]$immune_markers$SYMBOL)))` immune markers the expression of **`r length(which(ref_genes.list[["genes_immune"]]$immune_markers$SYMBOL %in% rownames(ref_dataset.list[[dataset]][["data_to_report"]])))`** was reliably measured in patient's sample.
The remaining `r length(which(!ref_genes.list[["genes_immune"]]$immune_markers$SYMBOL %in% rownames(ref_dataset.list[[dataset]][["data_to_report"]])))` genes are either not expressed or their expression level is too low to be detected (indicated in [BLANK]{style="color:#808080"} cells with missing values).

### - Summary table {.tabset}

#### Percentiles

```{r immune_genes_table_perc, comment = NA, message=FALSE, warning=FALSE}
##### Update MySQL commend to populate RNA-seq data portal
mysql_populate <- paste0(mysql_populate, ",Immune markers")
mysql_populate_update <- paste0(mysql_populate_update, ",Immune markers")

##### Generate expression summary table for cancer genes from OncoKB and UMCCR (https://github.com/vladsaveliev/NGS_Utils/blob/master/ngs_utils/reference_data/key_genes/umccr_cancer_genes.2019-03-20.tsv)
targets <- ref_dataset.list[[dataset]][["sample_annot"]]
dat1 <- ref_dataset.list[[dataset]][["data_to_report"]]
genes <- unique(unlist(ref_genes.list[["genes_immune"]]$immune_markers$SYMBOL))

##### Deal with no genes or when more than 10 genes are of interest
if (length(genes) == 0) {
  genes <- NULL
}

immune_genes.expr.perc <- RNAsum::exprTable(
  type = "perc",
  data = dat1,
  genes = genes,
  targets = targets,
  sampleName = sample_name,
  ext_cancer = ext_cancer_group,
  int_cancer = int_cancer_group,
  comp_cancer = comp_cancer_group,
  add_cancer = add_cancer_group,
  genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL", "Immune_Cycle_Role")],
  oncokb_annot = ref_genes.list[["genes_oncokb"]],
  scaling = scaling,
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
)[[1]]

##### Present the expression summary table
immune_genes.expr.perc

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = immune_genes.expr.perc,
    file = file.path(exprTableDir, "immune_genes.expr.perc.html")
  )
}

##### Clean the space
rm(immune_genes.expr.perc)
```

<details>

<summary>Table legend</summary>

<font size="2">

The [RED]{style="color:#ff0000"} colour range indicate relatively **high expression** (percentile) values and [BLUE]{style="color:#0000ff"} colour range indicate relatively **low expression** (percentile) values in individual sample group. The [BLANK]{style="color:#808080"} cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each immune marker. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column.

</font>

</details>

------------------------------------------------------------------------

#### Z-scores

```{r immune_genes_table, comment = NA, message=FALSE, warning=FALSE}
##### Generate expression summary table for cancer genes from OncoKB and UMCCR (https://github.com/vladsaveliev/NGS_Utils/blob/master/ngs_utils/reference_data/key_genes/umccr_cancer_genes.2019-03-20.tsv)
immune_genes.expr.z <- RNAsum::exprTable(
  type = "z",
  data = dat1,
  genes = genes,
  targets = targets,
  sampleName = sample_name,
  ext_cancer = ext_cancer_group,
  int_cancer = int_cancer_group,
  comp_cancer = comp_cancer_group,
  add_cancer = add_cancer_group,
  genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL", "Immune_Cycle_Role")],
  oncokb_annot = ref_genes.list[["genes_oncokb"]],
  scaling = scaling,
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
)[[1]]

##### Present the expression summary table
immune_genes.expr.z

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = immune_genes.expr.z,
    file = file.path(exprTableDir, "immune_genes.expr.z.html")
  )
}

##### Clean the space
rm(immune_genes.expr.z)
```

<details>

<summary>Table legend</summary>

<font size="2">

The [RED]{style="color:#ff0000"} colour range indicate relatively **high expression** (Z-score) values and [BLUE]{style="color:#0000ff"} colour range indicate relatively **low expression** (Z-score) values in individual sample group. The [BLANK]{style="color:#808080"} cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each immune marker. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column.

</font>

</details>

------------------------------------------------------------------------

### - Expression overview {.tabset}

Overview of immune markers expression profiles in patient's sample and in samples from cancer patients.

#### Percentiles

```{r glance_expr_plot_immune_genes_perc, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
##### Generate overview boxplot
if (!is.null(genes)) {
  RNAsum::glanceExprPlot(
    genes = genes, data = dat1, targets = targets, sampleName = sample_name,
    ext_cancer = ext_cancer_group, int_cancer = int_cancer_group,
    comp_cancer = comp_cancer_group, add_cancer = add_cancer_group,
    hexcode = "immune_genes", type = "perc", sort = "alphabetically",
    scaling = scaling, report_dir = results_dir
  )
} else {
  cat("\nNo expression data is available for immune markers!\n")
}

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())
```

<details>

<summary>Plot legend</summary>

<font size="2">

The individual box(es) represent the `r if ( int_cancer_group == comp_cancer_group ) { paste0(int_cancer_group, " and") } else { cat("") }` `r ext_cancer_group` `r if ( !is.null(add_cancer_group) ) { paste0("and ", add_cancer_group) } else { cat("") }` reference cancer cohort(s), and the **BLACK** dots indicate expression (percentile) values for each gene in the patient sample. Genes are ordered **alphabetically**.

</font>

</details>

------------------------------------------------------------------------

#### Z-scores

```{r glance_expr_plot_immune_genes, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
##### Generate overview boxplot
if (!is.null(genes)) {
  RNAsum::glanceExprPlot(
    genes = genes, data = dat1, targets = targets, sampleName = sample_name,
    ext_cancer = ext_cancer_group, int_cancer = int_cancer_group,
    comp_cancer = comp_cancer_group, add_cancer = add_cancer_group,
    hexcode = "immune_genes", type = "z", sort = "alphabetically",
    scaling = scaling, report_dir = results_dir
  )
} else {
  cat("\nNo expression data is available for immune markers!\n")
}

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())
```

<details>

<summary>Plot legend</summary>

<font size="2">

The individual box(es) represent the `r if ( int_cancer_group == comp_cancer_group ) { paste0(int_cancer_group, " and") } else { cat("") }` `r ext_cancer_group` `r if ( !is.null(add_cancer_group) ) { paste0("and ", add_cancer_group) } else { cat("") }` reference cancer cohort(s), and the **BLACK** dots indicate expression (Z-score) values for each gene in the patient sample. Genes are ordered **alphabetically**.

</font>

</details>

------------------------------------------------------------------------

`r if ( params$immunogram ) { c("### - Immunogram {.tabset}") }`

`r if ( params$immunogram ) { c("Visualisation of general and local cancer immunity status using **cancer immunogram** for the [cancer-immunity cycle](https://www.sciencedirect.com/topics/medicine-and-dentistry/tumor-immunity) (CIC), a concept of integrated immune biomarkers scoring system proposed by [Blank et al.](https://science.sciencemag.org/content/352/6286/658.summary)") }`

`r if ( params$immunogram ) { c("#### Plot") }`

```{r immunogram_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 6, fig.height = 6, eval = F}
##### Generate spider web plot to present the patient cancer immunity status. For more info about immunogram see the following papers
# https://www.sciencedirect.com/science/article/pii/S1556086417300084
# https://www.sciencedirect.com/science/article/pii/S1556086417302125
# https://www.europeanurology.com/article/S0302-2838(18)30685-7/fulltext?rss=yes
##### NOTE: currently, the mean expression (Z-score) values of genes from each of the 7 CIC steps are presented rather than the normalized enrichment scores (NES) from GSEA analysis performed for each geneset (CIC step)

##### Preset cancer immunity status for the patient using web-plot
# TODO (PD): what does this return...
RNAsum::webplot(
  as.data.frame(ref_genes.list[["genes_immune"]]$immunogram.df),
  data.row = ncol(dat1), main = "", add = FALSE, col = "black"
)

##### Now add data for samples with specific immunogram patterns, e.g. T-cellrich, T-cellpoor, T-cellintermediate...
# webplot(as.data.frame(ref_genes.list[["genes_immune"]]$immunogram.df), data.row = 5, main = "", add = TRUE, col = "powderblue", lty = 5)
# webplot(as.data.frame(ref_genes.list[["genes_immune"]]$immunogram.df), data.row = 156, main = "", add = TRUE, col = "forestgreen", lty = 5)
# webplot(as.data.frame(ref_genes.list[["genes_immune"]]$immunogram.df), data.row = 194, main = "", add = TRUE, col = "red", lty = 5)
# legend("topright", legend=c("Patient", "T-cellrich","T-cellpoor", "T-cellintermediate"), fill=c("black", "powderblue", "forestgreen", "red"), bty="n", bg = "transparent", cex = 0.8)

#### Clear plots to free up some memory
# if(!is.null(dev.list())) invisible(dev.off())
```

`r if ( params$immunogram ) { c("***") }`

`r if ( params$immunogram ) { c("#### Table {.tabset}") }`

```{r immunogram_table_legend, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, eval = F, results="asis"}
cat("\n<details>\n")
cat("\n<summary>Table legend</summary>\n")
cat("\n<font size=\"2\">\n")
cat("\nThe <span style=\"color:#ff0000\">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style=\"color:#0000ff\">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The <span style=\"color:#808080\">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each immunogram gene. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column.\n")
cat("\n</font>\n")
cat("\n</details>\n")
cat("\n***\n")
```

`r if ( params$immunogram ) { c("##### Percentiles") }`

```{r immunogram_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = FALSE}
# eval = params$immunogram (THIS IS OVERRIDEN HERE for dev DUE TO https://github.com/rstudio/rstudio/issues/6675)
targets <- ref_dataset.list[[dataset]][["sample_annot"]]
dat1 <- ref_dataset.list[[dataset]][["data_to_report"]]
genes <- unique(unlist(ref_genes.list[["genes_immune"]]$genes_immunogram$SYMBOL))

##### Deal with no genes or when more than 10 genes are of interest
if (length(genes) == 0) {
  genes <- NULL
}

##### Generate expression summary table for cancer genes from OncoKB and UMCCr (https://github.com/vladsaveliev/NGS_Utils/blob/master/ngs_utils/reference_data/key_genes/umccr_cancer_genes.2019-03-20.tsv)
immunogram.expr.perc <- RNAsum::exprTable(
  type = "perc",
  data = dat1,
  genes = genes,
  targets = targets,
  sampleName = sample_name,
  ext_cancer = ext_cancer_group,
  int_cancer = int_cancer_group,
  comp_cancer = comp_cancer_group,
  add_cancer = add_cancer_group,
  genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL", "CIC")],
  oncokb_annot = ref_genes.list[["genes_oncokb"]],
  scaling = scaling,
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
)[[1]]

##### Present the expression summary table
immunogram.expr.perc

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = immunogram.expr.perc,
    file = file.path(exprTableDir, "immunogram.expr.perc.html")
  )
}

##### Clean the space
rm(immunogram.expr.perc)
```

```{r immunogram_table_legend_perc, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, eval = FALSE, results="asis"}
# eval = params$immunogram (THIS IS OVERRIDEN HERE for dev DUE TO https://github.com/rstudio/rstudio/issues/6675)
cat("\n<details>\n")
cat("\n<summary>Table legend</summary>\n")
cat("\n<font size=\"2\">\n")
cat("\nThe <span style=\"color:#ff0000\">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style=\"color:#0000ff\">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The <span style=\"color:#808080\">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each immunogram gene. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column.\n")
cat("\n</font>\n")
cat("\n</details>\n")
cat("\n***\n")
```

`r if ( params$immunogram ) { c("##### Z-scores") }`

```{r immunogram_table, comment = NA, message=FALSE, warning=FALSE, eval = FALSE}
# eval = params$immunogram (THIS IS OVERRIDEN HERE for dev DUE TO https://github.com/rstudio/rstudio/issues/6675)
##### Generate expression summary table for cancer genes from OncoKB and UMCCR (https://github.com/vladsaveliev/NGS_Utils/blob/master/ngs_utils/reference_data/key_genes/umccr_cancer_genes.2019-03-20.tsv)
immunogram.expr.z <- RNAsum::exprTable(
  genes = genes,
  data = dat1,
  targets = targets,
  sampleName = sample_name,
  ext_cancer = ext_cancer_group,
  int_cancer = int_cancer_group,
  comp_cancer = comp_cancer_group,
  add_cancer = add_cancer_group,
  genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL", "CIC")],
  oncokb_annot = ref_genes.list[["genes_oncokb"]],
  type = "z",
  scaling = scaling,
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
)[[1]]

##### Present the expression summary table
immunogram.expr.z

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = immunogram.expr.z,
    file = file.path(exprTableDir, "immunogram.expr.z.html")
  )
}
```

## HRD genes

Section presenting expression levels of homologous recombination deficiency (HRD) genes to assess how many of these demonstrate low expression, which may indicate potential promoter methylation events. Their mRNA expression levels are presented in patient's sample along their average mRNA expression in samples from cancer cohorts.

Out of the `r length(unique(ref_genes.list[["genes_hrd"]][["SYMBOL"]]))` HRD genes, the expression of
**`r sum(ref_genes.list[["summary"]]$HRD %in% rownames(ref_dataset.list[[dataset]][["data_to_report"]]))`**
was reliably measured in patient's sample.
The remaining
`r sum(!ref_genes.list[["summary"]]$HRD %in% rownames(ref_dataset.list[[dataset]][["data_to_report"]]))`
genes are either not expressed or their expression level is too low to be detected (indicated in
[BLANK]{style="color:#808080"} cells with missing values).

### - Summary table {.tabset}

#### Percentiles

```{r hrd_genes_table_perc, comment = NA, message=FALSE, warning=FALSE}
##### Update MySQL commend to populate RNA-seq data portal
mysql_populate <- paste0(mysql_populate, ",HRD genes")
mysql_populate_update <- paste0(mysql_populate_update, ",HRD genes")

##### Generate expression summary table for hrd genes from Richqrd
targets <- ref_dataset.list[[dataset]][["sample_annot"]]
dat1 <- ref_dataset.list[[dataset]][["data_to_report"]]
genes <- unique(ref_genes.list[["genes_hrd"]][["SYMBOL"]])

##### Deal with no genes
if (length(genes) == 0) {
  genes <- NULL
}

hrd_genes.expr.perc <- RNAsum::exprTable(
  type = "perc",
  data = dat1,
  genes = genes,
  targets = targets,
  sampleName = sample_name,
  ext_cancer = ext_cancer_group,
  int_cancer = int_cancer_group,
  comp_cancer = comp_cancer_group,
  add_cancer = add_cancer_group,
  genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
  oncokb_annot = ref_genes.list[["genes_oncokb"]],
  scaling = scaling,
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
)

##### Present the expression summary table
hrd_genes.expr.perc[[1]]

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = hrd_genes.expr.perc[[1]],
    file = file.path(exprTableDir, "hrd_genes.expr.perc.html")
  )
}
```

<details>

<summary>Table legend</summary>

<font size="2">

The [RED]{style="color:#ff0000"} colour range indicates relatively **high expression** (percentile) values and [BLUE]{style="color:#0000ff"} colour range indicates relatively **low expression** (percentile) values in individual sample group. The [BLANK]{style="color:#808080"} cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each HRD gene. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. *TSG* - tumour suppressor gene

</font>

</details>

------------------------------------------------------------------------

#### Z-scores

```{r hrd_genes_table, comment = NA, message=FALSE, warning=FALSE}
##### Generate expression summary table for hrd genes from Richard
hrd_genes.expr.z <- RNAsum::exprTable(
  type = "z",
  data = dat1,
  genes = genes,
  targets = targets,
  sampleName = sample_name,
  ext_cancer = ext_cancer_group,
  int_cancer = int_cancer_group,
  comp_cancer = comp_cancer_group,
  add_cancer = add_cancer_group,
  genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
  oncokb_annot = ref_genes.list[["genes_oncokb"]],
  scaling = scaling,
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
)

##### Present the expression summary table
hrd_genes.expr.z[[1]]

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = hrd_genes.expr.z[[1]],
    file = file.path(exprTableDir, "hrd_genes.expr.z.html")
  )
}

##### Clean the space
rm(hrd_genes.expr.z)
```

<details>

<summary>Table legend</summary>

<font size="2">

The [RED]{style="color:#ff0000"} colour range indicate relatively **high expression** (Z-score) values and [BLUE]{style="color:#0000ff"} colour range indicate relatively **low expression** (Z-score) values in individual sample group. The [BLANK]{style="color:#808080"} cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each HRD gene. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column.

</font>

</details>

------------------------------------------------------------------------

### - Expression overview {.tabset}

Overview of HRD genes expression profiles in patient's sample and in samples from cancer patients.

#### Percentiles

```{r glance_expr_plot_hrd_genes_perc, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
##### Generate overview boxplot
if (!is.null(genes)) {
  RNAsum::glanceExprPlot(
    genes = genes, data = dat1, targets = targets, sampleName = sample_name,
    ext_cancer = ext_cancer_group, int_cancer = int_cancer_group,
    comp_cancer = comp_cancer_group, add_cancer = add_cancer_group,
    hexcode = "hrd_genes", type = "perc", sort = "alphabetically",
    scaling = scaling, report_dir = results_dir
  )
} else {
  cat("\nNo expression data is available for HRD genes!\n")
}

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())
```

<details>

<summary>Plot legend</summary>

<font size="2">

The individual box(es) represent the `r if ( int_cancer_group == comp_cancer_group ) { paste0(int_cancer_group, " and") } else { cat("") }` `r ext_cancer_group` `r if ( !is.null(add_cancer_group) ) { paste0("and ", add_cancer_group) } else { cat("") }` reference cancer cohort(s), and the **BLACK** dots indicate expression (percentile) values for each gene in the patient sample. Genes are ordered **alphabetically**.

</font>

</details>

------------------------------------------------------------------------

#### Z-scores

```{r glance_expr_plot_hrd_genes, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
##### Generate overview boxplot
if (!is.null(genes)) {
  RNAsum::glanceExprPlot(
    genes = genes, data = dat1, targets = targets, sampleName = sample_name,
    ext_cancer = ext_cancer_group, int_cancer = int_cancer_group,
    comp_cancer = comp_cancer_group, add_cancer = add_cancer_group,
    hexcode = "hrd_genes", type = "z", sort = "alphabetically",
    scaling = scaling, report_dir = results_dir
  )
} else {
  cat("\nNo expression data is available for HRD genes!\n")
}

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())
```

<details>

<summary>Plot legend</summary>

<font size="2">

The individual box(es) represent the `r if ( int_cancer_group == comp_cancer_group ) { paste0(int_cancer_group, " and") } else { cat("") }` `r ext_cancer_group` `r if ( !is.null(add_cancer_group) ) { paste0("and ", add_cancer_group) } else { cat("") }` reference cancer cohort(s), and the **BLACK** dots indicate expression (Z-score) values for each gene in the patient sample. Genes are ordered **alphabetically**.

</font>

</details>

------------------------------------------------------------------------

## Cancer genes

Shown below are mRNA expression levels of cancer genes in the patient's sample and their average mRNA expression in samples from cancer cohorts. These include genes reported in the following gene panels/resources [*UMCCR cancer genes*](https://github.com/umccr/NGS_Utils/blob/master/ngs_utils/reference_data/key_genes/umccr_cancer_genes.latest.tsv), [*OncoKB*](http://oncokb.org/#/cancerGenes), [*MSK-IMPACT*](https://www.mskcc.org/msk-impact), [*MSK-HEME*](http://www.islh.org/Presentation_Upload/presentation_uploads/12_52_0900-Zehir.pdf), [*Foundation One*](https://www.foundationmedicine.com/genomic-testing/foundation-one-cdx), [*Foundation One Heme*](https://www.foundationmedicine.com/genomic-testing/foundation-one-heme), [*Vogelstein*](http://science.sciencemag.org/content/339/6127/1546.full) and [*Sanger Cancer Gene Census*](https://www.sanger.ac.uk/science/data/cancer-gene-census) (CGC).

### - Summary table {.tabset}

Out of the `r nrow(ref_genes.list[["genes_cancer"]])` cancer genes, the expression of
**`r sum(ref_genes.list[["genes_cancer"]][["Gene"]] %in% rownames(ref_dataset.list[[dataset]][["data_to_report"]]))`**
was reliably measured in the patient's sample. The remaining
`r sum(!ref_genes.list[["genes_cancer"]][["Gene"]] %in% rownames(ref_dataset.list[[dataset]][["data_to_report"]]))` genes are either not expressed or their expression level is too low to be detected (indicated in [BLANK]{style="color:#808080"} cells with missing values).

#### Percentiles

```{r cancer_genes_table_perc, comment = NA, message=FALSE, warning=FALSE}
##### Update MySQL commend to populate RNA-seq data portal
mysql_populate <- paste0(mysql_populate, ",Cancer genes,All genes")
mysql_populate_update <- paste0(mysql_populate_update, ",Cancer genes,All genes")

##### Generate expression summary table for cancer genes from OncoKB and UMCCR (https://github.com/vladsaveliev/NGS_Utils/blob/master/ngs_utils/reference_data/key_genes/umccr_cancer_genes.2019-03-20.tsv)
targets <- ref_dataset.list[[dataset]][["sample_annot"]]
dat1 <- ref_dataset.list[[dataset]][["data_to_report"]]
genes <- ref_genes.list[["genes_cancer"]][["Gene"]]

##### Deal with no genes
if (length(genes) == 0) {
  genes <- NULL
}

cancer_genes.expr.perc <- RNAsum::exprTable(
  type = "perc",
  data = dat1,
  genes = genes,
  targets = targets,
  sampleName = sample_name,
  ext_cancer = ext_cancer_group,
  int_cancer = int_cancer_group,
  comp_cancer = comp_cancer_group,
  add_cancer = add_cancer_group,
  genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
  oncokb_annot = ref_genes.list[["genes_oncokb"]],
  cancer_genes = ref_genes.list[["genes_cancer"]],
  scaling = scaling,
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
)

##### Present the expression summary table
cancer_genes.expr.perc[[1]]

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = cancer_genes.expr.perc[[1]],
    file = file.path(exprTableDir, "cancer_genes.expr.perc.html")
  )
}
```

<details>

<summary>Table legend</summary>

<font size="2">

The [RED]{style="color:#ff0000"} colour range indicate relatively **high expression** (percentile) values and [BLUE]{style="color:#0000ff"} colour range indicate relatively **low expression** (percentile) values in individual sample group. The [BLANK]{style="color:#808080"} cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between percentiles in patient sample and reference cancer cohort for each cancer gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes) database, and inclusion in various sequencing panels are also indicated. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. *TSG* - tumour suppressor gene

</font>

</details>

------------------------------------------------------------------------

#### Z-scores

```{r cancer_genes_table, comment = NA, message=FALSE, warning=FALSE}
##### Generate expression summary table for cancer genes from OncoKB and UMCCR (https://github.com/vladsaveliev/NGS_Utils/blob/master/ngs_utils/reference_data/key_genes/umccr_cancer_genes.2019-03-20.tsv)
cancer_genes.expr.z <- RNAsum::exprTable(
  type = "z",
  data = dat1,
  genes = genes,
  targets = targets,
  sampleName = sample_name,
  ext_cancer = ext_cancer_group,
  int_cancer = int_cancer_group,
  comp_cancer = comp_cancer_group,
  add_cancer = add_cancer_group,
  genes_annot = ref_dataset.list[[dataset]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")],
  oncokb_annot = ref_genes.list[["genes_oncokb"]],
  cancer_genes = ref_genes.list[["genes_cancer"]],
  scaling = scaling,
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]]
)[[1]]

##### Present the expression summary table
cancer_genes.expr.z

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = cancer_genes.expr.z,
    file = file.path(exprTableDir, "cancer_genes.expr.z.html")
  )
}

##### Clean the space
rm(cancer_genes.expr.z)
```

<details>

<summary>Table legend</summary>

<font size="2">

The [RED]{style="color:#ff0000"} colour range indicate relatively **high expression** (Z-score) values and [BLUE]{style="color:#0000ff"} colour range indicate relatively **low expression** (Z-score) values in individual sample group. The [BLANK]{style="color:#808080"} cells with missing values indicate genes with **no/low expression**. The **Diff** (**Patient vs `r comp_cancer_group`**) column illustrates the difference between Z-scores in patient sample and reference cancer cohort for each cancer gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes) database, and inclusion in various sequencing panels are also indicated. Genes are ordered by **decreasing** absolute values in the **Diff** (**Patient vs `r comp_cancer_group`**) column. *TSG* - tumour suppressor gene

</font>

</details>

------------------------------------------------------------------------

### - Expression overview {.tabset}

Overview of expression profiles of 50 altered cancer genes with the greatest difference in mRNA expression (percentile) values between patient's sample and the average mRNA expression in samples from cancer patients.

#### Percentiles

```{r glance_expr_plot_cancer_genes_perc, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
##### Generate overview boxplot
genes <- cancer_genes.expr.perc[[2]]$SYMBOL[1:50]

if (!is.null(genes)) {
  RNAsum::glanceExprPlot(
    genes = genes, data = dat1, targets = targets, sampleName = sample_name,
    ext_cancer = ext_cancer_group, int_cancer = int_cancer_group,
    comp_cancer = comp_cancer_group, add_cancer = add_cancer_group,
    hexcode = "cancer_genes", type = "perc", sort = "none", scaling = scaling,
    report_dir = results_dir
  )
} else {
  cat("\nNo expression data is available for cancer genes!\n")
}

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())
```

<details>

<summary>Plot legend</summary>

<font size="2">

The individual box(es) represent the `r if ( int_cancer_group == comp_cancer_group ) { paste0(int_cancer_group, " and") } else { cat("") }` `r ext_cancer_group` `r if ( !is.null(add_cancer_group) ) { paste0("and ", add_cancer_group) } else { cat("") }` reference cancer cohort(s), and the **BLACK** dots indicate expression (percentile) values for each gene in the patient sample. Genes are ordered by **decreasing** absolute values in the **Patient vs `r comp_cancer_group`** comparison.

</font>

</details>

------------------------------------------------------------------------

#### Z-scores

```{r glance_expr_plot_cancer_genes, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
if (!is.null(genes)) {
  RNAsum::glanceExprPlot(
    genes = genes, data = dat1, targets = targets, sampleName = sample_name,
    ext_cancer = ext_cancer_group, int_cancer = int_cancer_group,
    comp_cancer = comp_cancer_group, add_cancer = add_cancer_group,
    hexcode = "cancer_genes", type = "z", sort = "none", scaling = scaling,
    report_dir = results_dir
  )
} else {
  cat("\nNo expression data is available for cancer genes!\n")
}

#### Clear plots to free up some memory
if (!is.null(dev.list())) invisible(dev.off())
```

<details>

<summary>Plot legend</summary>

<font size="2">

The individual box(es) represent the `r if ( int_cancer_group == comp_cancer_group ) { paste0(int_cancer_group, " and") } else { cat("") }` `r ext_cancer_group` `r if ( !is.null(add_cancer_group) ) { paste0("and ", add_cancer_group) } else { cat("") }` reference cancer cohort(s), and the **BLACK** dots indicate expression (Z-score) values for each gene in the patient sample. Genes are ordered by **decreasing** absolute values in the **Patient vs `r comp_cancer_group`** comparison.

</font>

</details>

------------------------------------------------------------------------

`r if ( params$drugs ) { c("## Drug matching {.tabset}") }`

`r if ( params$drugs ) { c("List of drugs targeting variants in detected [Mutated genes], [Fusion genes], [Structural variants]-affected genes, [CN altered genes], [HRD genes] and dysregulated [Cancer genes], which can be considered in the treatment decision making process. The clinically actionable aberrations are matched based on information provided by *[clinical interpretations of variants in Cancer](https://civicdb.org/home)* (CIViC) ([Griffith et al. (2017)](https://www.ncbi.nlm.nih.gov/pubmed/28138153)). The evidence pertaining to variants effect on therapeutic response is also provided.") }`

```{r drugs_table_dir, comment = NA, message=FALSE, warning=FALSE}
##### Create directory for tables
drugsTableDir <- file.path(results_dir, "drugsTables")
fs::dir_create(drugsTableDir)
```

`r if ( params$drugs ) { c("### - Mutated genes -") }`

`r if ( params$drugs && !runPcgrChunk ) { c("Mutation data for this sample are **NOT AVAILABLE**.") }`

`r if ( params$drugs && runPcgrChunk ) { paste0("**", length(mut_genes.expr.perc[[2]]$SYMBOL), "** genes with [PCGR](https://github.com/sigven/pcgr) tier 1-", params$pcgr_tier, " variants were screened for suitable drugs (see [Mutated genes] section).") } else if ( params$drugs && !runPcgrChunk ) { paste0("**0** genes with [PCGR](https://github.com/sigven/pcgr) tier 1-", params$pcgr_tier, " variants were screened for suitable drugs (see [Mutated genes] section).") }`

```{r drugs_predictive_mut_genes, comment = NA, message=FALSE, warning=FALSE, eval = runPcgrChunk}
##### Generate table with drugs targeting mutated cancer genes
genes <- mut_genes.expr.perc[[2]]$SYMBOL

drugsTable.mut_genes <- RNAsum::civicDrugTable(
  genes,
  civic_var_summaries = ref_genes.list[["civic_var_summaries"]],
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]],
  evid_type = "Predictive", var_type = "mutation"
)

if (params$drugs) {
  drugsTable.mut_genes[[1]]
}

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = drugsTable.mut_genes[[1]],
    file = file.path(drugsTableDir, "drugsTable.mut_genes.html")
  )
}
```

`r if ( params$drugs ) { c("<details>\n<summary>Table legend</summary>\n<font size=\"2\">") }`

```{r drugsTable_legend_mut_genes, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, results="asis", eval=params$drugs}
drugsTable_legend <- c("**[Evidence Level](https://civicdb.org/help/evidence/evidence-levels)**

* **A - Validated association**: Proven/consensus association in human medicine
* **B - Clinical evidence**: Clinical trial or other primary patient data supports association
* **C - Case study**: Individual case reports from clinical journals
* **D - Preclinical evidence**: *In vivo* or *in vitro* models support association
* **E - Inferential association**: Indirect evidence

**[Trust Rating](https://civicdb.org/help/evidence/trust-ratings)**

* **5**: Strong, well supported evidence from a lab or journal with respected academic standing. Experiments are well controlled, and results are clean and reproducible across multiple replicates. Evidence confirmed using independent methods. The study is statistically well powered
* **4**: Strong, well supported evidence. Experiments are well controlled, and results are convincing. Any discrepancies from expected results are well-explained and not concerning
* **3**: Evidence is convincing, but not supported by a breadth of experiments. May be smaller scale projects, or novel results without many follow-up experiments. Discrepancies from expected results are explained and not concerning
* **2**: Evidence is not well supported by experimental data, and little follow-up data is available. Publication is from a journal with low academic impact. Experiments may lack proper controls, have small sample size, or are not statistically convincing
* **1**: Claim is not supported well by experimental evidence. Results are not reproducible, or have very small sample size. No follow-up is done to validate novel claims

**[Actionability Score ](https://civicdb.org/help/variants/actionability-score)**

* [CIViC Actionability Score](https://civicdb.org/help/variants/actionability-score) allows to assess the accumulation of evidence for each variant. It is calculated by adding all Evidence Item Scores for each variant. The Evidence Item Score is calculated by multiplying the evidence level (A=10 points, B=5 points, C=3 points, D=1 point, E=0.25 points) by the trust rating (each Star = 1 point).")

cat(drugsTable_legend)
```

`r if ( params$drugs ) { c("</font>\n</details>") }`

`r if ( params$drugs ) { c("***") }`

`r if ( params$drugs ) { c("### - Fusion genes -") }`

`r if ( params$drugs && !runFusionChunk ) { c("Fusion genes information for this sample is **NOT AVAILABLE**.") }`

`r if ( params$drugs && runFusionChunk ) { paste0("<span style=\"color:#ff0000\">**", nrow(fusions[ fusions$geneA_dna_support == "Yes" | fusions$geneB_dna_support == "Yes" , ]), "**</span> **DNA-supported** fusion genes (see [Structural variants] section) and <span style=\"color:#02d653\">**", nrow(fusions[ fusions$reported_fusion == "Yes" , ]), "**</span> gene fusions **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB)** were screened for suitable drugs.") } else if ( params$drugs && !runFusionChunk ) { paste0("<span style=\"color:#ff0000\">**0**</span> involving **DNA-supported** fusion genes (see [Structural variants] section) and <span style=\"color:#02d653\">**0**</span> gene fusions **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB)** were screened for suitable drugs.") }`

```{r drugs_predictive_fusion_genes, comment = NA, message=FALSE, warning=FALSE, eval = runFusionChunk}
##### Generate table with drugs targeting fusion genes
genesA <- as.vector(fusions[fusions_ann$reported_fusion == "Yes" | fusions_ann$geneA_dna_support == "Yes" | fusions_ann$geneB_dna_support == "Yes", ]$geneA)
genesB <- as.vector(fusions[fusions_ann$reported_fusion == "Yes" | fusions_ann$geneA_dna_support == "Yes" | fusions_ann$geneB_dna_support == "Yes", ]$geneB)

drugsTable.fusion_genes <- RNAsum::civicDrugTable(
  genes = unique(c(genesA, genesB)),
  civic_var_summaries = ref_genes.list[["civic_var_summaries"]],
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]],
  evid_type = "Predictive", var_type = "fusion"
)

if (params$drugs) {
  drugsTable.fusion_genes[[1]]
}

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = drugsTable.fusion_genes[[1]],
    file = file.path(drugsTableDir, "drugsTable.fusion_genes.html")
  )
}
```

`r if ( params$drugs ) { c("<details>\n<summary>Table legend</summary>\n<font size=\"2\">") }`

```{r drugsTable_legend_fusion_genes, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, results="asis", eval=F}
cat(drugsTable_legend)
```

`r if ( params$drugs ) { c("</font>\n</details>") }`

`r if ( params$drugs ) { c("***") }`

`r if ( params$drugs ) { c("### - Structural variants -") }`

`r if ( params$drugs && !runSVsChunk ) { c("SVs information for this sample is **NOT AVAILABLE**.") }`

`r if ( params$drugs && runSVsChunk ) { paste0("**", length(unique(sv$melted_variants$Genes)), "** genes affected by structural variants (SVs) were screened for suitable drugs (see [Structural variants] section).") } else if ( params$drugs && !runSVsChunk ) { paste0("**0** genes affected by structural variants (SVs) were screened for suitable drugs (see [Structural variants] section).") }`

```{r drugs_predictive_sv_genes, comment = NA, message=FALSE, warning=FALSE, eval = runSVsChunk}
##### Generate table with drugs targeting dysregulated cancer genes
genes <- unique(sv$melted_variants$Genes)

drugsTable.sv_genes <- RNAsum::civicDrugTable(
  genes,
  civic_var_summaries = ref_genes.list[["civic_var_summaries"]],
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]],
  evid_type = "Predictive", var_type = NULL
)

if (params$drugs) {
  drugsTable.sv_genes[[1]]
}

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = drugsTable.sv_genes[[1]],
    file = file.path(drugsTableDir, "drugsTable.sv_genes.html")
  )
}
```

`r if ( params$drugs ) { c("<details>\n<summary>Table legend</summary>\n<font size=\"2\">") }`

```{r drugsTable_legend_sv_genes, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, results="asis", eval=F}
cat(drugsTable_legend)
```

`r if ( params$drugs ) { c("</font>\n</details>") }`

`r if ( params$drugs ) { c("***") }`

`r if ( params$drugs ) { c("### - CN altered genes - {.tabset}") }`

`r if ( params$drugs && !runPurpleChunk ) { c("CN information for this sample is **NOT AVAILABLE**.") }`

`r if ( params$drugs && runPurpleChunk ) { paste0("**", length(cn_genes), "** genes with CN values >= ", cn_top, "  (**gains**) or =< ", cn_bottom, " (**losses**) were screened for suitable drugs (see [CN altered genes] section).") } else if ( params$drugs && !runPurpleChunk ) { paste0("**0** genes were affected by CN changes (see [CN altered genes] section).") }`

`r if ( params$drugs ) { c("#### Gains") }`

```{r drugs_predictive_cn_altered_genes_gains, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Generate table with drugs targeting CN altered genes
genes <- cn_expr_genes.expr.gains.perc[[2]]$SYMBOL

drugsTable.CN_altered_genes_gains <- RNAsum::civicDrugTable(
  genes,
  civic_var_summaries = ref_genes.list[["civic_var_summaries"]],
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]],
  evid_type = "Predictive", var_type = "copy_gain"
)

if (params$drugs) {
  drugsTable.CN_altered_genes_gains[[1]]
}

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = drugsTable.CN_altered_genes_gains[[1]],
    file = file.path(drugsTableDir, "drugsTable.CN_altered_genes_gains.html")
  )
}
```

`r if ( params$drugs ) { c("<details>\n<summary>Table legend</summary>\n<font size=\"2\">") }`

```{r drugsTable_legend_cn_gains_genes, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, results="asis", eval=F}
cat(drugsTable_legend)
```

`r if ( params$drugs ) { c("</font>\n</details>") }`

`r if ( params$drugs ) { c("***") }`

`r if ( params$drugs ) { c("#### Losses") }`

```{r drugs_predictive_cn_altered_genes_losses, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Generate table with drugs targeting CN altered genes
genes <- cn_expr_genes.expr.losses.perc[[2]]$SYMBOL

drugsTable.CN_altered_genes_losses <- RNAsum::civicDrugTable(
  genes,
  civic_var_summaries = ref_genes.list[["civic_var_summaries"]],
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]],
  evid_type = "Predictive", var_type = "copy_loss"
)

if (params$drugs) {
  drugsTable.CN_altered_genes_losses[[1]]
}

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = drugsTable.CN_altered_genes_losses[[1]],
    file = file.path(drugsTableDir, "drugsTable.CN_altered_genes_losses.html")
  )
}
```

`r if ( params$drugs ) { c("<details>\n<summary>Table legend</summary>\n<font size=\"2\">") }`

```{r drugsTable_legend_cn_losses_genes, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, results="asis", eval=F}
cat(drugsTable_legend)
```

`r if ( params$drugs ) { c("</font>\n</details>") }`

`r if ( params$drugs ) { c("***") }`

`r if ( params$drugs ) { c("### - HRD genes -") }`

`r if ( params$drugs ) { paste0("**", length(which(hrd_genes.expr.perc[[2]]$SYMBOL %in% rownames(ref_dataset.list[[dataset]][["data_to_report"]]))), "** reliably measured [HRD genes] were screened for suitable drugs (see [HRD genes] section).") }`

```{r drugs_predictive_hrd_genes, comment = NA, message=FALSE, warning=FALSE}
##### Generate table with drugs targeting mutated cancer genes
genes <- hrd_genes.expr.perc[[2]] |>
  dplyr::filter(.data$SYMBOL %in% rownames(ref_dataset.list[[dataset]][["data_to_report"]])) |>
  dplyr::pull(.data$SYMBOL)

drugsTable.hrd_genes <- RNAsum::civicDrugTable(
  genes,
  civic_var_summaries = ref_genes.list[["civic_var_summaries"]],
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]],
  evid_type = "Predictive", var_type = "mutation"
)

if (params$drugs) {
  drugsTable.hrd_genes[[1]]
}

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = drugsTable.hrd_genes[[1]],
    file = file.path(drugsTableDir, "drugsTable.hrd_genes.html")
  )
}
```

`r if ( params$drugs ) { c("<details>\n<summary>Table legend</summary>\n<font size=\"2\">") }`

```{r drugsTable_legend_hrd_genes, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, results="asis", eval=F}
cat(drugsTable_legend)
```

`r if ( params$drugs ) { c("</font>\n</details>") }`

`r if ( params$drugs ) { c("***") }`

`r if ( params$drugs ) { c("### - Cancer genes -") }`

`r if ( params$drugs ) { paste0("**50** cancer genes with the greatest difference in standarised (Z-score) mRNA expression values between patient's sample and the average mRNA expression in samples from cancer patients were screened for suitable drugs (see [Cancer genes] section).") }`

```{r drugs_predictive_cancer_genes, comment = NA, message=FALSE, warning=FALSE}
##### Update MySQL commend to populate RNA-seq data portal
mysql_populate <- paste0(mysql_populate, ",Drug matching")
mysql_populate_update <- paste0(mysql_populate_update, ",Drug matching")

##### Generate table with drugs targeting dysregulated cancer genes
genes <- cancer_genes.expr.perc[[2]]$SYMBOL[1:50]

drugsTable.cancer_genes <- RNAsum::civicDrugTable(
  genes,
  civic_var_summaries = ref_genes.list[["civic_var_summaries"]],
  civic_clin_evid = ref_genes.list[["civic_clin_evid"]],
  evid_type = "Predictive", var_type = "expression"
)

if (params$drugs) {
  drugsTable.cancer_genes[[1]]
}

##### Save the expression table as html file
if (params$save_tables) {
  RNAsum::saveWidgetFix(
    widget = drugsTable.cancer_genes[[1]],
    file = file.path(drugsTableDir, "drugsTable.cancer_genes.html")
  )
}
```

`r if ( params$drugs ) { c("<details>\n<summary>Table legend</summary>\n<font size=\"2\">") }`

```{r drugsTable_legend_cancer_genes, echo=FALSE, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, results="asis", eval=F}
cat(drugsTable_legend)
```

`r if ( params$drugs ) { c("</font>\n</details>") }`

`r if ( params$drugs ) { c("***") }`

```{r mysql_populate_finalise, message=FALSE, warning=FALSE}
##### Finalise and write into a file the MySQL commend to populate RNA-seq data portal
##### Add input data info
mysql_populate <- paste0(mysql_populate, ",Input data")
mysql_populate_update <- paste0(mysql_populate_update, ",Input data")
mysql_populate <- paste0(mysql_populate, "\", \"Transcriptome summary for sample ", sample_name, " generated on ", Sys.Date(), "\"", ", \"", Sys.Date(), "\" )")
mysql_populate_update <- paste0(mysql_populate_update, "\", Summary=\"Transcriptome summary for sample ", sample_name, " generated on ", Sys.Date(), "\"", ", Date=\"", Sys.Date(), "\";")
mysql_populate <- paste0(mysql_populate, "\n  ", mysql_populate_update, "\nSET @ID := 0;\nUPDATE RNAseq_reports SET ID = ( SELECT @ID := @ID + 1 );")
writeLines(mysql_populate, con = paste0(results_dir, "/", sample_name, ".RNAseq_report.sql"))
```

## Addendum {.tabset .tabset-pills}

<details>

<summary>Details</summary>

### Params

```{r params_info}
params |>
  purrr::modify_if(is.null, \(x) "NULL", .else = as.character) |>
  tibble::enframe(name = "Parameter", value = "Value") |>
  tidyr::unnest("Value", keep_empty = TRUE) |>
  knitr::kable()
```

### Runtimes

```{r step_runtimes}
x <- all_chunk_runtimes |>
  unlist() |>
  tibble::enframe() |>
  dplyr::mutate(
    value = round(value, 0),
    n = dplyr::row_number()
  ) |>
  dplyr::select("n", "name", "value")
tot_sec <- sum(x$value)
tot_min <- tot_sec %/% 60
rem_sec <- floor(tot_sec %% 60)
tot <- paste0(tot_min, "min:", rem_sec, "sec")
x |>
  dplyr::mutate(
    value = as.character(value),
    n = as.character(n)
  ) |>
  dplyr::bind_rows(tibble::tibble(n = "", name = "TOTAL", value = tot)) |>
  knitr::kable()
```

### SessionInfo {.tabset .tabset-pills}

```{r si_prep}
si <- RNAsum::session_info_tbls()
si_pkg <- si$si_pkg
si_pl <- si$si_pl
```

#### Platform

```{r si_pl}
si_pl |>
  knitr::kable()
```

#### Packages

```{r si_pkg}
si_pkg |>
  knitr::kable()
```

#### SysInfo

```{r reporter_details, comment = NA}
tibble::tribble(
  ~Info, ~Value,
  "Node", Sys.info()["nodename"],
  "OS", Sys.info()["sysname"],
  "User", Sys.info()["user"],
) |>
  knitr::kable()
```

</details>
