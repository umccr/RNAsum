---
title: 'UMCCR Transcriptome Patient Summary'
author: 'Jacek Marzec, Sehrish Kanwal, Lavinia Gordon'
date: '`r Sys.Date()`'
output:
  html_document:
    theme: readable
    toc: true
    toc_float: true
    code_folding: hide
  rmdformats::material:
    highlight: kate
params:
  report_dir: '/Users/kanwals/Documents/UMCCR/data/RNAseq-report/Patients/final/CCR180038_SV18T002P006_RNA/RNAseq_report'
  sample_name: 'CCR180038_SV18T002P006_RNA'
  count_file: '/Users/kanwals/Documents/UMCCR/data/RNAseq-report/Patients/final/CCR180038_SV18T002P006_RNA/CCR180038_SV18T002P006_RNA-ready.counts'
  tissue: 'pancreas'
  plots_mode: 'static'
  batch: '/Users/kanwals/Documents/UMCCR/data/RNAseq-report/Patients/umccrised/2016_249_18_SV_P006_1__CCR180038_SV18T002P006'
  ref_data_dir: '../data'
  genes_cancer: 'genes/umccr_cancer_genes.20190122.tsv'
  genes_immune: 'genes/Genes_immune.txt'
  genes_hrd: 'genes/Genes_HRD.txt'
  oncokb_genes: 'OncoKB/CancerGenesList.txt'
  oncokb_clin_vars: 'OncoKB/allActionableVariants.txt'
  oncokb_all_vars: 'OncoKB/allAnnotatedVariants.txt'
  civic_var_summaries: 'CIViC/01-Oct-2018-VariantSummaries.tsv'
  civic_clin_evid: 'CIViC/01-Oct-2018-ClinicalEvidenceSummaries.tsv'
  cancer_biomarkers_trans: 'cancer_biomarkers_database/cancer_genes_upon_trans.tsv'
  FusionGDB: 'FusionGDB/TCGA_ChiTaRS_combined_fusion_ORF_analyzed_gencode_h19v19_fgID.txt'
  cn_loss: 1.5
  cn_gain: 3
  ensembl_version: 86
  ucsc_genome_assembly: 19
---

RNA-seq report for patient sample **`r params$sample_name`**.

```{r script_description, eval=FALSE}
##### We attempt to structure the script in the following way:

# 1. Defining functions
# 2. Loading libraries
# 3. Loading sample data and reference datasets
# Then... code chunks involving data processing
# Then... code chunks calling the processed data to produce tables / plots / data summary
# Finish with Session info in Addendum section

##### The processed data is stored in "ref_datasets.list" list variable with elements holding the following data:

# 1. ref_datasets.list[[tissue]][["combined_data"]] = combined read count data (reference datasets + sample data) ("combineDatasets" function output in the "load_ref_data chunk")

# 2. ref_datasets.list[[tissue]][["sample_annot"]] = combined data samples annotation ("combineDatasets" function output in the "load_ref_data chunk")

# 3. ref_datasets.list[[tissue]][["combined_data_processed"]] = transformed, filtered and normalised data (see "data_transformation" and "data_normalisation" chunks)

# 4. ref_datasets.list[[tissue]][["pca"]] = PCA results

# 5. ref_datasets.list[[tissue]][["gene_annot_all"]] = gene annotation for combined read count data, containing all input genes. The annotation includes "SYMBOL", "GENEBIOTYPE", "ENSEMBL", "SEQNAME", "GENESEQSTART", "GENESEQEND". "ENSEMBL" is used for rownames

# 6. ref_datasets.list[[tissue]][["gene_annot"]] = gene annotation for transformed, filtered and normalised data. The annotation includes "SYMBOL", "GENEBIOTYPE", "ENSEMBL", "SEQNAME", "GENESEQSTART", "GENESEQEND". "SYMBOL" is used for rownames

# 7. ref_datasets.list[[tissue]][["expr_mut_cn_data"]] = combined expression, mutation and copy-number data


##### Genes of interest are stored in "ref_genes.list" list variable with elements holding the following gene sets:

# 1. ref_genes.list[["genes_cancer"]] = list of cancer genes derived from UMCCR Cancer Gene list and OncoKB portal (http://oncokb.org/#/cancerGenes) 

# 2. ref_genes.list[["genes_oncokb"]] = list of cancer genes derived from OncoKB portal (http://oncokb.org/#/cancerGenes) alone (although genes present on the UMCCR panel are also flagged)

# 3. ref_genes.list[["genes_immune"]] = list of immune reponse markers provided in OmniSeq report (https://www.omniseq.com/)

# 4. ref_genes.list[["genes_hrd"]] = list of hrd (homologous recombination deficiency) genes - provided by Richard

# 5. ref_genes.list[["pcgr"]] = list and PCGR annotation of mutated genes in given patient based on PCGR report

# 6. ref_genes.list[["purple"]] = list and PURPLE annotation of copy-number (CN) altered genes in given patient based on PURPLE results

# 7. ref_genes.list[["manta"]] = list and MANTA annotation of structural variants (SVs) with affected genes in given patient based on MANTA results

# 8. ref_genes.list[["pizzly"]] = list and PIZZLY annotation of gene fusion events detected in given patient based on PIZZLY results

# 9. ref_genes.list[["kallisto"]] = genes quantification file from KALLISTO This is required for gene fusion events filtering

# 10. ref_genes.list[["pizzly_manta"]] = list and annotation of gene fusion events detected in given patient based on both PIZZLY and MANTA results
```

```{r chunks_timing, comment=NA, message=FALSE, warning=FALSE}
NOW <- Sys.time()

##### Time chunks during knitting
knitr::knit_hooks$set(timeit = function(before) {
  
  if (before) {
    print(paste("Start:", Sys.time()))
    NOW <<- Sys.time()
    
  } else {
    print(paste("Stop:", Sys.time()))
    print(Sys.time() - NOW)
  }
})

knitr::opts_chunk$set(
  timeit = TRUE
)
```

```{r define_functions, comment=NA, message=FALSE, warning=FALSE}
##### Define functions
##### Create 'not in' operator
"%!in%" <- function(x,table) match(x,table, nomatch = 0) == 0

##### Prepare object to write into a file
prepare2write <- function (x) {
  
  x2write <- cbind(rownames(x), x)
  colnames(x2write) <- c("",colnames(x))
  return(x2write)
}

##### Combine sample expression profile with reference datasets. This function outputs a vector with first element containing the merged data and second element containing merged targets info
combineDatasets <- function(sample_name, sample_counts, ref_dataset) {
  
  ##### Read file with reference datasets information
  DatasetInput <- read.table(ref_dataset, sep="\t", as.is=TRUE, header=TRUE, row.names=1)
  
  ##### Extract info about target file for the first dataset
  fileInfo <- strsplit(DatasetInput[,"Target_file"], split='/', fixed=TRUE)
  targetFile <- read.table(DatasetInput[1,"Target_file"], sep="\t", as.is=TRUE, header=TRUE)[,c(1:4)]
  rownames(targetFile) <- targetFile[,"Sample_name"]
  targetFile <- cbind(targetFile[,2:4],rownames(DatasetInput[1,]))
  colnames(targetFile)[ncol(targetFile)] <- "Dataset"
  
  if ( nrow(DatasetInput) > 1 ) {
    for ( i in 2:nrow(DatasetInput) ) {
        
      ##### Create a temporary object to store info from the remaining target files
      targetFileTmp <- read.table(DatasetInput[i,"Target_file"], sep="\t", as.is=TRUE, header=TRUE)[,c(1:4)]
      rownames(targetFileTmp) <- targetFileTmp[,"Sample_name"]
      targetFileTmp <- cbind(targetFileTmp[,2:4],rownames(DatasetInput[i,]))
      colnames(targetFileTmp)[ncol(targetFileTmp)] <- "Dataset"
        
      targetFile <- rbind(targetFile, targetFileTmp)
    }
  }  
  
  ##### Add sample info
  sampleTargetFile <- data.frame(sample_counts, sample_name, NA, sample_name)
  names(sampleTargetFile) <- names(targetFile)
  rownames(sampleTargetFile) <- sample_name
  targetFile <- rbind( targetFile, sampleTargetFile )
  
  ##### Make syntactically valid names
  rownames(targetFile) <- make.names(rownames(targetFile))
  
  ##### Read sample read count file and combine it with reference datasets
  datasets.comb <- read.table(sample_counts, sep="\t", as.is=TRUE, header=FALSE, row.names=NULL)
  names(datasets.comb) <- c("", sample_name)
      
  ##### list genes present in the read count file
  gene_list <- as.vector(datasets.comb[,1])
      
  ##### Loop through the expression data from different datasets and merge them into one matrix
  for ( data_matrix in DatasetInput[ , "Expression_matrix" ] ) {
    
    ##### Add data from the reference datasets
    dataset <- as.data.frame( read.table(data_matrix, header=TRUE, sep="\t", row.names=NULL) )
      
    ##### list genes present in individal files
    gene_list <- c( gene_list, as.vector(dataset[,1]) )
    
    ##### Merge the expression datasets and make sure that the genes order is the same
    datasets.comb <- merge( datasets.comb, dataset, by=1, all = FALSE, sort= TRUE)
      
    ##### Remove per-sample data for merged samples to free some memory
    rm(dataset)
  }
  
  ##### Use gene IDs as rownames
  rownames(datasets.comb) <- datasets.comb[,1]
  datasets.comb <- datasets.comb[, -1]
  
  ##### Make syntactically valid names
  colnames(datasets.comb) <- make.names(colnames(datasets.comb))
  
  ##### Make sure that the target file contains info only about samples present in the data matrix
  targetFile <- targetFile[ rownames(targetFile) %in% colnames(datasets.comb),  ]
  
  ##### Make sure that the samples order in the data matrix is the same as in the target file 
  datasets.comb <- datasets.comb[ , rownames(targetFile) ]
  
  ##### Identify genes that were not present across all per-sampel files and were ommited in the merged matrix
  gene_list <- unique(gene_list)
  gene_list.missing <- gene_list[ gene_list %!in% rownames(datasets.comb) ]
  
  ##### Write list of missing genes into a file
  if ( length(gene_list.missing) > 0 ) {
    write.table(prepare2write(gene_list.missing), file = paste0(params$report_dir, "/", sample_name,".missing_genes.txt"), sep="\t", quote=FALSE, row.names=TRUE, append = FALSE )
  }
  
    return( list(datasets.comb, targetFile) )
}


##### Assign colours to different groups
getTargetsColours <- function(targets) {
  
##### Predefined selection of colours for groups
targets.colours <- c("red","cornflowerblue","green","darkred","darkgoldenrod","deepskyblue", "coral", "blue", "chartreuse4", "bisque4", "chocolate3", "cadetblue3", "darkslategrey", "lightgoldenrod4", "mediumpurple4", "orangered3","indianred1","blueviolet","darkolivegreen4","darkgoldenrod4","firebrick3","deepskyblue4", "coral3", "dodgerblue1", "chartreuse3", "bisque3", "chocolate4", "cadetblue", "darkslategray4", "lightgoldenrod3", "mediumpurple3", "orangered1")
  
  f.targets <- factor(targets)
  vec.targets <- targets.colours[1:length(levels(f.targets))]
  targets.colour <- rep(0,length(f.targets))
  for(i in 1:length(f.targets))
    targets.colour[i] <- vec.targets[ f.targets[i]==levels(f.targets)]
  
  return( list(vec.targets, targets.colour) )
}

##### Assign colours to different datasets
getDatasetsColours <- function(datasets) {
  
  ##### Predefined selection of colours for datasets
  datasets.colours <- c("dodgerblue","firebrick","lightslategrey","darkseagreen","orange","darkcyan","bisque", "coral2", "cadetblue3","red","blue","green")
  
  f.datasets <- factor(datasets)
  vec.datasets <- datasets.colours[1:length(levels(f.datasets))]
  datasets.colour <- rep(0,length(f.datasets))
  for(i in 1:length(f.datasets))
    datasets.colour[i] <- vec.datasets[ f.datasets[i]==levels(f.datasets)]
  
  return( list(vec.datasets, datasets.colour) )
}

##### Perform PCA. This function outputs a list with dataframe and samples colouring info ready for plotting
pca <- function(data, targets) {

  ##### Keep only genes with variance > 0 across all samples
  rsd <- apply(data,1,sd)
  data.subset <- data[rsd>0,]
  
  ##### Perform PCA
  data.subset_pca <- prcomp(t(data.subset), scale=FALSE)
  
  ##### Get variance importance for all principal components
  importance_pca <- summary(data.subset_pca)$importance[2,]
  importance_pca <- paste(round(100*importance_pca, 2), "%", sep="")
  names(importance_pca) <- names(summary(data.subset_pca)$importance[2,])
    
  ##### Prepare data frame
  data.subset_pca.df <- data.frame(targets$Target, targets$Dataset, data.subset_pca$x[,"PC1"], data.subset_pca$x[,"PC2"], data.subset_pca$x[,"PC3"])
  colnames(data.subset_pca.df) <- c("Target", "Dataset", "PC1", "PC2", "PC3")
  
  ##### Assigne colours to targets and datasets
  targets.colour <- getTargetsColours(target$Target)
  datasets.colour <- getDatasetsColours(target$Dataset)
  
  ##### Create a list with dataframe and samples colouring info
  pca.list <- list(data.subset_pca.df, importance_pca, targets.colour, datasets.colour)
  names(pca.list) <- c("pca.df", "importance_pca", "targets", "datasets")
  
  return( pca.list )
}

##### Convert a vector of numbers into corresponding vector of their percentiles
perc.rank <- function(x) trunc(rank(x))*100/length(x)

##### Perform range standardization between 0 and 1 (for the cumulative sums)
standardization <- function(x) sort(x-min(x))/(max(x)-min(x))

##### Calculate mean, sd, quantiles and cumulative franctions for expression data from specific sample group
exprGroupStats <- function(data, targets, target) {
  
  ##### Subset data for defined biological group
  data.group <- data[, targets$Target %in% target ]
  
  ##### For groups with > 1 sample get the mean and standard deviation for each gene
  if ( !is.null(ncol(data.group)) )  {
    
    data.group.mean <- rowMeans(data.group)
    data.group.mean <- sort(data.group.mean)
    data.group.sd <- rowSds(data.group)
    
  } else {
    data.group.mean <- sort(data.group)
    data.group.sd <- rep( NA, length(data.group))
  }
  
  ##### Make sure the mean and sd vectors have the same gene order
  names(data.group.sd) <- rownames(data)
  data.group.sd <- data.group.sd[names(data.group.mean)]

  ##### Convert a expression values into corresponding percentiles
  data.group.q <- perc.rank(data.group.mean)
  
  ##### Perform range standardization between 0 and 1 (for the cumulative sums), otherwise the negative values are summed up
  data.group.s <- standardization(data.group.mean)
  
  ##### Calculate cumulative sums and perform range standardization between 0 and 1 
  data.group.cum <- standardization(cumsum(data.group.s))
  
  ##### Perform Z-score transformation of the mean expression values
  data.group.z <- scale(data.group.mean)
  
  ##### Organise the data into data frame
  data.group.df <- as.data.frame(cbind( data.group.mean, data.group.sd, data.group.z, data.group.q, data.group.cum))
  names(data.group.df) <- c("mean", "sd", "z", "quantile", "cumulative_fraction")
  
  return( data.group.df )
}

##### Generate cumulative distribution function (CDF) plot for selected gene. If option "addBoxPlot" = TRUE, then generate additional boxplot below to show the data variance for selected gene in individual groups
cdfPlot <- function(gene, data, targets, sampleName, normal, cancer, addBoxPlot = FALSE, plot_mode = "static") {
  
  ##### Get expression-related stats for each group
  sample.expr.cum <- exprGroupStats(data, targets, sampleName)
  cancer.expr.cum <- exprGroupStats(data, targets, cancer)
  normal.expr.cum <- exprGroupStats(data, targets, normal)
  
  ##### Extract expression for selected genes
  sample.expr.cum.selected <- sample.expr.cum[ rownames(sample.expr.cum) %in% gene, ]
  cancer.expr.cum.selected <- cancer.expr.cum[ rownames(cancer.expr.cum) %in% gene, ]
  normal.expr.cum.selected <- normal.expr.cum[ rownames(normal.expr.cum) %in% gene, ]
  
  ##### Generate box-plot for selected gene
  if ( addBoxPlot ) {
    
    data.z <- scale(data)
    targets$Target[ targets$Target==sampleName ] <- "Patient"
    
    gene.expr.df <- data.frame(targets$Target, data.z[gene, ])
    colnames(gene.expr.df) <- c("Group", "Expression")
    
    ##### Reorder groups
    gene.expr.df$Group <- factor(gene.expr.df$Group, levels=c(normal, cancer, "Patient"))
    
    p2 <- plot_ly(gene.expr.df, x= ~Expression, color = ~Group, type = 'box', jitter = 0.3, pointpos = 0, boxpoints = 'all', colors = c("darkseagreen1", "red", "black"), opacity = 0.5, orientation = 'h', width = 800, height = 600, showlegend=FALSE)
  }
  
  ##### Generate interactive CFD plot with plotly
  p1 <- plot_ly(sample.expr.cum, x = ~z, color = I("black")) %>%
  
    ##### Add sample data
    add_markers(y = sample.expr.cum.selected$cumulative_fraction, x = sample.expr.cum.selected$z,
                text = rownames(sample.expr.cum.selected ),
                name = "Patient",
                marker = list(size = 12, color = "black"),
                showlegend = TRUE) %>%
  
    add_lines(y = sample.expr.cum$cumulative_fraction, x = sample.expr.cum$z, 
              line = list(color = "grey"),
              text = rownames( sample.expr.cum ),
              name = "Patient", showlegend = FALSE) %>%
    
    ##### Add cancer data
    add_markers(y = cancer.expr.cum.selected$cumulative_fraction, x =  cancer.expr.cum.selected$z,
                text = rownames( cancer.expr.cum.selected),
                name = cancer,
                marker = list(size = 12, opacity = 0.5, color = "red"),
                showlegend = TRUE) %>%
  
    add_lines(y = cancer.expr.cum$cumulative_fraction, x = cancer.expr.cum$z, opacity = 0.5,
              line = list(color = "red", dash = "dash"),
              text = rownames( cancer.expr.cum ),
              name = cancer, showlegend = FALSE) %>%
    
    ##### Add normal data
    add_markers(y = normal.expr.cum.selected$cumulative_fraction, x =  normal.expr.cum.selected$z,
                text = rownames( normal.expr.cum.selected ),
                name = normal,
                marker = list(size = 12, opacity = 0.1, color = "green"),
                showlegend = TRUE) %>%
  
    add_lines(y = normal.expr.cum$cumulative_fraction, x = normal.expr.cum$z, opacity = 0.1,
              line = list(color = "green", dash = "dash"),
              text = rownames( normal.expr.cum ),
              name = normal, showlegend = FALSE) %>%
    
    ##### Add quantile lines
    add_lines(y = seq(0,1,0.1), x = rep(quantile(sample.expr.cum$z)[2], 11), opacity = 0.5,
              line = list(color = "gray", dash = "dash"),
              name = "Q1", showlegend = FALSE) %>%
    
    add_lines(y = seq(0,1,0.1), x = rep(quantile(sample.expr.cum$z)[3], 11), opacity = 0.5,
              line = list(color = "gray", dash = "dash"),
              name = "Q2", showlegend = FALSE) %>%
    
    add_lines(y = seq(0,1,0.1), x = rep(quantile(sample.expr.cum$z)[4], 11), opacity = 0.5,
              line = list(color = "gray", dash = "dash"),
              name = "Q3", showlegend = FALSE) %>% 
    
        layout(title = gene, xaxis = list(title = "mRNA expression (Z-score)", zeroline = FALSE, range = c(min(sample.expr.cum$z)-1.5, max(sample.expr.cum$z)+1.5)),
           yaxis = list(title = "Cumulative fraction"),
           legend = list(orientation = 'v', x = 0.02, y = 1, bgcolor = "white")
           
           ##### Annotate the gene of interest
           #annotations = list(x = sample.expr.cum.selected$z, y = sample.expr.cum.selected$cumulative_fraction,
           #text = rownames(sample.expr.cum.selected), xref = "x", yref = "y", showarrow = TRUE, arrowhead = 0, opacity = 0.5, ax = 30, ay = 30)
    )
  
  ##### Combine CDF plot with boxplot if this option is selected
  if ( addBoxPlot ) {
    
    p1_2 <- subplot(p1, p2, nrows = 2, shareX = TRUE, shareY = FALSE, titleY = TRUE) %>%
  layout(xaxis = list(title = "mRNA expression (Z-score)", zeroline = FALSE, range = c(min(sample.expr.cum$z)-1.5, max(sample.expr.cum$z)+1.5)),
          yaxis = list(title = "Cumulative fraction"),
          legend = list(orientation = 'v', x = 0.02, y = 1, bgcolor = "white"),
          yaxis2 = list( title =""), xaxis2 = list(title = paste0(gene, " mRNA expression (Z-score)")), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = FALSE,
         showlegend=TRUE, showlegend2=FALSE)
    
    ##### Embed static rather interactive plots into the html report if requested by user. This will reduce the report size. To this end the orca() function in plotly is used. Of note, this requires orca (https://github.com/plotly/orca) installation (conda option worked well for me, https://github.com/plotly/orca#method-1-conda), but the orca needs to be in the PATH, see https://github.com/plotly/orca/pull/122). In case of issues/errors (such as orca utility is required to use orca() function), it might be needed to restart Rstudio from the commandline using "open -na Rstudio" and for 'Argument list too long' try "devtools::install_github('ropensci/plotly')"
    if ( plot_mode == "static" ) {

      ##### Create directory for CDF plots
      cdfPlotsDir <- paste(params$report_dir, "CDF_plots", sep = "/")
      if ( !file.exists(cdfPlotsDir) ) {

        dir.create(cdfPlotsDir, recursive=TRUE)
      }
  
      ##### Add access token, required by orca function, to the shell environment
      Sys.setenv('MAPBOX_TOKEN' = 'secret token')
  
      ##### Change directory to folder with CDF plots
      setwd(cdfPlotsDir)
 
      ##### Save the static image into a file
      orca(p1_2, format = "png", file = paste0(gene, "_cdf_box_plot.png"), width = 800, height = 600)
  
      ##### Present the static plot in the report
      include_graphics(paste(cdfPlotsDir, paste0(gene, "_cdf_box_plot.png"), sep = "/"), dpi = 72)
  
    } else if ( plot_mode == "interactive" ) {

      return( p1_2 )
    }
    
  } else {
   
    if ( plot_mode == "static") {

      ##### Create directory for CDF plots
      cdfPlotsDir <- paste(params$report_dir, "CDF_plots", sep = "/")
      if ( !file.exists(cdfPlotsDir) ) {

        dir.create(cdfPlotsDir, recursive=TRUE)
      }
  
      ##### Add access token, required by orca function, to the shell environment
      Sys.setenv('MAPBOX_TOKEN' = 'secret token')
  
      ##### Change directory to folder with CDF plots
      setwd(cdfPlotsDir)
  
      ##### Save the static image into a file
      orca(p1, format = "png", file = paste0(gene, "_cdf_plot.png"), width = 800, height = 200)
  
      ##### Present the static plot in the report
      include_graphics(paste(cdfPlotsDir, paste0(gene, "_cdf_plot.png"), sep = "/"), dpi = 72)
  
    } else if ( plot_mode == "interactive" ) {

      return( p1 )
    }
  }
}

##### Generate scatterplot with per-gene expression values (y-axis), CN values (x-axis) and mutation status info (colours), if provided
mutCNexprPlot <- function(data, mut_data = FALSE, cn_bottom = 1.5, cn_top = 3, cancer, plot_mode = "static") {
  
  ##### Generate scatterplot with per-gene expression values (y-axis) (difference between Patient's and [cancer] data), CN values (x-axis) and mutation status info (colours)
  if ( mut_data ) {
  
    p <- plot_ly(data, x = ~CN, y = ~Z_score_diff, color = ~Mutation, text=~Gene, type='scatter', mode = "markers", marker = list(size=10, symbol="circle"), width = 800, height = 600) %>%
      
      add_annotations( text="Mutation", xref="paper", yref="paper",
                      x=1.02, xanchor="left",
                      y=1, yanchor="top",
                      legendtitle=TRUE, showarrow=FALSE ) %>%
      
      add_annotations( data = data[ data$CN > cn_top | data$CN < cn_bottom ,], text=~Gene,
                      x=~CN, xanchor="left",
                      y=~Z_score_diff, yanchor="top",
                      font = list(color = "Grey",
                                size = 10),
                      legendtitle=TRUE, showarrow=FALSE ) %>%
      
      layout( xaxis = list(title = "CN values"), yaxis = list(title = paste0("mRNA expression (Z-score [Patient vs ", cancer, "])")), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = F, legend = list( orientation = 'v', x=1, y=0.97, yanchor="top"), showlegend=TRUE)
  
  ##### Generate scatterplot with per-gene expression values (y-axis) and CN values (x-axis)
  } else {
  
    p <- plot_ly(data, x = ~CN, y = ~Z_score_diff, text=~Gene, type='scatter', mode = "markers", marker = list(size=10, symbol="circle"), width = 800, height = 600) %>%
      
      add_annotations( data = data[ data$CN > cn_top | data$CN < cn_bottom ,], text=~Gene,
                      x=~CN, xanchor="left",
                      y=~Z_score_diff, yanchor="top",
                      font = list(color = "Grey",
                                size = 10),
                      legendtitle=TRUE, showarrow=FALSE ) %>%
      
      layout( xaxis = list(title = "CN values"), yaxis = list(title =  paste0("mRNA expression (Z-score [Patient vs ", cancer, "])")), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = F, legend = list( orientation = 'v', y=0.8, yanchor="top"), showlegend=FALSE)
  }
  
  ##### Create directory for the plots
  mutCNexprPlotDir <- paste(params$report_dir, "mut_cn_expr_plot", sep = "/")
  if ( !file.exists(mutCNexprPlotDir) ) {

    dir.create(mutCNexprPlotDir, recursive=TRUE)
  }
    
  ##### Save interactive plot as html file
  htmlwidgets::saveWidget(p, file = paste(mutCNexprPlotDir, "mut_cn_expr_plot.html", sep = "/"))
  
  ##### Embed static rather interactive plots into the html report if requested by user. This will reduce the report size. TO this end the orca() function in plotly is used. Of note, this requires orca (https://github.com/plotly/orca) installation (conda option worked well for me, https://github.com/plotly/orca#method-1-conda), but the orca needs to be in the PATH, see https://github.com/plotly/orca/pull/122). 
  if ( plot_mode == "static" ) {
    
    ##### Add access token, required by orca function, to the shell environment
    Sys.setenv('MAPBOX_TOKEN' = 'secret token')

    ##### Change directory to folder with CDF plots
    setwd(mutCNexprPlotDir)

    ##### Save the static image into a file
    orca(p, format = "png", file = "mut_cn_expr_plot.png", width = 800, height = 600)

    ##### Present the static plot in the report
    include_graphics(paste(mutCNexprPlotDir, "mut_cn_expr_plot.png", sep = "/"), dpi = 72)
  
  } else if ( plot_mode == "interactive" ) {

    return( p )
  }
}

##### Fusion visualisation 
fusion_png <- function(geneA, geneB, clinker_results ) {

  ##### Get path to fusion visualisation  pdf file
  fusion_pdf <- paste(clinker_results, paste0(geneA, "_", geneB, ".pdf"), sep = "/")
  
  ##### Export pdf to png
  fusion_png <- paste(clinker_results, paste0(geneA, "_", geneB, ".png"), sep = "/")
  fusion <- image_read_pdf(fusion_pdf, pages = NULL, density = 300)
  image_write(fusion, path = fusion_png, format = "png")
  
  ##### Present the converted file in the report
  include_graphics(fusion_png)
}


##### Generate table with coloured cells indicating expression values for selected genes
exprTable <- function(genes, data, cn_data = NULL, sv_data = NULL, cn_decrease = TRUE, targets, sampleName, normal, cancer, genes_annot = NULL, cancer_genes = NULL, mut_annot = NULL, fusion_genes = NULL, ext_links = FALSE, type = "z") {
  
  ##### Check which of the selected genes are not present in the expression data
  genes.absent <- genes[ genes %!in% rownames(data) ]
  
  targets.list <- unique(targets$Target)
  
  ##### Initiate dataframe for expression mean values in each group
  group.z <- as.data.frame(matrix(NA, ncol = length(targets.list), nrow = nrow(data)))
  colnames(group.z) <- targets.list
  rownames(group.z) <- sort(rownames(data))
  
  for ( group in targets.list ) {
    
    ##### Calculate z-score for each group  
    group.stats <- exprGroupStats(data[rownames(group.z), ], targets, group)
    group.stats <- group.stats[order(rownames(group.stats)), ]
    
    #### Present expression data as percentiles or z-score values (default)
    if ( type == "perc" ) {
      
      group.z[, group] <- round(group.stats$quantile, digits=1)

    } else {
      group.z[, group] <- round(group.stats$z, digits=2)
    }
  } 
  
  ##### Compute Z-scores sd for each gene across groups
  group.z <- cbind(group.z, round(rowSds(as.matrix(group.z)), digits = 2))
  names(group.z)[ncol(group.z)] <- "SD"
  
  ##### Calculate Z-score differneces between investigated sample and cancer group mean values
  group.z <- cbind(group.z, round((group.z[, sampleName] - group.z[, cancer]), digits = 2))
  names(group.z)[ncol(group.z)] <- paste0("Patient vs ", cancer)
  
  ##### Add NAs for genes that are absent in the expression matrix. In the "Patient vs [cancer]" columns provide "0"s to facilitate interactive sorting the table. These will appear in blank cells in the table
  if ( length(genes.absent) > 0 ) {
    
    NAs.df <- data.frame(matrix(NA, ncol = ncol(group.z), nrow = length(genes.absent)))
    names(NAs.df) <- names(group.z)
    rownames(NAs.df) <- genes.absent
    NAs.df[ names(NAs.df) %in% paste0("Patient vs ", cancer) ] <- 0
    
    group.z <- rbind( group.z,  NAs.df)
  }
  
  ##### Change sample ID to "Patient" and normal sample to "Normal" for better visualisation
  names(group.z)[names(group.z)==sampleName] <- "Patient"
  targets.list[targets.list==sampleName] <- "Patient"
  names(group.z)[names(group.z)==normal] <- "Normal"
  targets.list[targets.list==normal] <- "Normal"
  
  ##### Reorder groups
  group.z <- cbind(group.z[ , c("Normal", cancer, "Patient")], group.z[, c("SD", paste0("Patient vs ", cancer) )])
  
  ##### Add "Gene" column to facilitate adding annotations
  group.z$Gene <- rownames(group.z)
  
  ##### Add genes annotation
  if ( !is.null(genes_annot) ) {
    
    ##### Remove rows with duplicated gene symbols
    if ( "SYMBOL" %in% names(genes_annot) ) {
      
      genes_annot <- genes_annot[!duplicated(genes_annot$SYMBOL),]  
    }
    
    ##### Merge the dataframe with groups mean expression values and gene annotations
    group.z <- merge(genes_annot, group.z, by.x="SYMBOL", by.y="Gene", all = TRUE, sort = FALSE)
    names(group.z) <- gsub("SYMBOL", "Gene", names(group.z))
    
  }
  
  ##### Define colours for cells background for each group and the patient vs [cancer] difference
  ##### Initiate dataframe for expression mean values in each group
  brks.q <- as.data.frame( matrix(NA, ncol = length(targets.list), nrow = length(seq(.05, .95, .0005)) ))
  colnames(brks.q) <- targets.list
  clrs.q <- as.data.frame( matrix(NA, ncol = length(targets.list), nrow = length(seq(.05, .95, .0005))+1 ))
  colnames(clrs.q) <- targets.list
  
  for ( group in c(targets.list, paste0("Patient vs ", cancer)) ) {

    brks.q[[group]] <- quantile(group.z[, group], probs = seq(.05, .95, .0005), na.rm = TRUE)
    #brks.q[[group]] <- sort(group.z[, group])
    
    clrs_pos.q <- round(seq(255, 150, length.out = length(brks.q[[group]])/2 + 1.5), 0) %>%
    {paste0("rgb(255,", ., ",", ., ")")}
    clrs_neg.q <- rev(round(seq(255, 150, length.out = length(brks.q[[group]])/2 - 0.5), 0)) %>%
    {paste0("rgb(", .,",", .,",", "255)")}
    
    clrs.q[[group]] <- c(clrs_neg.q, clrs_pos.q)
  }
  
  ##### Subset the expression data to include only the user-defined genes
  group.z <- group.z[ group.z$Gene %in% genes, ]
    
  #### Add variants information to the expression table - if exists. Note, "TIER" and "CONSEQUENCE" columns are required
  if( !is.null(mut_annot) && "TIER" %in% colnames(mut_annot) && length(genes) > 0 ) {
    
    mut_annot <- mut_annot[mut_annot$SYMBOL %in% genes,]
    
    #### keep only varaints that has the lowest tier value. Multiple varaints detected in same gene but with higher tier will be added to additional column "CONSEQUENCE_OTHER". Applies to the ones that may have multiple mutations and hence tiers
    ##### First, create a list of genes to store multiple variants
    mut_consequence <- vector("list", length(unique(mut_annot$SYMBOL)))
    mut_consequence  <- setNames(mut_consequence,  unique(mut_annot$SYMBOL) )
    
    ##### Record all varaints detected in individual genes
    if ( nrow(mut_annot) > 0 ) {
      
      for ( i in 1:nrow(mut_annot) ) {
        
        mut_consequence[[ mut_annot$SYMBOL[i] ]] <- unique(c( mut_consequence[[ mut_annot$SYMBOL[i] ]], mut_annot$CONSEQUENCE[i] ))
      }
      
      mut_annot$CONSEQUENCE_OTHER <- "-"
    }
    
    ##### Remove the first elements since these variant consequences will be reported as the "canonical" CONSEQUENCE
    mut_consequence <- lapply(mut_consequence, function(x) x[-1])
    
    ##### Order variant entires based on tier info, to make sure that the varaints with the lowest tier are reported first
    mut_annot <- mut_annot[ order(mut_annot$TIER), ]
    
    ##### Remove rows with duplicated gene symbols
    mut_annot <- mut_annot[!duplicated(mut_annot$SYMBOL),]  
    rownames(mut_annot) <- mut_annot$SYMBOL
    
    ##### Add other provided variants consequences for individual genes
    for ( gene in rownames(mut_annot) ) {
      
      if ( length(mut_consequence[[ gene ]]) > 0 ) {
        
        mut_annot$CONSEQUENCE_OTHER[ match(gene, mut_annot$SYMBOL)  ] <- mut_consequence[[ gene ]]
      }
    }
    
    #### merge the variants information with the dataframe
    group.z <- merge(group.z, mut_annot, by.x = "Gene", by.y = "SYMBOL", all = TRUE, sort = FALSE)
  }
  
  ##### Add CN data if provided
  if ( !is.null(cn_data) && length(genes) > 0 ) {
    
    ##### Get the position of "Patient vs [cancer]" column
    col_idx <- grep(paste0("Patient vs ", cancer), names(group.z))
    
    ##### Now place the CN data after the "Patient vs [cancer]" column
    group.z <- add_column(group.z, round(cn_data[ group.z$Gene, "CN"], digits=2), .after = col_idx)
    colnames(group.z)[ col_idx+1 ] <- "Patient (CN)"
  }

  ##### Add structural variants results from MANTA
  if ( !is.null(sv_data) && length(genes) > 0 ) {
    
    ##### NOTE: when merging per-gene exprssion data with SV data from MANTA the "gene" column is used since multiple entires are possible for one gene in MANTA output
    group.z <- merge(group.z, sv_data, by.x="Gene", by.y="gene", all = TRUE, sort = FALSE)
  }
  
  ##### Add fusion genes annotation
  if ( !is.null(fusion_genes) && length(genes) > 0 ) {
    
    group.z <- merge(group.z, fusion_genes, by.x="Gene", by.y="row.names", all = TRUE, sort = FALSE)
  }
  
  ##### Add cancer gene resources info
  if ( !is.null(cancer_genes) && length(genes) > 0 ) {
    
    group.z <- merge(group.z, cancer_genes, by.x="Gene", by.y="row.names", all = TRUE, sort = FALSE)
  }
  
  ##### Include only queried genes
  group.z <- group.z[ group.z$Gene %in% genes, ]
    
  group.z$SYMBOL <- group.z$Gene
  
  ##### Add links to external gene annotation resourses
  if ( ext_links && length(genes) > 0 ) {
    
    ##### Place the external links after the "Patient vs [cancer]" column
    ##### Get the position of "Patient vs [cancer]" column
    col_idx <- grep(paste0("Patient vs ", cancer), names(group.z))
    group.z <- add_column(group.z, NA, .after = col_idx)
    names(group.z)[ col_idx+1 ] <- "ext_links"
    
    for ( gene in genes ) {

      ##### Provide link to VICC meta-knowledgebase ( https://search.cancervariants.org )
      group.z$ext_links[ group.z$Gene==gene ] <- paste0("<a href='https://search.cancervariants.org/#", gene, "' target='_blank'>VICC</a>")
      
      ##### Provide link to OncoKB
      if ( gene %in% rownames(ref_genes.list[["genes_oncokb"]]) & ref_genes.list[["genes_oncokb"]][gene, "OncoKB"] == "Yes" ) {
        
        group.z$ext_links[ group.z$Gene == gene ] <- paste( group.z$ext_links[ group.z$Gene==gene ] , paste0("<a href='http://oncokb.org/#/gene/", gene, "' target='_blank'>OncoKB</a>"), sep = ", ")
      }
      
      ##### Provide link to CIViC database druggable genes ( https://civicdb.org )
      if ( gene %in% caner_genes_annot.list[["civic_clin_evid"]]$gene ) {
    
        group.z$ext_links[ group.z$Gene==gene ] <- paste( group.z$ext_links[ group.z$Gene==gene ] , paste0("<a href='", unique(caner_genes_annot.list[["civic_clin_evid"]][ caner_genes_annot.list[["civic_clin_evid"]]$gene == gene , "gene_civic_url"]), "' target='_blank'>CIViC</a>"), sep = ", ")
      }
    }
    
    names(group.z) <- gsub("ext_links", "External resources", names(group.z))
  }
  
  ##### Attach links to GeneCards and Ensembl (if provided). Here we assume that gene names are
  for ( gene in genes ) {
    
    if ( "ENSEMBL" %in% names(group.z) ) {
      
        if ( !is.na(group.z$ENSEMBL[ group.z$Gene==gene ]) ) {
          
        group.z$ENSEMBL[ group.z$Gene==gene ] <- paste0("<a href='http://ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=", group.z$ENSEMBL[ group.z$Gene==gene], "' target='_blank'>", group.z$ENSEMBL[ group.z$Gene == gene ], "</a>")
      }
    }
    
    group.z$Gene[ group.z$Gene==gene ] <- paste0("<a href='https://www.genecards.org/cgi-bin/carddisp.pl?gene=", gene, "' target='_blank'>", gene, "</a>")
  }

  ##### Order the data by CN values (to allow filtering based on CN information) and then by the highest absolute values for Patient vs [cancer] difference (to allow filtering based on z-score differences)
  if ( !is.null(cn_data) && length(genes) > 0 ) {
    
    group.z <- group.z[ order(abs(group.z[, paste0("Patient vs ", cancer)]),  decreasing = TRUE), ]
    group.z <- group.z[ order(group.z[ ,col_idx+1 ],  decreasing = cn_decrease), ]
    
  ##### Order the data by increasing TIER category (to allow filtering based on tier information) and then by the highest absolute values for Patient vs [cancer] difference (to allow filtering based on z-score differences)
  } else if  ( !is.null(mut_annot) && length(genes) > 0 ) {
    
    group.z <- group.z[ order(abs(group.z[, paste0("Patient vs ", cancer)]),  decreasing = TRUE), ]
    group.z <- group.z[ order(group.z$TIER), ]
    
  ##### Order the data by MANTA increasing score (to prioritise SVs, based on https://github.com/AstraZeneca-NGS/simple_sv_annotation/blob/master/simple_sv_annotation.py) and then by the highest absolute values for Patient vs [cancer] difference
  } else if  ( !is.null(sv_data) && length(genes) > 0 ) {
    
    group.z <- group.z[ order(abs(group.z[, paste0("Patient vs ", cancer)]),  decreasing = TRUE), ]
    group.z <- group.z[ order(group.z$score), ]
    
  ##### Otherwise order table by the highest absolute values for Patient vs [cancer] difference
  } else if ( length(genes) > 0 ) {
    
    group.z <- group.z[ order(abs(group.z[, paste0("Patient vs ", cancer)]),  decreasing = TRUE), ]
  }
  
  if ( !is.null(cn_data) ) {
    
    ##### Generate a table with genes annotations and coloured expression values in each group
    dt.table <- DT::datatable( data = group.z[, names(group.z) %!in% "SYMBOL"], filter="none", rownames = FALSE, extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800, caption = htmltools::tags$caption( style = 'caption-side: top; text-align: left; color:grey; font-size:100% ;'), escape = FALSE) %>%
      DT::formatStyle( columns = names(group.z)[names(group.z) %!in% "SYMBOL"], `font-size` = '12px', 'text-align' = 'center' ) %>%
      
      ##### Colour cells according to the expression values quantiles in each group
      DT::formatStyle(columns = targets.list[1], 
                      backgroundColor = DT::styleInterval(brks.q[[targets.list[1]]], clrs.q[[targets.list[1]]])) %>%
      DT::formatStyle(columns = targets.list[2], 
                      backgroundColor = DT::styleInterval(brks.q[[targets.list[2]]], clrs.q[[targets.list[2]]])) %>%
      DT::formatStyle(columns = targets.list[3], 
                      backgroundColor = DT::styleInterval(brks.q[[targets.list[3]]], clrs.q[[targets.list[3]]])) %>%
      DT::formatStyle(columns = paste0("Patient vs ", cancer), 
                      backgroundColor = DT::styleInterval(brks.q[[paste0("Patient vs ", cancer)]], clrs.q[[paste0("Patient vs ", cancer)]])) %>%
      DT::formatStyle(columns = "Patient (CN)", background = DT::styleColorBar(base::range(group.z[ ,"Patient (CN)" ], na.rm = TRUE), 'lightblue'), backgroundSize = '98% 88%', backgroundRepeat = 'no-repeat', backgroundPosition = 'center')
    
  } else {
    
    ##### Generate a table with genes annotations and coloured expression values in each group
    dt.table <- DT::datatable( data = group.z[, names(group.z) %!in% "SYMBOL"], filter="none", rownames = FALSE, extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800, caption = htmltools::tags$caption( style = 'caption-side: top; text-align: left; color:grey; font-size:100% ;'), escape = FALSE) %>%
      DT::formatStyle( columns = names(group.z)[names(group.z) %!in% "SYMBOL"], `font-size` = '12px', 'text-align' = 'center' ) %>%
      
      ##### Colour cells according to the expression values quantiles in each group
      DT::formatStyle(columns = targets.list[1], 
                      backgroundColor = DT::styleInterval(brks.q[[targets.list[1]]], clrs.q[[targets.list[1]]])) %>%
      DT::formatStyle(columns = targets.list[2], 
                      backgroundColor = DT::styleInterval(brks.q[[targets.list[2]]], clrs.q[[targets.list[2]]])) %>%
      DT::formatStyle(columns = targets.list[3], 
                      backgroundColor = DT::styleInterval(brks.q[[targets.list[3]]], clrs.q[[targets.list[3]]])) %>%
      DT::formatStyle(columns = paste0("Patient vs ", cancer), 
                      backgroundColor = DT::styleInterval(brks.q[[paste0("Patient vs ", cancer)]], clrs.q[[paste0("Patient vs ", cancer)]]))
  }
  
  return( list(dt.table,  group.z) )
}

##### Generate table with drugs targeting selected set of genes using info from CIViC database (https://civicdb.org/)
civicDrugTable <- function(genes, civic_var_summaries, civic_clin_evid, evid_type = "Predictive", var_type = NULL) {
  
  ##### Initialize data frame to the about drug-target info from CIViC
  drug.info <- setNames(data.frame(matrix(ncol = 18, nrow = 0)), c("Gene", "Variant", "variant_types", "drugs", "nct_ids", "evidence_level", "evidence_type", "evidence_direction", "clinical_significance", "rating", "civic_actionability_score", "Disease", "phenotypes", "pubmed_id", "variant_origin", "representative_transcript", "representative_transcript2", "last_review_date"))
  
  evid_levels <- list("A" = "A: Validated association", "B" = "B: Clinical evidence", "C" = "C: Case study", "D" = "D: Preclinical evidence", "E" = "E: Inferential association")
  
  ##### Loop thourgh each gene and check if they are druggable
  for ( gene in genes) {
    
    ##### Get summary info about druggable genes
    if ( gene %in% civic_clin_evid$gene ) {
      
      ##### Extract info about all reported variants's clinical evidence for queried gene
      clin.evid.info <- civic_clin_evid[ civic_clin_evid$gene == gene , ]

      ##### Use more descriptive evidence level info
      for ( level in unique(clin.evid.info$evidence_level) ) {
        
        clin.evid.info$evidence_level[ clin.evid.info$evidence_level == level ] <- evid_levels[[ level ]]
      }
      
      ##### Subset table to include only variants with the evidence type of interest
      clin.evid.info <- clin.evid.info[ clin.evid.info$evidence_type == evid_type,  ]
        
      if ( nrow(clin.evid.info) > 0 ) {
        
        ##### Provide link to CIViC clinical evidence summary
        clin.evid.info$drugs <- paste0("<a href='", clin.evid.info$evidence_civic_url, "' target='_blank'>", clin.evid.info$drugs, "</a>")
        
        ##### Provide link to CIViC clinical evidence summary
        clin.evid.info$evidence_type <- paste0("<a href='", clin.evid.info$evidence_civic_url, "' target='_blank'>", clin.evid.info$evidence_type, "</a>")
        
        ##### Provide link to CIViC gene summary
        clin.evid.info$gene_civic_url <- paste0("<a href='", clin.evid.info$gene_civic_url, "' target='_blank'>", gene, "</a>")
        names(clin.evid.info)[ names(clin.evid.info) =="gene_civic_url" ] <- "Gene"
        
        ##### Provide link to CIViC variants summary
        clin.evid.info$variant_civic_url <- paste0("<a href='", clin.evid.info$variant_civic_url, "' target='_blank'>", clin.evid.info$variant, "</a>")
        names(clin.evid.info)[ names(clin.evid.info) =="variant_civic_url" ] <- "Variant"
        
        ##### Provide link to ClinicalTrials.gov variants summary based on NCT IDs
        for ( nct_id in clin.evid.info$nct_ids ) {
          
          if ( !is.empty(nct_id) ) {
            
            ##### Deal with multiple NCT IDs (separated by comma)
            nct_id_url <- gsub(" '" , "'", paste(gsub("/ " , "/", paste("<a href='https://clinicaltrials.gov/ct2/show/", unlist(strsplit(nct_id, split=",", fixed=TRUE)) , "' target='_blank'>", unlist(strsplit(nct_id, split=",", fixed=TRUE)), "</a>")), collapse = ", "))
            clin.evid.info$nct_ids[ clin.evid.info$nct_ids==nct_id ] <- nct_id_url
          }
        }
        
        ##### Provide link to PubMed variants summary
        clin.evid.info$pubmed_id <- paste0("<a href='https://www.ncbi.nlm.nih.gov/pubmed/", clin.evid.info$pubmed_id, "' target='_blank'>", clin.evid.info$pubmed_id, "</a>")
        
        ##### Provide link to Disease Ontology
        clin.evid.info$doid <- paste0("<a href='http://www.disease-ontology.org/?id=DOID:", clin.evid.info$doid, "' target='_blank'>", clin.evid.info$disease, "</a>")
        names(clin.evid.info)[ names(clin.evid.info) =="doid" ] <- "Disease"
        
        ##### Extract info about all variants it that gene
        var.info <- civic_var_summaries[ civic_var_summaries$gene == gene , ]
        var.info <- var.info[, c("variant", "variant_types", "civic_actionability_score")]
        var.info[,"variant_types"] <- gsub("_", " ", var.info[,"variant_types"])
        var.info[,"variant_types"] <- gsub(",", ", ", var.info[,"variant_types"])
        
        ##### Merge about all variants it that gene and clinical evidence info
        clin.evid.info <- merge(clin.evid.info, var.info, by = "variant", all.x = TRUE)
        
        ##### Filter drug matching info depending on the variant type
        var_type.keep <- NULL
        
        if ( !is.null(var_type) && var_type == "mutation" ) {
          
          ##### Remove entries containing "EXPRESSION", "AMPLIFICATION", "DELETION", "METHYLATION", "WILD TYPE", "FUSION", "COPY", "REARRANGEMENT", "PHOSPHORYLATION", "TRANSCRIPT", "GAIN", "LOSS"
          var_type.keep <- c(var_type.keep, grep( "EXPRESSION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "AMPLIFICATION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "DELETION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "METHYLATION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "WILD TYPE", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "FUSION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "REARRANGEMENT", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "PHOSPHORYLATION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "COPY", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "TRANSCRIPT", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "GAIN", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "LOSS", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          
          clin.evid.info <- clin.evid.info[ -c(unique(var_type.keep)), ]
          
        } else if ( !is.null(var_type) && var_type == "expression" ) {
          
          ##### Keep only entries containing "EXPRESSION", "FUSION", "TRANSCRIPT", "ALTERATION"
          var_type.keep <- c(var_type.keep, grep( "EXPRESSION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "FUSION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "TRANSCRIPT", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "ALTERATION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          
          clin.evid.info <- clin.evid.info[ c(unique(var_type.keep)), ]
          
        } else if ( !is.null(var_type) && var_type == "fusion" ) {
          
          ##### Keep only entries containing "FUSION", "ALTERATION", "[gene]-", "-[gene]"
          
          ##### Keep only entries containing "FUSION", "ALTERATION", "-"
          var_type.keep <- c(var_type.keep, grep( "FUSION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( paste0(gene, "-"), clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( paste0("-", gene), clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "ALTERATION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          
          clin.evid.info <- clin.evid.info[ c(unique(var_type.keep)), ]
          
        } else if ( !is.null(var_type) && var_type == "copy_gain" ) {
          
          ##### Keep only entries containing "AMPLIFICATION", "COPY", "GAIN", "ALTERATION"
          var_type.keep <- c(var_type.keep, grep( "AMPLIFICATION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "COPY", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "GAIN", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "ALTERATION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          
          clin.evid.info <- clin.evid.info[ c(unique(var_type.keep)), ]
          
        } else if ( !is.null(var_type) && var_type == "copy_loss" ) {
          
          ##### Keep only entries containing "DELETION", "COPY", "LOSS", "ALTERATION"
          var_type.keep <- c(var_type.keep, grep( "DELETION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "COPY", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "LOSS", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          var_type.keep <- c(var_type.keep, grep( "ALTERATION", clin.evid.info$variant, invert=FALSE, ignore.case=TRUE))
          
          clin.evid.info <- clin.evid.info[ c(unique(var_type.keep)), ]
        }
      }
      
      if ( nrow(clin.evid.info) > 0 ) {
        
        ##### Subset table to include only most important info
        clin.evid.info <- clin.evid.info[ , names(drug.info)]
        
        ##### Add drugs info for subsequent gene
        drug.info <- rbind(drug.info, clin.evid.info)
      }
    }
  }
  
  ##### Use more friendly column names for the table
  names(drug.info) <- c("Gene", "Variant", "Variant type", "Drugs", "Clinical trials", "Evidence level", "Evidence type", "Evidence direction", "Clinical significance", "Trust rating", "Actionability score", "Disease", "Phenotypes", "PubMed ID",  "Variant origin", "Representative transcript", "Representative transcript 2", "Review date")
  
  ##### Limit the info to fewer columns
  drug.info <- drug.info[ , c("Gene", "Variant", "Variant type", "Drugs", "Clinical trials", "Evidence level", "Evidence direction", "Clinical significance", "Trust rating", "Actionability score", "Disease", "Phenotypes", "PubMed ID",  "Representative transcript", "Representative transcript 2")] 
  
  ##### Generate a table
  dt.table <- DT::datatable( data = drug.info, filter = "none", rownames = FALSE, extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left; color:grey; font-size:100% ;'), escape = FALSE) %>%
    DT::formatStyle( columns = names(drug.info), `font-size` = '12px', 'text-align' = 'center' ) %>%
    
    ##### Colour cells according to evidence level and trust rating
    DT::formatStyle(columns = "Evidence level", 
                    backgroundColor = DT::styleEqual(c("A: Validated association", "B: Clinical evidence", "C: Case study", "D: Preclinical evidence", "E: Inferential association"), c("mediumseagreen", "deepskyblue", "mediumpurple", "darkorange", "coral")) )  %>%
    #DT::formatStyle(columns = "Trust rating", 
    #                backgroundColor = DT::styleEqual(c(1:5), c(rev(round(seq(0, 200, length.out = 5), 0) %>%  {paste0("rgb(", .,",200,", ., ")")}))) )
    DT::formatStyle(columns = "Trust rating", 
                    backgroundColor = DT::styleEqual(c(1:5), c("coral", "azure", "lightskyblue", "palegreen", "mediumseagreen")) )
  
  return( list(dt.table,  drug.info) )
}

##### Generate bezier curves-like plot representing gene fusion events
fusionsBezierPlot <- function(fusion_annot, genes_annot) {
  
  ##### Get the genes chromosomes...
  chr1 <- paste0("chr", fusion_annot$SEQNAME)
  chr2 <- paste0("chr", fusion_annot$SEQNAME.1)
  
  ##### ...positions
  pos1 <- fusion_annot$GENESEQSTART
  pos2 <- fusion_annot$GENESEQSTART.1
  
  ##### ... and the events type
  type <- paste( fusion_annot$reported_fusion, fusion_annot$fusions_abundant, fusion_annot$geneA_dna_support, fusion_annot$geneB_dna_support, sep = "-") 
  type <- gsub("Yes-Yes-Yes-Yes","Reported fusion, abundant and DNA-supported gene(s)", type)
  type <- gsub("Yes-Yes---Yes","Reported fusion, abundant and DNA-supported gene(s)", type)
  type <- gsub("Yes-Yes-Yes--","Reported fusion, abundant and DNA-supported gene(s)", type)
  type <- gsub("Yes-Yes----","Reported fusion and abundant gene(s)", type)
  type <- gsub("Yes---Yes-Yes","Reported fusion and DNA-supported gene(s)", type)
  type <- gsub("Yes---Yes--","Reported fusion and DNA-supported gene(s)", type)
  type <- gsub("Yes-----Yes","Reported fusion and DNA-supported gene(s)", type)
  type <- gsub("Yes------","Reported fusion", type)
  type <- gsub("--Yes-Yes-Yes","Abundant and DNA-supported gene(s)", type)
  type <- gsub("--Yes-Yes--","Abundant and DNA-supported gene(s)", type)
  type <- gsub("--Yes---Yes","Abundant and DNA-supported gene(s)", type)
  type <- gsub("--Yes----","Abundant gene(s)", type)
  type <- gsub("----Yes-Yes","DNA-supported gene(s)", type)
  type <- gsub("----Yes--","DNA-supported gene(s)", type)
  type <- gsub("------Yes","DNA-supported gene(s)", type)
  type <- gsub("-------","Other", type)

  #### Prepare x-axis coordinates info for ggplot
  ##### This part of the script converts the genomic positions from hg38 to coordinates that can be plotted on the ggplot x-axis.
  ##### Start with calculating the whole genome length. Here we consider chromosomes 1-22, X and Y
  genome.length <- sum(seqlengths(Hsapiens)[1:24])
  
  ##### Now calculate fake chromosomes' start positions so that they match with the x-axis coordinates in the ggplot
  chrs_fake_starts <- vector("list", 24)
  chrs_fake_starts  <- setNames(chrs_fake_starts,  names(Hsapiens)[1:24] )
  
  ##### Chromosome 1 has coordingate 0
  chrs_fake_starts[["chr1"]] <- 0
  
  ##### The coordinates for the remaining chromosomes will be calculated by adding the lengths of individual preceding chromosomes
  length_sum <- 0
  for ( i in 2:length(chrs_fake_starts) ) {
  	#cat(paste("\nThe fake start position for " , names(chrs_fake_starts)[i], " is ", length_sum + as.numeric(seqlengths(Hsapiens)[[i-1]]), sep=""))
  #	cat(paste("\nLength of " , names(chrs_fake_starts)[i-1], " = ", as.numeric(seqlengths(Hsapiens)[[i-1]]), " and the sum of the preceding chromosomes = ", length_sum, ".\n\n", sep=""))
  	length_sum <- length_sum + as.numeric(seqlengths(Hsapiens)[[i-1]])
  	chrs_fake_starts[[names(Hsapiens)[i]]] <- length_sum
  }
  
  ##### Calculate the coordinates for x-axis labels (chr1, chr2...) for ggplot by adding the half-lenght of each chrosomome to its fake start
  chrs_fake_label.pos <- vector("list", 24)
  chrs_fake_label.pos  <- setNames(chrs_fake_label.pos,  names(Hsapiens)[1:24] )
  for ( i in 1:length(chrs_fake_starts) ) {
  	chrs_fake_label.pos[[names(Hsapiens)[i]]] <- seqlengths(Hsapiens)[[i]]/2 + chrs_fake_starts[[names(Hsapiens)[i]]]
  	# cat(paste("\nThe x-axis coordinate for " , names(chrs_fake_starts)[i], " label is ", chrs_fake_label.pos[[names(Hsapiens)[i]]], " = ",  seqlengths(Hsapiens)[[i]]/2, " (half-length) + ", chrs_fake_starts[[names(Hsapiens)[i]]]," (fake start)", sep=""))
  }
  
  #### Calculate ggplot x-axis coordinates for fusion events
  ##### Calculate the coordinates to draw bezier curves by adding the fusion events position info to the fake start coordinates of corresponding chromosomes
  pos1_fake <- vector("list", nrow(fusion_annot))
  pos2_fake <- vector("list", nrow(fusion_annot))
  
  for ( i in 1:nrow(fusion_annot) ) {
  	# cat(paste("\nCalculations for fusion event: " , paste( chr1[i], pos1[i], sep=" " ), "-",  paste( chr2[i], pos2[i], sep=" " ), sep=""))
  	# cat(paste("\nThe x-axis coordinate for position 1 is ", chrs_fake_starts[[chr1[i]]] + pos1[i], " = ",  chrs_fake_starts[[chr1[i]]], " (the fake start of ", chr1[i],") + ", pos1[i], " (the real position 1)", sep=""))
  	# cat(paste("\nThe x-axis coordinate for position 2 is ", chrs_fake_starts[[chr2[i]]] + pos2[i], " = ",  chrs_fake_starts[[chr2[i]]], " (the fake start of ", chr2[i],") + ", pos2[i], " (the real position 2).\n", sep=""))
  	pos1_fake[[i]] <- chrs_fake_starts[[chr1[i]]] + pos1[i]
  	pos2_fake[[i]] <- chrs_fake_starts[[chr2[i]]] + pos2[i]
  }
  
  ##### Get random number for the bezier curves' heigths and caluclate the middle point for each bezier curve
  beziers.height <- runif(nrow(fusion_annot), 1, 2)
  beziers.mid <- unlist(pos1_fake)+(unlist(pos2_fake)-unlist(pos1_fake))/2
  
  ##### Create data-frame with beziers curves info
  beziers <- data.frame(
      x = c(rbind( unlist(pos1_fake), beziers.mid, unlist(pos2_fake) )),
      y = c(rbind( 0.2, beziers.height, 0.2 ) ),
      type = rep( paste( chr1, make.names(pos1, unique=TRUE), chr2, make.names(pos2, unique=TRUE), sep="_" ), each=3),
  		group = rep( type, each=3)
  )
  
  ##### Generate a bezier curves-like plot representing fusion events
  p <- ggplot() + geom_bezier(aes(x= x, y = y, group = type, color = group ), data = beziers, show.legend = TRUE, size = 0.2) +
  		##### Remove default axes labels and grey backgroud
  		theme(axis.title.x=element_blank(), axis.text.x= element_blank(), axis.ticks.x=element_blank(), axis.title.y=element_blank(), axis.text.y= element_blank(), axis.ticks.y=element_blank(),
  		##### ...and the grey backgroud
  					panel.background = element_rect(fill = NA),
  		##### ...change the legend parameters
  					legend.title=element_text(size=6), legend.text=element_text(size=10), legend.key.size = unit(1,"line"), legend.key= element_blank(), legend.position = c(0.8,0.65) ) +
  		##### Set the axes limits
  		scale_x_continuous(limits = c(1, genome.length)) +
  		scale_y_continuous(limits = c(0, 2)) +
  		##### Add chromosomes boundaries
  		geom_segment(aes(x = c(1,unlist(chrs_fake_starts)[2:24],genome.length) , xend = c(1,unlist(chrs_fake_starts)[2:24],genome.length), y = 0, yend = 0.2), colour = 'grey', size = 0.2) +
  		labs( color = "") +
  		##### Add chromosomes labels
  		annotate(geom = 'text', label = names(chrs_fake_label.pos), x = unlist(chrs_fake_label.pos), y = 0.1, size = 2, angle = 45)
      ##### Add gene fusion labels
      #annotate(geom = 'text', label = paste(fusion_annot$fusion_data.geneA.name, fusion_annot$fusion_data.geneB.name, sep="-"), x = beziers.mid, y = beziers.height-0.5, size = 1.5)
  
  return( p )
}

##### Code from UMCCRISE to prioritise SV events https://github.com/umccr/umccrise/blob/master/umccrise/rmd_files/index.Rmd
sv_prioritize <- function(sv_file) {

  col_types <- "ccciicccccc"
  sv_all = NULL
  
  if (length(readLines(con = sv_file, n = 2)) > 1) {
    sv_all <- readr::read_tsv(sv_file, col_names = TRUE, col_types = col_types) %>%
      tidyr::unnest(annotation = strsplit(annotation, ',')) %>% # Unpack multiple annotations per region
      tidyr::separate(annotation,
                      c('type', 'annotation', 'gene', 'transcript', 'priority', 'score'),
                      sep = '\\|', convert = TRUE) %>% # Unpack annotation columns %>%
      dplyr::mutate(SR = split_read_support, PR = paired_support_PR) %>%
      dplyr::select(chrom, start, end, gene, priority, score, annotation, type, lof, SR, PR) %>%
      dplyr::distinct() %>%
      dplyr::mutate(chrom = factor(chrom, levels = c(1:22, "X", "Y", "MT")))
  }

  return( sv_all )
}
```

```{r load_libraries, warning=FALSE}
##### Load libraries
suppressMessages(library(edgeR))
suppressMessages(library(preprocessCore))
suppressMessages(library(rapportools))
suppressMessages(library(edgeR))
suppressMessages(library(kableExtra))
suppressMessages(library(tidyverse))
suppressMessages(library(DataCombine))
suppressMessages(library(knitr))
suppressMessages(library(magick))
suppressMessages(library(matrixStats))
suppressMessages(library(ggplot2))
suppressMessages(library(ggforce))
suppressMessages(library(NOISeq))
suppressMessages(library(package=paste0("EnsDb.Hsapiens.v", params$ensembl_version), character.only = TRUE))
suppressMessages(library(package=paste0("BSgenome.Hsapiens.UCSC.hg", params$ucsc_genome_assembly), character.only = TRUE)) # required to get chromosomes lengts for fusionsBezierPlot function generating Bezier plot to present gene fusions in the genomics context
```

```{r load_ref_data, message=FALSE, warning=FALSE}
##### Load reference datasets
##### Define the reference datasets based on user-defined tissue of sample origin
ref_tissue <- list( "pancreas" = c(paste(params$ref_data_dir, "Datasets_list_PDAC.txt", sep="/"), "Normal (pancreas)", "PDAC"), "cervix" = c(paste(params$ref_data_dir, "Datasets_list_cervical_SCC.txt", sep="/"), "Normal (cervix uteri)", "Cervical squamous cell carcinoma") )

tissue <- params$tissue
normal_group <- ref_tissue[[tissue]][2]
cancer_group <- ref_tissue[[tissue]][3]

##### Create a list with reference datasets
ref_datasets <- c(tissue)
ref_datasets.list <- vector("list", length(ref_datasets))
names(ref_datasets.list) <- ref_datasets

##### Create a list with various sets of genes
ref_genes <- c("genes_cancer", "oncokb_genes", "genes_immune", "genes_hrd")
ref_genes.list <- vector("list", length(ref_genes))
names(ref_genes.list) <- ref_genes

##### Create a list with cancer genes annotations
caner_genes_annot <- c("oncokb_clin_vars", "oncokb_all_vars")
caner_genes_annot.list <- vector("list", length(caner_genes_annot))
names(caner_genes_annot.list) <- caner_genes_annot

##### Get patient data dir and sample file name
dataDir <- unlist(strsplit(params$count_file, split='/', fixed=TRUE))
sampleName <- gsub("-ready.counts", "", dataDir[length(dataDir)])
dataDir <- paste(dataDir[-c(length(dataDir))], collapse ="/")

##### Read in reference datasets and merge them with sample data. This part outputs a vector with first element containing the merged data and second element containing merged targets info
ref_datasets.list[[tissue]] <- combineDatasets(params$sample_name, params$count_file, ref_tissue[[tissue]][1])
names(ref_datasets.list[[tissue]]) <- c("combined_data", "sample_annot")

##### Read in selected genes list
ref_genes.list[["genes_cancer"]] <- read.table(paste(params$ref_data_dir, params$genes_cancer, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="")
ref_genes.list[["genes_oncokb"]] <- read.table(paste(params$ref_data_dir, params$oncokb_genes, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="", comment.char = "")
ref_genes.list[["genes_immune"]] <- read.table(paste(params$ref_data_dir, params$genes_immune, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="")
ref_genes.list[["genes_hrd"]] <- read.table(paste(params$ref_data_dir, params$genes_hrd, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="")

##### Read in gene fusion data for investigate sample
##### Read in the pizzly fusion calls
ref_genes.list[["pizzly"]] <- read.table(file = paste(dataDir, "pizzly", paste0(sampleName, "-flat.tsv"), sep = "/"), header = TRUE)

##### Read in the quantification file from kallisto
ref_genes.list[["kallisto"]] <- read.table(file = paste(dataDir, "kallisto/quant_pizzly_post/abundance.tsv", sep = "/"), header = TRUE)

##### Read in mutation data for investigate sample
##### Get the WGS data batch name
batch <- unlist(strsplit(params$batch, split='/', fixed=TRUE))
batch <- batch[length(batch)]
  
##### Check if PCGR (mutation) output file exists
pcgr_file <- paste(params$batch, "pcgr", paste0(batch, "-somatic.pcgr_acmg.grch37.snvs_indels.tiers.tsv"), sep = "/")
runPcgrChunk <- TRUE

if ( file.exists(pcgr_file) ) {
  
  ref_genes.list[["pcgr"]] <- read.table(pcgr_file, sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, fill = TRUE)
  
  ##### Simplify the variants types
  ref_genes.list[["pcgr"]]$CONSEQUENCE <- gsub("_variant", "", ref_genes.list[["pcgr"]]$CONSEQUENCE)
  ref_genes.list[["pcgr"]]$CONSEQUENCE <- gsub("_", " ", ref_genes.list[["pcgr"]]$CONSEQUENCE)
  
  ##### Simplify tiers' annotations and AFs
  ref_genes.list[["pcgr"]]$TIER <- gsub("TIER ", "", ref_genes.list[["pcgr"]]$TIER)
  
  ref_genes.list[["pcgr"]]$AF_TUMOR <- round(ref_genes.list[["pcgr"]]$AF_TUMOR, digits = 2)
  ref_genes.list[["pcgr"]]$AF_NORMAL <- round(ref_genes.list[["pcgr"]]$AF_NORMAL, digits = 2)
  
} else {
  
  ref_genes.list[["pcgr"]] <- NULL
  runPcgrChunk <- FALSE
}

##### Check if purple (CN) output file exists
purple_file <- paste(params$batch, "purple", paste0(batch, ".purple.gene.cnv"), sep = "/")
runPurpleChunk <- TRUE

if ( file.exists(purple_file) ) {
  
  ref_genes.list[["purple"]] <- read.table(purple_file, sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, fill = TRUE)
  
} else {
  
  ref_genes.list[["purple"]] <- NULL
  runPurpleChunk <- FALSE
}

##### Check if manta (structural variants (SVs)) file exists
sv_file <- paste(params$batch, "structural", paste0(batch, "-sv-prioritize-manta-pass.tsv"), sep = "/")
runSVsChunk <- TRUE

if ( file.exists(sv_file) ) {
  
  ref_genes.list[["manta"]] <- sv_prioritize(sv_file)
  
} else {
  
  ref_genes.list[["manta"]] <- NULL
  runSVsChunk <- FALSE
}

##### Read in OncoKB (http://oncokb.org) annotations
caner_genes_annot.list[["oncokb_clin_vars"]] <- read.table(paste(params$ref_data_dir, params$oncokb_clin_vars, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="")
caner_genes_annot.list[["oncokb_all_vars"]] <- read.table(paste(params$ref_data_dir, params$oncokb_all_vars, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="", fill = TRUE)

##### Read in CIViC (https://civicdb.org/) annotations
caner_genes_annot.list[["civic_var_summaries"]] <- read.table(paste(params$ref_data_dir, params$civic_var_summaries, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="", fill = TRUE)
caner_genes_annot.list[["civic_clin_evid"]] <- read.table(paste(params$ref_data_dir, params$civic_clin_evid, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="", fill = TRUE)

##### Read in Cancer Biomarkers database (https://www.cancergenomeinterpreter.org/biomarkers) annotations. This is mainly used to annotate reported fusion events
caner_genes_annot.list[["cancer_biomarkers_trans"]] <- read.table(paste(params$ref_data_dir, params$cancer_biomarkers_trans, sep="/"), sep="\t", as.is=TRUE, header=TRUE, row.names=NULL, quote="", fill = TRUE)

##### Read in FusionGDB database (https://ccsm.uth.edu/FusionGDB/) used to annotate reported fusion events, with info about head and tail genes.
caner_genes_annot.list[["FusionGDB"]] <- read.table(paste(params$ref_data_dir, params$FusionGDB, sep="/"), sep="\t", as.is=TRUE, header=FALSE, row.names=NULL, quote="", fill = TRUE)
names(caner_genes_annot.list[["FusionGDB"]]) <- c("Hgene", "HgeneID", "Tgene", "TgeneID", "FGname", "FGID")
```

```{r data_transformation, comment = NA, message=FALSE, warning=FALSE}
##### Data transformation and filtering
##### For differential expression and related analyses, gene expression is rarely considered at the level of raw counts since libraries sequenced at a greater depth will result in higher counts. Rather, it is common practice to transform raw counts onto a scale that accounts for such library size differences. Here we convert the read count data into log2-counts per million (***log-CPM***) using function from *[edgeR](https://bioconductor.org/packages/release/bioc/html/edgeR.html){target="_blank"}* package. Genes with very low counts across all libraries provide little evidence for differential expression. In the biological point of view, a gene must be expressed at some minimal level before it is likely to be translated into a protein or to be biologically important. In addition, the pronounced discretenes of these counts interferes with some of the statistical approximations that are used later in the pipeline. These genes should be filtered out prior to further analysis.

##### Loop through combined datasets
for ( tissue in names(ref_datasets.list) ) {
  
  counts <- ref_datasets.list[[tissue]][["combined_data"]]
  target <- ref_datasets.list[[tissue]][["sample_annot"]]
  
  ##### Create EdgeR DGEList object
  y <- DGEList(counts=counts,  group=target$Target)
  
  ##### Add datasets name for each sample
  y$samples$dataset <- target$Dataset
  
  ##### Filtering to remove low expressed genes. Users should filter with CPM rather than filtering on the counts directly, as the latter does not account for differences in library sizes between samples. Here we keep only genes that have CPM of 1
  keep <- rowSums(cpm(y)>1) >= ncol(counts)/10
  y.filtered <- y[keep, , keep.lib.sizes=FALSE]
  
  ref_datasets.list[[tissue]][["combined_data_processed"]] <- y.filtered
}

# cat("The CPM of 1 (cut-off for removing low expressed genes) corresponds to", round(min(as.numeric(colSums(counts)*1e-6)), digits=0), "reads in sample with the lowest sequencing depth, and", round(max(as.numeric(colSums(counts)*1e-6)), digits=0), "reads in sample with the greatest sequencing depth\n")
```

```{r data_normalisation, comment = NA, message=FALSE, warning=FALSE}
##### Data normalisation
##### During the sample preparation or sequencing process, external factors that are not of biological interest can affect the expression of individual samples. For example, samples processed in the first batch of an experiment can have higher expression overall when compared to samples processed in a second batch. It is assumed that all samples should have a similar range and distribution of expression values. Normalisation for sample-specific effectss is required to ensure that the expression distributions of each sample are similar across the entire experiment. Normalisation by the method of *[trimmed mean of M-values](https://www.ncbi.nlm.nih.gov/pubmed/20196867){target="_blank"} (TMM)* is performed using the *calcNormFactors* function in *[edgeR](https://bioconductor.org/packages/release/bioc/html/edgeR.html){target="_blank"}*. The normalisation factors calculated here are used as a scaling factor for the library sizes. TMM is the recommended for most RNA-Seq data where the majority (more than half) of the genes are believed not differentially expressed between any pair of the samples.

##### Adjust for RNA composition effect. Calculate scaling factors for the library sizes with calcNormFactors function using trimmed mean of M-values (TMM) between each pair of samples. Note, that the raw read counts are used to calculate the normalisation factors

##### Loop through combined datasets
for ( tissue in names(ref_datasets.list) ) {
  
  y.filtered <- ref_datasets.list[[tissue]][[3]]
  
  y.filtered.norm <- calcNormFactors(y.filtered, method = "TMM")
  
  ##### Transformations from the raw-scale to CPM
  y.filtered.norm.cpm <- cpm(y.filtered.norm, normalized.lib.sizes=TRUE, log=TRUE, prior.count=0.25)
  
  ref_datasets.list[[tissue]][["combined_data_processed"]] <- y.filtered.norm.cpm
}
```

```{r pca, comment = NA, message=FALSE, warning=FALSE}
##### Principal component analysis (PCA)
##### Loop through combined datasets and perform PCA
for ( tissue in names(ref_datasets.list) ) {
  
  target <- ref_datasets.list[[tissue]][["sample_annot"]]
  data <- ref_datasets.list[[tissue]][["combined_data_processed"]]
  
  ref_datasets.list[[tissue]][["pca"]] <- pca(data, target)
}
```

```{r gene_annot_count_data, comment = NA, message=FALSE, warning=FALSE}
##### Loop through combined, BUT NOT PROCESSED, datasets and annotate ALL genes. This part is mainly required for biotype detection step
for ( tissue in names(ref_datasets.list) ) {
  
  ##### Convert data into a data frame to make the Ensembl ID and gene symbol matches (with merge function)
  data <- ref_datasets.list[[tissue]][["combined_data"]]
  data.df <- as.data.frame(cbind(rownames(data), data))
  colnames(data.df)[1] <- "ENSEMBL"

  ##### Get genes annotation and genomic locations (Use Ensembl annotation version 86 (Oct 2016), the most recent as of Oct 2018)
  edb <- EnsDb.Hsapiens.v86
  
  ##### Get keytypes for gene SYMBOL
  keys <- keys(edb, keytype="GENEID")
  
  ##### Get genes genomic coordiantes
  gene_info <- ensembldb::select(edb, keys=keys, columns=c("GENEID", "GENEBIOTYPE", "GENENAME", "SEQNAME", "GENESEQSTART", "GENESEQEND"), keytype="GENEID")
  names(gene_info) <- gsub("GENEID", "ENSEMBL", names(gene_info))
  names(gene_info) <- gsub("GENENAME", "SYMBOL", names(gene_info))
  
  ##### Limit genes annotation to those genes for which sample expression measurments are available
  gene_info <-  gene_info[ gene_info$ENSEMBL %in% data.df$ENSEMBL,  ]
  
  ##### Remove rows with duplicated ENSEMBL IDs
  gene_info = gene_info[!duplicated(gene_info$ENSEMBL),]
  rownames(gene_info) <- gene_info$ENSEMBL
  
  ##### Remove rows with duplicated gene symbols (Y_RNAs, SNORs, LINC0s etc)
  gene_info = gene_info[!duplicated(gene_info$SYMBOL),]
  
  ##### Add info about immune response markers
  gene_info <- merge(gene_info, ref_genes.list[["genes_immune"]], by = "SYMBOL", all.x = TRUE)
  
  ##### Keep only immune response marjers for which there is available annotation
  ref_genes.list[["genes_immune"]] <- ref_genes.list[["genes_immune"]][ ref_genes.list[["genes_immune"]]$SYMBOL %in% gene_info$SYMBOL, ]
  
  ##### Merge genes genomic coordinates info with their annotation and expression data
  data.annot <- merge(gene_info, data.df, by = "ENSEMBL", all.x = FALSE)
  rownames(data.annot) <- data.annot$ENSEMBL
  
  ##### Get data matrix with gene symbols
  ref_datasets.list[[tissue]][["gene_annot_all"]] <- data.annot[, c("SYMBOL", "GENEBIOTYPE", "ENSEMBL", "SEQNAME", "GENESEQSTART", "GENESEQEND", "Immune_Cycle_Role")]
}
```

```{r gene_annot_processed_data, comment = NA, message=FALSE, warning=FALSE}
##### Loop through combined datasets and annotate genes
for ( tissue in names(ref_datasets.list) ) {
  
  ##### Convert data into a data frame to make the Ensembl ID and gene symbol matches (with merge function)
  data <- ref_datasets.list[[tissue]][["combined_data_processed"]]
  data.df <- as.data.frame(cbind(rownames(data), data))
  colnames(data.df)[1] <- "ENSEMBL"
  
  ##### Merge genes genomic coordinates info with their annotation and expression data
  data.annot <- merge(gene_info, data.df, by = "ENSEMBL", all.x = FALSE)
  
  ##### Keep only genes fo which gene symbol is available
  data.annot <- data.annot[!(is.na(data.annot$SYMBOL) | data.annot$SYMBOL==""), ]
  rownames(data.annot) <- data.annot$SYMBOL
  
  ##### Get data matrix with gene symbols
  #data <- data.annot[, colnames(data)]
  #data <- apply(data.annot[, colnames(data)], 2, as.numeric)
  #rownames(data) <- data.annot$SYMBOL
  ref_datasets.list[[tissue]][["combined_data_processed"]] <- apply(data.annot[, colnames(data)], 2, as.numeric)
  rownames(ref_datasets.list[[tissue]][["combined_data_processed"]]) <- data.annot$SYMBOL
  ref_datasets.list[[tissue]][["gene_annot"]] <- data.annot[, c("SYMBOL", "GENEBIOTYPE", "ENSEMBL", "SEQNAME", "GENESEQSTART", "GENESEQEND", "Immune_Cycle_Role")]
  
  ##### Save the combined expression matrix, genes list and associated targets into txt files
  write.table(prepare2write(ref_datasets.list[[tissue]][["combined_data_processed"]]), file = paste0(params$report_dir, "/", params$sample_name,".combined_data_processed.txt"), sep="\t", quote=FALSE, row.names=FALSE, col.names=TRUE, append = FALSE )
  write.table(prepare2write(rownames(ref_datasets.list[[tissue]][["combined_data_processed"]])), file = paste0(params$report_dir, "/", params$sample_name,".combined_data_processed.genes.txt"), sep="\t", quote=FALSE, row.names=FALSE, col.names=TRUE, append = FALSE )
  write.table(prepare2write(ref_datasets.list[[tissue]][["sample_annot"]]), file = paste0(params$report_dir, "/", params$sample_name,".sample_annot.txt"), sep="\t", quote=FALSE, row.names=FALSE, col.names=TRUE, append = FALSE )
}
```

```{r cancer_genes_prep, comment = NA, message=FALSE, warning=FALSE}
##### Combine UMCCR cancer gene list with OncoKB cancer genes
genes_cancer <- ref_genes.list[["genes_oncokb"]]
genes_cancer$UMCCR <- rep("No", nrow(genes_cancer))
genes_cancer$Oncogene <- rep("-", nrow(genes_cancer))
genes_cancer$TSG <- rep("-", nrow(genes_cancer))
genes_cancer$Fusion <- rep("-", nrow(genes_cancer))
genes_cancer$Germline <- rep("-", nrow(genes_cancer))

##### Flag Oncogenes, TSGs and fusion genes in the UMCCR cancer genes list
ref_genes.list[["genes_cancer"]]$germ <- gsub("TRUE", "Yes", ref_genes.list[["genes_cancer"]]$germ)
ref_genes.list[["genes_cancer"]]$germ <- gsub("FALSE", "-", ref_genes.list[["genes_cancer"]]$germ)
ref_genes.list[["genes_cancer"]]$fusion <- gsub("TRUE", "Yes", ref_genes.list[["genes_cancer"]]$fusion)
ref_genes.list[["genes_cancer"]]$fusion <- gsub("FALSE", "-", ref_genes.list[["genes_cancer"]]$fusion)
ref_genes.list[["genes_cancer"]]$tumorsuppressor <- gsub("TRUE", "Yes", ref_genes.list[["genes_cancer"]]$tumorsuppressor)
ref_genes.list[["genes_cancer"]]$tumorsuppressor <- gsub("FALSE", "-", ref_genes.list[["genes_cancer"]]$tumorsuppressor)
ref_genes.list[["genes_cancer"]]$oncogene <- gsub("TRUE", "Yes", ref_genes.list[["genes_cancer"]]$oncogene)
ref_genes.list[["genes_cancer"]]$oncogene <- gsub("FALSE", "-", ref_genes.list[["genes_cancer"]]$oncogene)

for ( gene in unlist(ref_genes.list[["genes_cancer"]]$symbol ) ) {

  ##### Check if the UMCCR genes is already reported in OncoKB
  if ( gene %in% genes_cancer$Hugo.Symbol ) {
   
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$UMCCR <- "Yes"
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$Oncogene <- ref_genes.list[["genes_cancer"]]$oncogene[ref_genes.list[[ "genes_cancer"]]$symbol==gene]
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$TSG <- ref_genes.list[["genes_cancer"]]$tumorsuppressor[ref_genes.list[[ "genes_cancer"]]$symbol==gene]
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$Fusion <- ref_genes.list[["genes_cancer"]]$fusion[ref_genes.list[[ "genes_cancer"]]$symbol==gene]
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$Germline <- ref_genes.list[["genes_cancer"]]$germ[ref_genes.list[[ "genes_cancer"]]$symbol==gene]
    
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, 2] <- as.numeric(genes_cancer[ genes_cancer$Hugo.Symbol==gene, 2]) + 1
    
  ##### Add if not present
  } else {
    
    genes_cancer <- rbind(genes_cancer, c(gene, 1, "No", rep("", 8), "Yes"))
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$Oncogene <- ref_genes.list[["genes_cancer"]]$oncogene[ref_genes.list[[ "genes_cancer"]]$symbol==gene]
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$TSG <- ref_genes.list[["genes_cancer"]]$tumorsuppressor[ref_genes.list[[ "genes_cancer"]]$symbol==gene]
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$Fusion <- ref_genes.list[["genes_cancer"]]$fusion[ref_genes.list[[ "genes_cancer"]]$symbol==gene]
    genes_cancer[ genes_cancer$Hugo.Symbol==gene, ]$Germline <- ref_genes.list[["genes_cancer"]]$germ[ref_genes.list[[ "genes_cancer"]]$symbol==gene]
  }
}

##### Make the data frame to look nicer
rownames(genes_cancer) <- genes_cancer$Hugo.Symbol
names(genes_cancer) <- c("Gene", "Resources no.", "OncoKB", "Oncogene (OncoKB)", "TSG (OncoKB)", "MSK-IMPACT", "MSK-HEME", "Foundation One", "Foundation One Heme", "Vogelstein", "Sanger CGC", "UMCCR", "Oncogene", "TSG", "Fusion", "Germline")
genes_cancer <- genes_cancer[,c("Oncogene", "TSG", "Fusion", "Germline", "Resources no.", "UMCCR", "OncoKB", "MSK-IMPACT", "MSK-HEME", "Foundation One", "Foundation One Heme", "Vogelstein", "Sanger CGC")]
genes_cancer[ genes_cancer=="No" ] <- "-"
genes_cancer[ genes_cancer=="" ] <- "-"

ref_genes.list[["genes_cancer"]] <- genes_cancer
ref_genes.list[["genes_oncokb"]] <- genes_cancer[ rownames(genes_cancer) %in% ref_genes.list[["genes_oncokb"]]$Hugo.Symbol, ]
```

```{r gene_annot_processed_data_save, comment = NA, message=FALSE, warning=FALSE}
##### Save the entire expression data with cancer genes annotaiton as a data table html file
##### Generate expression summary table for mutated genes
if ( params$plots_mode == "interactive" ) {
    
  targets <- ref_datasets.list[[tissue]][["sample_annot"]]
  data <- apply(data.annot[ , names(data.annot) %!in% c(names(ref_datasets.list[[tissue]][["gene_annot"]])) ], 2, as.numeric)
  rownames(data) <- ref_datasets.list[[tissue]][["gene_annot"]]$SYMBOL
    
  genes.expr.z <- exprTable( genes = rownames(data), data = data, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]], ext_links = TRUE, type = "z")
  
  genes.expr.perc <- exprTable( genes = rownames(data), data = data, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]], ext_links = TRUE, type = "perc")
  
  ##### Create directory for saving tables
  exprTableDir <- paste(params$report_dir, "exprTables", sep = "/")
  
  if ( !file.exists(exprTableDir) ) {
  
          dir.create(exprTableDir, recursive=TRUE)
  }
  
  ##### Save the expression tables as html file
  DT::saveWidget(widget=genes.expr.z[[1]], file=paste(exprTableDir, "genes.expr.z.html", sep = "/"), selfcontained=TRUE)
  DT::saveWidget(widget=genes.expr.perc[[1]], file=paste(exprTableDir, "genes.expr.perc.html", sep = "/"), selfcontained=TRUE)
}
```

```{r mut_cn_expr_data_prep, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Combine expression data with mutation and CN data if available
cn_data <- ref_genes.list[["purple"]]
expr_data <- ref_datasets.list[[tissue]][["combined_data_processed"]]
targets <- ref_datasets.list[[tissue]][["sample_annot"]]

##### Get the Patient vs [cancer] Z-scores using exprTable funstion
expr_data <- exprTable( genes = rownames(expr_data), data = expr_data, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, type = "z")[[2]]

expr_data.z <- expr_data[, paste0( "Patient vs ", cancer_group)]
names(expr_data.z) <- rownames(expr_data)

##### Extract partient sample data
#expr_data <- expr_data[, ncol(expr_data)]
  
##### Perform Z-score transformation of the expression values
#expr_data.z <- as.vector(scale(expr_data))
#names(expr_data.z) <- names(expr_data)
    
##### Remove entries with missing gene symbol (mainly variants in intergenic regions)
cn_data <- cn_data[ cn_data$Gene %!in% "", ]

##### Keep only genes with available expression data
cn_data <- cn_data[ cn_data$Gene %in% names(expr_data.z), ]

##### Calculate the mean CN for each gene
cn_data$MeanCopyNumber <- rowMeans(cbind(cn_data$MinCopyNumber, cn_data$MaxCopyNumber))
  
##### Deal with negative CN values
cn_data$MeanCopyNumber[ cn_data$MeanCopyNumber < 0 ] <- 0
  
##### Get the percentiles from from the CN values
#cn_data.percent <- quantile(cn_data$MeanCopyNumber, probs = seq(0, 1, .05), na.rm = TRUE)
  
# ##### Draw histogram of CN data
# p <- plot_ly(x = cn_data$MeanCopyNumber, type = 'histogram', name = "Copy-number data", width = 800, height = 500) %>%
#   
#   ##### Add 10th percentile threshold
#   add_lines(y = seq(0,1000, 100), x = rep(cn_data.percent[2],11), 
#               line = list(color = "black", dash = "dash"), opacity = 0.4,
#               name = "10th percentile", showlegend = TRUE) %>%
#   
#   ##### Add 50th percentile
#   add_lines(y = seq(0,1000, 100), x = rep(cn_data.percent[11],11), 
#               line = list(color = "black", dash = "dash"), opacity = 0.7,
#               name = "50th percentile", showlegend = TRUE) %>%
#   
#   ##### Add 90th percentile threshold
#   add_lines(y = seq(0,1000, 100), x = rep(cn_data.percent[20],11), 
#               line = list(color = "black", dash = "dash"), opacity = 1,
#               name = "80th percentile", showlegend = TRUE) %>%
#   
#   layout(xaxis = list( range=c(0,3), title = "Copy-number values"), yaxis = list( title = "Frequency"), margin = list(l=50, r=50, b=50, t=50, pad=4), autosize = F)
  
##### Keep only altered genes with CN values below 10th percentile and above 90th percentile
#cn_data <- cn_data[ cn_data$MaxCopyNumber < cn_data.percent[2] | cn_data$MinCopyNumber > cn_data.percent[20], ]

##### Keep only altered genes with CN values below loss threshold (default CN value = 1) and above gain threshold (default CN value = 4)
cn_data <- cn_data[ cn_data$MeanCopyNumber < params$cn_loss | cn_data$MeanCopyNumber > params$cn_gain, ]
  
##### Add mutation data if available
if ( !is.null(ref_genes.list[["pcgr"]]) ) {

  mut_data <- ref_genes.list[["pcgr"]]
    ##### Remove entries with missing gene symbol (mainly variants in intergenic regions)
  mut_data <- mut_data[ mut_data$SYMBOL %!in% "", ]

  ##### Prepare mutation data to include multiple mutations per gene
  ##### Initiate variable for the gene mutation status for each gene
  gene.mut <- as.matrix(rep("not mutated", length(expr_data.z)))
  colnames(gene.mut) <- "Mutation"
  rownames(gene.mut) <- names(expr_data.z)

  for ( i in 1:nrow(gene.mut) ) {
  
    ##### Check if any mutations are reported for each gene
    if (  rownames(gene.mut)[i] %in% mut_data$SYMBOL ) {
    
      ##### Deal with multiple mutations per gene
      if ( length(mut_data[ mut_data$SYMBOL %in% rownames(gene.mut)[i],  ]$CONSEQUENCE) > 1 ) {

        gene.mut[ rownames(gene.mut)[i],"Mutation" ] <- "multiple hits"

      } else {
      
        gene.mut[ rownames(gene.mut)[i],"Mutation" ] <- mut_data[ mut_data$SYMBOL %in% rownames(gene.mut)[i],  ]$CONSEQUENCE
      }
    }
  }

  ##### If there is no expression value for a specific gene than assume it's not expressed at all and assign the lowest value observed in that sample
  for ( gene in unique(mut_data$SYMBOL) ) {
  
    if ( gene %!in% rownames(gene.mut) ) {
        
      expr_data.z <- c(expr_data.z, min(expr_data.z))
      names(expr_data.z)[length(expr_data.z)] <- gene
    
      ##### Deal with multiple mutations per gene
      if ( length(mut_data[ mut_data$SYMBOL %in% gene,  ]$CONSEQUENCE) > 1 ) {

        gene.mut <- rbind( gene.mut,  "multiple hits")

      } else {
      
        gene.mut <- rbind( gene.mut,  mut_data[ mut_data$SYMBOL %in% gene,  ]$CONSEQUENCE )
      }
      rownames(gene.mut)[nrow(gene.mut)] <- gene
    }
  }

  ##### Subset expression, mutation and copy-number data to include only overlapping genes
  genes.intersect <- intersect(intersect(rownames(gene.mut), cn_data$Gene), names(expr_data.z))
  
  gene.mut.sub <- gene.mut[ rownames(gene.mut) %in% genes.intersect, ]
  cn_data.sub <- cn_data[ cn_data$Gene %in% genes.intersect, ]
  expr_data.z.sub <- expr_data.z[ names(expr_data.z) %in% genes.intersect ]
  
  ##### Make sure thay are all in the same order
  gene.mut.sub <- gene.mut.sub[ genes.intersect ]
  rownames(cn_data.sub) <- cn_data.sub$Gene
  cn_data.sub <- cn_data.sub[ genes.intersect,  ]
  expr_data.z.sub <- expr_data.z.sub[ genes.intersect  ]
  
  ##### Prepare data frame
  ref_datasets.list[[tissue]][["expr_mut_cn_data"]] <- data.frame(names(expr_data.z.sub), cn_data.sub$MeanCopyNumber, expr_data.z.sub, gene.mut.sub)
  colnames(ref_datasets.list[[tissue]][["expr_mut_cn_data"]]) <- c("Gene", "CN", "Z_score_diff", "Mutation")
  
} else {
  
  ##### Skip the step for processing mutation info and deal with expression and copy-number data
  ##### Subset expression and copy-number data to include only overlapping genes
  genes.intersect <- intersect(cn_data$Gene, names(expr_data.z))
  
  cn_data.sub <- cn_data[ cn_data$Gene %in% genes.intersect, ]
  expr_data.z.sub <- expr_data.z[ names(expr_data.z) %in% genes.intersect ]
  
  ##### Make sure thay are all in the same order
  rownames(cn_data.sub) <- cn_data.sub$Gene
  cn_data.sub <- cn_data.sub[ genes.intersect,  ]
  expr_data.z.sub <- expr_data.z.sub[ genes.intersect  ]
  
  ##### Prepare data frame
  ref_datasets.list[[tissue]][["expr_mut_cn_data"]] <- data.frame(names(expr_data.z.sub), cn_data.sub$MeanCopyNumber, expr_data.z.sub)
  colnames(ref_datasets.list[[tissue]][["expr_mut_cn_data"]]) <- c("Gene", "CN", "Z_score_diff")
}
```

```{r pizzly_filtering, comment = NA, message=FALSE, warning=FALSE}
#read in the pizzly fusion calls
pizzly.fusions <- ref_genes.list[["pizzly"]]
quant <- ref_genes.list[["kallisto"]]
#sort and filter quantification file on tpm values. First, grep only the transcript ids for fusion genes from quantification #file. Currently filtering on quantiles. Selected 0.997 because that reduces the #final fusion calls to the value we are #interested in (~15)
quant.fusions.only.transcripts <- quant[grep(":", quant$target_id), ]
quant.sorted.filtered <- dplyr::filter(arrange(quant.fusions.only.transcripts, desc(quant.fusions.only.transcripts$tpm)), tpm >= (quantile(quant.fusions.only.transcripts$tpm, 0.9)))

#initialize an empty dataframe
result <- data.frame()

#let's try using for loop for iterating over pizzly.fusions dataframe and get transcriptID and fusion gene pair information.
#can also filter quant.sorted.filtered$target_id to have only fusion gene target ids (that is two transcripts instead of one-
#this will increase speed

for (row in 1:nrow(pizzly.fusions)){
  y <- strsplit(as.character(pizzly.fusions[row, "transcripts.list"]), "\\;")
  y <- unname(y)
  for (i in 1:length(y[[1]])){
    if (y[[1]][i] %in% quant.sorted.filtered$target_id){
      #creating a new dataframe for the filtered pizzly results
      result <- rbind(result, data.frame(pizzly.fusions[row,]))
    }
  }
}

#remove duplicated values from result filtered using expression count (as multiple transcripts might support fusion between same gene) and sort the results by number of events (first by split count and then paircount)
deduped.result <- unique(result)
idx <- order(deduped.result$splitcount, deduped.result$paircount, decreasing = TRUE)
deduped.result <- deduped.result[idx, ]

#Extract only those fusion genes that are in cancer genes list
result.cancer_genes <- data.frame()
for (row in 1:nrow(pizzly.fusions)){
  if(pizzly.fusions[row,"geneA.name"] %in% rownames(ref_genes.list[["genes_cancer"]]) | pizzly.fusions[row,"geneB.name"] %in% rownames(ref_genes.list[["genes_cancer"]])) {
    #creating a new dataframe for extracting pizzly rows with cancer gene hits
    result.cancer_genes <- rbind(result.cancer_genes, data.frame(pizzly.fusions[row,]))
  }
}

##### Ordering pizzly's cancer genes results on the basis of read count values
##### Skip ordering if no of the fusion genes is a cancer gene
if ( nrow(result.cancer_genes) > 0 ) {
  
  idx2 <- order(result.cancer_genes$splitcount, result.cancer_genes$paircount, decreasing = TRUE)
  result.cancer_genes <- result.cancer_genes[idx2,]
}

#extracting rows from pizzly results that are not in re-quant i.e. deduped.result or cancer genes list i.e. result.cancer_genes
result.other_genes <- pizzly.fusions[ rownames(pizzly.fusions) %!in% c(rownames(result.cancer_genes), rownames(deduped.result)), ]

##### Ordering pizzly's other genes results on the basis of read count values
##### Skip ordering if no of the fusion genes is a cancer gene
if ( nrow(result.other_genes) > 0 ) {
  idx3 <- order(result.other_genes$splitcount, result.other_genes$paircount, decreasing = TRUE)
  result.other_genes <- result.other_genes[idx3,]
}

#combing all the three above sorted dataframes
pizzly.fusions <- rbind(deduped.result, result.cancer_genes, result.other_genes)

##### Flag known fusions based on info from Cancer Biomarkers database (CGI) (https://www.cancergenomeinterpreter.org/biomarkers)
known_translocations.CGI <- caner_genes_annot.list[["cancer_biomarkers_trans"]]
known_translocations.CGI$cancer_acronym <- gsub(";", ", ", known_translocations.CGI$cancer_acronym)
known_translocations.CGI$source <- gsub(";", ", ", known_translocations.CGI$source)
known_translocations.CGI$translocation <- gsub("__", "_", known_translocations.CGI$translocation)

##### Flag known fusions based on info from FusionGDB (https://ccsm.uth.edu/FusionGDB)
known_translocations.FusionGDB <- caner_genes_annot.list[["FusionGDB"]]

##### Merge info from both resources
known_translocations <- merge(known_translocations.FusionGDB, known_translocations.CGI, by.x = "FGname", by.y = "translocation", all = TRUE, sort=FALSE)

##### Extract gene pairs involved in reported gene fusions
trans.pairs <- as.data.frame(cbind( known_translocations$FGname, known_translocations$FGname ))
names(trans.pairs) <- c("geneA", "geneB")
trans.pairs$geneA <- sub("_.*", "", trans.pairs$geneA)
trans.pairs$geneB <- sub(".*_", "", trans.pairs$geneB)
known_translocations <- cbind(known_translocations, trans.pairs)
trans.pairs <- apply( trans.pairs , 1 , paste , collapse = "-" )

##### Add columns for info about reported fusions
pizzly.fusions <- cbind(pizzly.fusions, data.frame(matrix("", ncol = 5, nrow = nrow(pizzly.fusions)), stringsAsFactors = FALSE))
colnames(pizzly.fusions)[-c(1:7)] <- c("FGID", "reported_fusion", "reported_fusion_geneA", "reported_fusion_geneB", "effector_gene")

##### Add annotations about known fusion events
##### Loop through all genes involved in deteced gene fusions (pizzly results) and check which are already reported
for ( i in 1:nrow(pizzly.fusions) ) {
  
  geneA <- as.character(pizzly.fusions$geneA.name[i])
  geneB <- as.character(pizzly.fusions$geneB.name[i])
        
  ##### First check if the exact reported gene pairs were detected by pizzly
  if ( paste(geneA, geneB, sep="-") %in% trans.pairs ) {
    
    ##### provide fusion URL to FusionGDB
    pizzly.fusions$reported_fusion[i] <- "Yes"
    
    ##### provide fusion ID from FusionGDB
    pizzly.fusions$FGID[i] <- known_translocations$FGID[ trans.pairs %in% paste(geneA, geneB, sep="-")  ]
    
    pizzly.fusions$reported_fusion_geneA[i] <- "Yes"
    pizzly.fusions$reported_fusion_geneB[i] <- "Yes"
    
 } else if ( paste(geneB, geneA, sep="-") %in% trans.pairs ) {
    
    ##### provide fusion URL to FusionGDB
    pizzly.fusions$reported_fusion[i] <- "Yes"
    
    ##### provide fusion ID from FusionGDB
    pizzly.fusions$FGID[i] <- known_translocations$FGID[ trans.pairs %in% paste(geneB, geneA, sep="-")  ]
    
    pizzly.fusions$reported_fusion_geneA[i] <- "Yes"
    pizzly.fusions$reported_fusion_geneB[i] <- "Yes"
    
  ##### Now check if any ofthe pizzly detected fusion genes are reported
  } else {
    
    pizzly.fusions$reported_fusion[i] <- "-"
    
    ##### Check the Cancer Genome Interpreter (CGI) database first
    ##### Check pizzly genes A and genes A in reported fusions
    if ( geneA %in% known_translocations$geneA ) {
      
      pizzly.fusions$reported_fusion_geneA[i] <- "Yes"
      
    ##### Check pizzly genes A and genes B in reported fusions
    } else if ( geneA %in% known_translocations$geneB ) {
      
      pizzly.fusions$reported_fusion_geneA[i] <- "Yes"
    }
    
    ##### Check pizzly genes B and genes A in reported fusions
    if ( geneB %in% known_translocations$geneA ) {
      
      pizzly.fusions$reported_fusion_geneB[i] <- "Yes"
      
    ##### Check pizzly genes B and genes B in reported fusions
    } else if ( geneB %in% known_translocations$geneB ) {
      
      pizzly.fusions$reported_fusion_geneB[i] <- "Yes"
    }
    
    ##### Flag if any of the genes are effector gene
    if ( geneA %in% known_translocations$effector_gene  ) {
          
      pizzly.fusions$effector_gene[i] <- geneA
      
    } else if ( geneB == known_translocations$effector_gene  ) {
          
        pizzly.fusions$effector_gene[i] <- geneB
    }
  }
}

##### Rearrange the table to move the transcripts list at the end
pizzly.fusions <- pizzly.fusions %>% dplyr::select(-"transcripts.list","transcripts.list")

##### Index duplicated rows = these are fusions which involve both highly abundant transcripts and cancer genes and so are duplicated in  pizzly.fusions data frame
dup.index <- which( duplicated(pizzly.fusions) |  duplicated(pizzly.fusions[nrow(pizzly.fusions):1, ])[nrow(pizzly.fusions):1] )

##### Add column indicating fusions containing high abundant transcripts and known cancer genes
fusions_abundant <- c(rep("-", nrow(pizzly.fusions)))
fusions_abundant[ c(1:nrow(deduped.result)) ] <- "Yes"
fusions_cancer <- c(rep("-", nrow(pizzly.fusions)))

if ( nrow(result.cancer_genes) > 0 ) {
  fusions_cancer[ c((nrow(deduped.result)+1):(nrow(deduped.result) + nrow(result.cancer_genes))) ] <- "Yes"
}

pizzly.fusions <- cbind(pizzly.fusions, fusions_abundant, fusions_cancer)

##### Indicate duplicated rows and flag them as both, those which involve both highly abundant transcripts and cancer genes
pizzly.fusions$fusions_abundant[ dup.index  ] <- "Yes"
pizzly.fusions$fusions_cancer[ dup.index ] <- "Yes"

##### Remove duplicated rows
if ( any(duplicated(pizzly.fusions)) ) {
  
  pizzly.fusions <- pizzly.fusions[ -c(which( duplicated(pizzly.fusions) )), ]
}

##### Re-order fusion genes based on the reported fusions column
pizzly.fusions <- pizzly.fusions[ order(pizzly.fusions$reported_fusion, pizzly.fusions$fusions_abundant, pizzly.fusions$paircount, pizzly.fusions$splitcount, pizzly.fusions$fusions_cancer, pizzly.fusions$reported_fusion_geneA, pizzly.fusions$reported_fusion_geneB, decreasing = TRUE), ]
```

```{r fusions_reads, comment = NA, message=TRUE, warning=FALSE}
##### Get the number of reads supporting fusions of interest
fusion_reads <- data.frame()

for (row in 1:nrow(deduped.result)){
  y <- strsplit(as.character(deduped.result[row, "transcripts.list"]), "\\;")
  y <- unname(y)
  for (i in 1:length(y[[1]])){
    if (y[[1]][i] %in% quant.sorted.filtered$target_id){
      #creating a new dataframe for the reads supporting individual transcript ID for each filtered fusion gene pair 
      fusion_reads_inter <- data.frame(deduped.result[ row, names(deduped.result) %!in% "transcripts.list" ])
      fusion_reads_inter$transcriptID = y[[1]][i]
      tpm = quant.sorted.filtered[grep(y[[1]][i], quant.sorted.filtered$target_id), ]$tpm 
      fusion_reads_inter$tpm = tpm
      fusion_reads <- rbind(fusion_reads, fusion_reads_inter)
    }
  }
}

##### Rearrange the table to move the transcripts list at the end
fusion_reads <- fusion_reads %>% dplyr::select(-"transcriptID","transcriptID")
```

```{r fusions_annot, comment = NA, message=TRUE, warning=FALSE}
##### Annotate fusion genes
##### Get data to annotate fusion genes
fusion_genes_annot <- ref_datasets.list[[tissue]][["gene_annot_all"]][ , c("ENSEMBL", "SYMBOL", "SEQNAME", "GENESEQSTART", "GENESEQEND") ]

##### Keep only fusions for which both genes have gene symbol (and genomics location) available
pizzly.fusions <- pizzly.fusions[ pizzly.fusions$geneA.id %in% fusion_genes_annot$ENSEMBL, ]
pizzly.fusions <- pizzly.fusions[ pizzly.fusions$geneB.id %in% fusion_genes_annot$ENSEMBL, ]

pizzly.fusions.annot <- pizzly.fusions
pizzly.fusions.annot$order <- 1:nrow(pizzly.fusions.annot)

##### Get genomic info for fusions genes
fusion_annot1 <- merge(fusion_genes_annot, pizzly.fusions.annot[ , c("geneA.id", "order")], by = 1, sort=FALSE)
fusion_annot1 <- fusion_annot1[ order(fusion_annot1$order), ]
fusion_annot2 <- merge(fusion_genes_annot, pizzly.fusions.annot[ , c("geneB.id", "order")], by = 1, sort=FALSE)
fusion_annot2 <- fusion_annot2[ order(fusion_annot2$order), ]

fusion_annot <- cbind(fusion_annot1, fusion_annot2, pizzly.fusions.annot[, c("paircount", "splitcount", "reported_fusion", "fusions_abundant", "fusions_cancer", "reported_fusion_geneA", "reported_fusion_geneB")])

##### Add column to flag fusions supported by WGS data (from MANTA), if available
fusion_annot$geneA_dna_support <- "-"
fusion_annot$geneB_dna_support <- "-"

colnames(fusion_annot) = make.names(colnames(fusion_annot), unique=TRUE)
```

```{r pizzly_data_cleanup, comment = NA, message=FALSE, warning=FALSE}
##### Clean the pizzly data first
##### Remove some columns and rename column names for better presentation
pizzly.fusions.cut <- pizzly.fusions[ , names(pizzly.fusions) %!in% c("geneA.id", "geneB.id", "transcripts.list") ]

##### Add column to flag fusions supported by WGS data (from MANTA), if available
pizzly.fusions.cut$geneA_dna_support <- "-"
pizzly.fusions.cut$geneB_dna_support <- "-"

pizzly.fusions.cut <- pizzly.fusions.cut[ , c("geneA.name", "geneB.name", "paircount", "splitcount", "geneA_dna_support", "geneB_dna_support", "reported_fusion", "FGID", "fusions_abundant", "fusions_cancer", "reported_fusion_geneA", "reported_fusion_geneB") ]
```

```{r pizzly_and_manta_data_prep, comment = NA, message=FALSE, warning=FALSE, eval = runSVsChunk}
##### Compare PIZZY and MANTA called gene fusion events

##### Deal with MANTA results
##### Add row for gene fusion events so that there is one row per gene
manta_sv <- ref_genes.list[["manta"]]
manta_sv$event <- manta_sv$gene
  
i <- 1
  
while ( i <= nrow(manta_sv) ) {
    
  if ( length(strsplit(manta_sv$gene[i], split='&', fixed=TRUE)[[1]]) > 1 ) {
      
    ##### Insert new row for events involving two genes
    manta_sv <- InsertRow(manta_sv, manta_sv[i,], RowNum = i)
      
    manta_sv$gene[i] <- strsplit(manta_sv$event[i], split='&', fixed=TRUE)[[1]][1]
    manta_sv$gene[i+1] <- strsplit(manta_sv$event[i], split='&', fixed=TRUE)[[1]][2]
      
  }
  i <- i + 1
}
  
##### Compare fusion genes called by PIZZLy and MANTA
##### First limit MANTA output to fusions only
manta_pizzly.fusions <- unique(manta_sv[ grep("&", manta_sv$event),  ]$gene)
manta_pizzly.fusions <- manta_pizzly.fusions[ manta_pizzly.fusions %in% unique(c(as.vector(pizzly.fusions.cut$geneA.name), as.vector(pizzly.fusions.cut$geneB.name))) ]
  
##### Flag PIZZLY fusions that were also reported in MANTA
if ( length(manta_pizzly.fusions) > 0 ) {
    
  pizzly.fusions.cut$geneA_dna_support[ sort( match( manta_pizzly.fusions , pizzly.fusions.cut$geneA.name ), na.last = NA ) ] <- "Yes"
  pizzly.fusions.cut$geneB_dna_support[ sort( match( manta_pizzly.fusions , pizzly.fusions.cut$geneB.name ), na.last = NA ) ] <- "Yes"
    
  fusion_annot$geneA_dna_support[ sort( match( manta_pizzly.fusions , fusion_annot$SYMBOL ), na.last = NA ) ] <- "Yes"
  fusion_annot$geneB_dna_support[ sort( match( manta_pizzly.fusions , fusion_annot$SYMBOL.1 ), na.last = NA ) ] <- "Yes"

  ##### Re-order pizzly dataframe with MANTA supporting fusions on top
  idx <- order(pizzly.fusions.cut$geneA_dna_support, pizzly.fusions.cut$geneB_dna_support, pizzly.fusions.cut$reported_fusion, decreasing = TRUE)
  pizzly.fusions.cut <- pizzly.fusions.cut[ idx, ]
  fusion_annot <- fusion_annot[ idx, ]
  pizzly.fusions <- pizzly.fusions[ idx, ]
}
```

```{r ref_cohorts_summary, comment = NA, message=FALSE, warning=FALSE}
##### Summarise the reference cohorts samples
target <- ref_datasets.list[[tissue]][["sample_annot"]]

ref_normal <- table(target$Target)[names(table(target$Target))==normal_group]
ref_cancer <- table(target$Target)[names(table(target$Target))==cancer_group]
```

***

## Input data

<details>
<summary>Summary</summary>

The following reference patient cohorts were used for the analysis:

* **`r paste(ref_normal, normal_group, sep=" ")`** samples from [The Genotype-Tissue Expression](https://commonfund.nih.gov/gtex){target="_blank"} (GTEx) program ([related publication](https://www.mdpi.com/2075-4426/5/1/22){target="_blank"})
* **`r paste(ref_cancer, cancer_group, sep=" ")`** samples from [The Cancer Genome Atlas](https://cancergenome.nih.gov/abouttcga){target="_blank"} (TCGA) project ([related publication](https://www.nature.com/articles/ng.2764){target="_blank"})

Out of the `r nrow(counts)` input genes:

* **`r nrow(data.annot)` genes** have reliably detected expression
* `r nrow(counts) - nrow(y.filtered$counts)` are either not expressed or their expression level is too low to be detected
* `r nrow(y.filtered$counts) - nrow(data.annot)` genes were ignored due to lack of [HGNC](https://www.genenames.org/){target="_blank"}-approved gene symbol

NOTE: the `r nrow(counts) - nrow(y.filtered$counts)` genes with no/low expression are indicated in <span style="color:#808080">BLANK</span> cells with missing values in *expression summary tables* in [Mutated genes], [Cancer genes], [Structural variants], [CN altered genes] and [Immune markers] sections.

</details>

***

## Mutated genes

mRNA expression levels of genes containing single nucleotide variants (SNVs) or insertions/deletions (indels), obtained from the [PCGR](https://github.com/sigven/pcgr){target="_blank"} report, in patient's sample and their average mRNA expression in samples from cancer and healthy individuals. NOTE, only PCGR [tier 1-3](https://pcgr.readthedocs.io/en/latest/tier_systems.html#tier-model-2-pcgr-acmg){target="_blank"} variants are reported.

Mutation data for this sample is **`r if ( runPcgrChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**. 

### - Summary table {.tabset}

Out of the `r length(unique(ref_genes.list[["pcgr"]]$SYMBOL))` mutated genes `r length(unique(ref_genes.list[["pcgr"]][ ref_genes.list[["pcgr"]]$TIER %in% c("1", "2", "3" ), ]$SYMBOL))` include [tier 1-3](https://pcgr.readthedocs.io/en/latest/tier_systems.html#tier-model-2-pcgr-acmg){target="_blank"} variants. Of these, the expression of **`r length(which(unique(ref_genes.list[["pcgr"]][ ref_genes.list[["pcgr"]]$TIER %in% c("1", "2", "3" ), ]$SYMBOL) %in% rownames(ref_datasets.list[[tissue]][["combined_data_processed"]])))`** was reliably measured in patient's sample. The remaining `r length(which((unique(ref_genes.list[["pcgr"]][ ref_genes.list[["pcgr"]]$TIER %in% c("1", "2", "3" ), ]$SYMBOL)) %!in% rownames(ref_datasets.list[[tissue]][["combined_data_processed"]])))` genes are either not expressed or their expression level is too low to be detected (indicated in <span style="color:#808080">BLANK</span> cells with missing values).

#### Z-scores

```{r mut_genes_table, comment = NA, message=FALSE, warning=FALSE, eval = runPcgrChunk}
##### Generate expression summary table for mutated genes (based on PCGR report)
targets <- ref_datasets.list[[tissue]][["sample_annot"]]
data <- ref_datasets.list[[tissue]][["combined_data_processed"]]

##### Consider only genes with mutations calssified within Tiers 1-3
genes <- unique(ref_genes.list[["pcgr"]][ ref_genes.list[["pcgr"]]$TIER %in% c("1", "2", "3" ), ]$SYMBOL)

##### Deal with no genes
if ( length(genes) == 0 ) {
  
  genes <- NULL
}

mut_genes.expr.z <- exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], mut_annot = ref_genes.list[["pcgr"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "z")

##### Present the expression summary table
mut_genes.expr.z[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=mut_genes.expr.z[[1]], file=paste(exprTableDir, "mut_genes.expr.z.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Patient vs `r cancer_group`** column illustrates the difference between Z-scores in patient sample and cohort of healthy individuals for each mutated gene. Variants' tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided based on information from [PCGR](https://github.com/sigven/pcgr){target="_blank"} report. In case of multiple varaints detected in single gene the variant with the lowest tier is reported and other potential consequences are listed in column *CONSEQUENCE_OTHER*. Genes are ordered by **increasing variants TIER** and then by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. SD - standard deviation across groups
</font>
</details>

***

#### Percentiles

```{r mut_genes_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = runPcgrChunk}
mut_genes.expr.perc <- exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], mut_annot = ref_genes.list[["pcgr"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "perc")

##### Present the expression summary table
mut_genes.expr.perc[[1]]

##### Save the expression table as html file
##### Create directory for tables
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=mut_genes.expr.perc[[1]], file=paste(exprTableDir, "mut_genes.expr.perc.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Patient vs `r cancer_group`** column illustrates the difference between percentiles in patient sample and cohort of healthy individuals for each mutated gene. Variants' tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided based on information from [PCGR](https://github.com/sigven/pcgr){target="_blank"} report. In case of multiple varaints detected in single gene the variant with the lowest tier is reported and other potential consequences are listed in column *CONSEQUENCE_OTHER*. Genes are ordered by **increasing variants TIER** and then by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. SD - standard deviation across groups
</font>
</details>

***

### - Expression profiles {.tabset}

Expression profiles for 10 mutated genes with variants annotated with the lowest [tier](https://pcgr.readthedocs.io/en/latest/tier_systems.html#tier-model-2-pcgr-acmg){target="_blank"} and demonstrating the greatest difference in standarised (Z-score) mRNA expression values between patient's sample and the average mRNA expression in samples from healthy individuals.

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[1]) ) { mut_genes.expr.z[[2]]$SYMBOL[1] }`

```{r cdf_plot_mut_genes_1, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[1]

if ( !is.na(gene) && gene %in% rownames(data) ) {
  ##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_genes.expr.z[[2]]$SYMBOL), "mutated genes that include tier 1-3 variants!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[2]) ) { mut_genes.expr.z[[2]]$SYMBOL[2] }`

```{r cdf_plot_mut_genes_2, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[2]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_genes.expr.z[[2]]$SYMBOL), "mutated genes that include tier 1-3 variants!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[3]) ) { mut_genes.expr.z[[2]]$SYMBOL[3] }`

```{r cdf_plot_mut_genes_3, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[3]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_genes.expr.z[[2]]$SYMBOL), "mutated genes that include tier 1-3 variants!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[4]) ) { mut_genes.expr.z[[2]]$SYMBOL[4] }`

```{r cdf_plot_mut_genes_4, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[4]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_genes.expr.z[[2]]$SYMBOL), "mutated genes that include tier 1-3 variants!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[5]) ) { mut_genes.expr.z[[2]]$SYMBOL[5] }`

```{r cdf_plot_mut_genes_5, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[5]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_genes.expr.z[[2]]$SYMBOL), "mutated genes that include tier 1-3 variants!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[6]) ) { mut_genes.expr.z[[2]]$SYMBOL[6] }`

```{r cdf_plot_mut_genes_6, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[6]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_genes.expr.z[[2]]$SYMBOL), "mutated genes that include tier 1-3 variants!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[7]) ) { mut_genes.expr.z[[2]]$SYMBOL[7] }`

```{r cdf_plot_mut_genes_7, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[7]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_genes.expr.z[[2]]$SYMBOL), "mutated genes that include tier 1-3 variants!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[8]) ) { mut_genes.expr.z[[2]]$SYMBOL[8] }`

```{r cdf_plot_mut_genes_8, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[8]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_genes.expr.z[[2]]$SYMBOL), "mutated genes that include tier 1-3 variants!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[9]) ) { mut_genes.expr.z[[2]]$SYMBOL[9] }`

```{r cdf_plot_mut_genes_9, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[9]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_genes.expr.z[[2]]$SYMBOL), "mutated genes that include tier 1-3 variants!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runPcgrChunk && !is.na(mut_genes.expr.z[[2]]$SYMBOL[10]) ) { mut_genes.expr.z[[2]]$SYMBOL[10] }`

```{r cdf_plot_mut_genes_10, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPcgrChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_genes.expr.z[[2]]$SYMBOL[10]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_genes.expr.z[[2]]$SYMBOL), "mutated genes that include tier 1-3 variants!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

## Cancer genes

mRNA expression levels of cancer genes in patient's sample and their average mRNA expression in samples from cancer and healthy individuals. These include genes reported in the following gene panels/resources *UMCCR cancer genes*, *[OncoKB](http://oncokb.org/#/about){target="_blank"}* (cancer genes listed [here](http://oncokb.org/#/cancerGenes){target="_blank"} and available [here](https://github.com/oncokb/oncokb-public/tree/master/data){target="_blank"}), *[MSK-IMPACT](https://www.mskcc.org/msk-impact){target="_blank"}*, *[MSK-HEME](http://www.islh.org/Presentation_Upload/presentation_uploads/12_52_0900-Zehir.pdf){target="_blank"}*, *[Foundation One](https://www.foundationmedicine.com/genomic-testing/foundation-one-cdx){target="_blank"}*, *[Foundation One Heme](https://www.foundationmedicine.com/genomic-testing/foundation-one-heme){target="_blank"}*, *[Vogelstein](http://science.sciencemag.org/content/339/6127/1546.full){target="_blank"}* and *[Sanger Cancer Gene Census](https://www.sanger.ac.uk/science/data/cancer-gene-census){target="_blank"}* (CGC).

### - Summary table {.tabset}

Out of the `r nrow(ref_genes.list[["genes_cancer"]])` cancer genes the expression of **`r length(which(rownames(ref_genes.list[["genes_cancer"]]) %in% rownames(ref_datasets.list[[tissue]][["combined_data_processed"]])))`** was reliably measured in patient's sample. The remaining `r length(which(rownames(ref_genes.list[["genes_cancer"]]) %!in% rownames(ref_datasets.list[[tissue]][["combined_data_processed"]])))` genes are either not expressed or their expression level is too low to be detected (indicated in <span style="color:#808080">BLANK</span> cells with missing values).

#### Z-scores

```{r cancer_genes_table, comment = NA, message=FALSE, warning=FALSE}
##### Generate expression summary table for cancer genes from OncoKB and PMCC
targets <- ref_datasets.list[[tissue]][["sample_annot"]]
data <- ref_datasets.list[[tissue]][["combined_data_processed"]]

cancer_genes.expr.z <- exprTable( genes = rownames(ref_genes.list[["genes_cancer"]]), data = data, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]], ext_links = TRUE, type = "z")

##### Present the expression summary table
cancer_genes.expr.z[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=cancer_genes.expr.z[[1]], file=paste(exprTableDir, "cancer_genes.expr.z.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Patient vs `r cancer_group`** column illustrates the difference between Z-scores in patient sample and cohort of healthy individuals for each cancer gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, and inclusion in various sequencing panels are also indicated. Genes are ordered by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. TSG - tumour suppressor gene; SD - standard deviation across groups
</font>
</details>

***

#### Percentiles

```{r cancer_genes_table_perc, comment = NA, message=FALSE, warning=FALSE}
cancer_genes.expr.perc <- exprTable( genes = rownames(ref_genes.list[["genes_cancer"]]), data = data, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]], ext_links = TRUE, type = "perc")

##### Present the expression summary table
cancer_genes.expr.perc[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=cancer_genes.expr.perc[[1]], file=paste(exprTableDir, "cancer_genes.expr.perc.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Patient vs `r cancer_group`** column illustrates the difference between percentiles in patient sample and cohort of healthy individuals for each cancer gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, and inclusion in various sequencing panels are also indicated. Genes are ordered by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. TSG - tumour suppressor gene; SD - standard deviation across groups
</font>
</details>

***

### - Expression profiles {.tabset}

Expression profiles for 10 altered cancer genes with the greatest difference in standarised (Z-score) mRNA expression values between patient's sample and the average mRNA expression in samples from healthy individuals.

#### `r cancer_genes.expr.z[[2]]$SYMBOL[1]`

```{r cdf_plot_cancer_genes_1, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[1]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[2]`

```{r cdf_plot_cancer_genes_2, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[2]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[3]`

```{r cdf_plot_cancer_genes_3, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[3]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[4]`

```{r cdf_plot_cancer_genes_4, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[4]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[5]`

```{r cdf_plot_cancer_genes_5, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[5]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[6]`

```{r cdf_plot_cancer_genes_6, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[6]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[7]`

```{r cdf_plot_cancer_genes_7, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[7]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[8]`

```{r cdf_plot_cancer_genes_8, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[8]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}
##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[9]`

```{r cdf_plot_cancer_genes_9, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[9]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r cancer_genes.expr.z[[2]]$SYMBOL[10]`

```{r cdf_plot_cancer_genes_10, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- cancer_genes.expr.z[[2]]$SYMBOL[10]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(cancer_genes.expr.z[[2]]$SYMBOL), "altered cancer genes detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

## Fusion genes

<details>
<summary>Fusion genes prioritisation</summary>

Fusion genes detected in transcriptome data are prioritised based on criteria ranked in the following order:

1. Involvement of fusion gene(s) **detected in genomic data** (if [Structural variants] results are available)

2. Listed as **reported** fusion event according to [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"} database

3. Involvement of highly **abundant transcript(s)**  (see abundant transcripts definition below)

4. The number of **split counts**

5. The number of **pair counts**

6. Involvement of **cancer gene(s)** (see [Cancer genes] section)

</details>

<details>
<summary>Abundant transcripts definition</summary>

The following steps were performed to define **abundant transcripts** involved in detected fusion events:

1. Run [kallisto](https://github.com/pachterlab/kallisto){target="_blank"} to quantify the fusion transcripts reported by [pizzly](https://github.com/pmelsted/pizzly){target="_blank"} and select those which are supported by decent number of [Transcripts Per Kilobase Million](http://www.arrayserver.com/wiki/index.php?title=TPM){target="_blank"} (TPM) 
2. Create a new index based on the transcriptome and the fusion transcripts identified by [pizzly](https://github.com/pmelsted/pizzly){target="_blank"}
3. Run [kallisto](https://github.com/pachterlab/kallisto){target="_blank"} in normal quantification mode on the expanded index to quantify both normal transcripts and fusions
4. Select fusion genes involving transcripts with [TPM](http://www.arrayserver.com/wiki/index.php?title=TPM){target="_blank"} values above 90th percentile of all [TPM](http://www.arrayserver.com/wiki/index.php?title=TPM){target="_blank"} values (as reported by previous step)

</details>

***

### - Summary

Out of the `r nrow(pizzly.fusions.cut)` fusion event(s) <span style="color:#ff0000">**`r nrow(pizzly.fusions.cut[ pizzly.fusions.cut$geneA_dna_support == "Yes" | pizzly.fusions.cut$geneB_dna_support == "Yes" , ])`**</span> involve **DNA-supported** fusion genes (see [Structural variants] section), <span style="color:#02d653">**`r nrow(pizzly.fusions.cut[ pizzly.fusions.cut$reported_fusion == "Yes" , ])`**</span> are **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"}**, <span style="color:#0000ff">**`r nrow(pizzly.fusions.cut[ pizzly.fusions.cut$fusions_abundant == "Yes" , ])`**</span> contain **highly abundant** fusion transcript(s) and <span style="color:#767689">**`r nrow(pizzly.fusions.cut[ pizzly.fusions.cut$fusions_cancer == "Yes" , ])`**</span> involve **[Cancer genes]**.

NOTE: Only fusion events including genes with available genomics coordinates in [Ensembl database version](https://ensembl.org/info/website/archives/index.html){target="_blank"} `r params$ensembl_version` are reported.

```{r fusions_summary_table, comment = NA, message=FALSE, warning=FALSE}
##### Create a nice table output (with dataTable)
pizzly.fusions.table <- pizzly.fusions.cut
pizzly.fusions.table$geneA.name <- as.vector(pizzly.fusions.table$geneA.name)
pizzly.fusions.table$geneB.name <- as.vector(pizzly.fusions.table$geneB.name)

##### Provide link to FusionGDB
for ( i in 1:nrow(pizzly.fusions.table) ) {
  
    if ( pizzly.fusions.table$reported_fusion[i] == "Yes" ) {
        
      pizzly.fusions.table$geneA.name[i] <- paste0("<a href='https://ccsm.uth.edu/FusionGDB/gene_search_result.cgi?page=page&type=quick_search&quick_search=", pizzly.fusions.table$FGID[i], "' target='_blank'>", pizzly.fusions.table$geneA.name[i], "</a>")

      pizzly.fusions.table$geneB.name[i] <- paste0("<a href='https://ccsm.uth.edu/FusionGDB/gene_search_result.cgi?page=page&type=quick_search&quick_search=", pizzly.fusions.table$FGID[i], "' target='_blank'>", pizzly.fusions.table$geneB.name[i], "</a>")
    }
}

pizzly.fusions.table <- pizzly.fusions.table[ , names(pizzly.fusions.table) %!in% "FGID" ]

names(pizzly.fusions.table) <- c("Gene A", "Gene B", "Pair count", "Split count", "DNA support (gene A)", "DNA support (gene B)", "Reported fusion", "Abundant transcript(s)", "Cancer gene(s)", "Fusion gene (A)", "Fusion gene (B)")

##### Present gene fusion events in a table
pizzly.fusions.summary <- DT::datatable( data = pizzly.fusions.table, filter = "none", rownames = FALSE, extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800, caption = htmltools::tags$caption(style = 'caption-side: top; text-align: left; color:grey; font-size:100% ;'), escape = FALSE) %>%
    DT::formatStyle( columns = names(pizzly.fusions.table), `font-size` = '12px', 'text-align' = 'center' ) %>%
  
    ##### Highlight rows with fusions involving hihgly abundant transcripts (red), cancer genes (blue) or DNA support (from MANTA)
    DT::formatStyle( columns = colnames(pizzly.fusions.table) %in% "Abundant transcript(s)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'lightblue')) ) %>%
    DT::formatStyle( columns = colnames(pizzly.fusions.table) %in% "Cancer gene(s)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'lightgrey')) ) %>%
    DT::formatStyle( columns = colnames(pizzly.fusions.table) %in% "DNA support (gene A)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'coral')) ) %>%
    DT::formatStyle( columns = colnames(pizzly.fusions.table) %in% "DNA support (gene B)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'coral')) ) %>%
    DT::formatStyle( columns = colnames(pizzly.fusions.table) %in% "Reported fusion", backgroundColor = DT::styleEqual( c("-", "Yes"), c('transparent', 'lightgreen')) )

pizzly.fusions.summary

##### Save the table as html file
if ( params$plots_mode == "interactive" ) {
  
  ##### Create directory for tables
  fusionsTableDir <- paste(params$report_dir, "fusionsTables", sep = "/")
  
  if ( !file.exists(fusionsTableDir) ) {
  
          dir.create(fusionsTableDir, recursive=TRUE)
  }

  DT::saveWidget(widget=pizzly.fusions.summary, file=paste(fusionsTableDir, "pizzly.fusions.summary.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
Cells in <span style="color:#ff0000">RED</span> indicate **DNA-supported** fusion genes (see [Structural variants] section), cells in <span style="color:#02d653">GREEN</span> indicate fusion events **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"}**, cells in <span style="color:#0000ff">BLUE</span> indicate **highly abundant** fusion transcript(s), and those hihglighted in <span style="color:#767689">GREY</span> indicate fusions containing **[Cancer genes]**. Gene fusions reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"} are hyperlinked. Genes known to be involved in gene fusions are flagged based on information provided in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"} and [Cancer Genome Interpreter](https://www.cancergenomeinterpreter.org/biomarkers){target="_blank"} (CGI) databases. Fusion events are ordered by the following columns:

**DNA support (gene A/B)**: DNA-supported fusion gene(s) (see [Structural variants] section)

**Reported fusion**: fusion event reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"}

**Abundant transcript(s)**: gene fusion events involving highly abundant transcript(s)

**Cancer gene(s)**: gene fusion events involving [Cancer genes]

**Fusion gene (A/B)**: gene(s) known to be involved in tumorigenesis across cancer types based on [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"} and [CGI](https://www.cancergenomeinterpreter.org/biomarkers){target="_blank"} databases
</font>
</details>

***

### - Genomic view

<span style="color:#ff0000">**`r nrow(pizzly.fusions.cut[ pizzly.fusions.cut$geneA_dna_support == "Yes" | pizzly.fusions.cut$geneB_dna_support == "Yes" , ])`**</span> involving **DNA-supported** fusion genes (see [Structural variants] section) and <span style="color:#02d653">**`r nrow(pizzly.fusions.cut[ pizzly.fusions.cut$reported_fusion == "Yes" , ])`**</span> gene fusions **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"}** are presented in the genomic context. The table at the bottom contains genomic coordingates of individual fusion genes sorted based on their genomic location.

SVs information for this sample is **`r if ( runSVsChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**. 

```{r genomic_view_plot_fusions, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
##### Keep only fusions with abundant transcript(s) or cancer gene(s) involved
fusion_annot_top <- fusion_annot[ fusion_annot$reported_fusion == "Yes" | fusion_annot$geneA_dna_support == "Yes" | fusion_annot$geneB_dna_support == "Yes" , ]

##### Generate bezier curves-like plot representing gene fusion events. NOTE. Only fusions involving fusion genes supported by MANTA are presented
if ( nrow(fusion_annot_top) > 0 ) {
  
  BezierPlot <- fusionsBezierPlot(fusion_annot = fusion_annot_top, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]])
  BezierPlot
  
} else {
  
  cat("None of the transcriptome-based fusion events have supporting evidence from DNA data.")
}
```

```{r genomic_view_plot_fusions_save, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
##### Save the BezierPlot as png
if ( nrow(fusion_annot_top) > 0 ) {
  
  fusionsPlotDir <- paste(params$report_dir, "fusionsPlot", sep = "/")
  
  if ( !file.exists(fusionsPlotDir) ) {
  
        dir.create(fusionsPlotDir, recursive=TRUE)
  }
  
  png( filename = paste(fusionsPlotDir, "bezierPlot.png", sep="/"), width = 800, height = 300, units = "px" )
  BezierPlot
}
```

```{r genomic_view_table_fusions, comment = NA, message=FALSE, warning=FALSE, eval = runSVsChunk}
if ( nrow(fusion_annot_top) > 0 ) {
  
  ##### Clean the table for better presentation
  fusion_annot_top.clean <- fusion_annot_top[, c("SYMBOL", "SEQNAME", "GENESEQSTART", "GENESEQEND", "SYMBOL.1", "SEQNAME.1", "GENESEQSTART.1", "GENESEQEND.1", "paircount", "splitcount", "geneA_dna_support", "geneB_dna_support", "reported_fusion", "fusions_abundant", "fusions_cancer") ]
  
  ##### Order fusions based on the genomic location (chrom and start positions)
  chrOrder <-c((1:22),"X","Y","M")
  
  fusion_annot_top.clean$SEQNAME <- factor(fusion_annot_top.clean$SEQNAME, chrOrder, ordered=TRUE)
  fusion_annot_top.clean$SEQNAME.1 <- factor(fusion_annot_top.clean$SEQNAME.1, chrOrder, ordered=TRUE)
  fusion_annot_top.clean <- fusion_annot_top.clean[do.call(order, fusion_annot_top.clean[, c("SEQNAME", "SEQNAME.1", "GENESEQSTART", "GENESEQSTART.1")]), ]
  
  names(fusion_annot_top.clean) <- c("Gene A", "Chrom (A)", "Start (A)", "End (A)", "Gene B", "Chrom (B)", "Start (B)", "End (B)", "Pair count", "Split count", "DNA support (gene A)", "DNA support (gene B)", "Reported fusion", "Abundant transcript(s)", "Cancer gene(s)")
  
  pizzly.fusions.genomicView <- DT::datatable( data = fusion_annot_top.clean, filter="none", rownames = FALSE, extensions = c('Buttons','Scroller'), options = list(pageLength = 10, dom = 'Bfrtip', buttons = c('excel', 'csv', 'pdf','copy','colvis'), scrollX = TRUE, deferRender = TRUE, scrollY = 200, scroller = TRUE), width = 800,  escape = FALSE) %>%
      DT::formatStyle( columns = names(fusion_annot_top.clean), `font-size` = '12px', 'text-align' = 'center' ) %>%
    
      ##### Highlight rows with fusions involving hihgly abundant transcripts (red) or cancer genes (blue)
      DT::formatStyle( columns = colnames(fusion_annot_top.clean) %in% "Abundant transcript(s)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'lightblue')) ) %>%
      DT::formatStyle( columns = colnames(fusion_annot_top.clean) %in% "Cancer gene(s)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'lightgrey')) ) %>%
      DT::formatStyle( columns = colnames(fusion_annot_top.clean) %in% "DNA support (gene A)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'coral')) ) %>%
      DT::formatStyle( columns = colnames(fusion_annot_top.clean) %in% "DNA support (gene B)", backgroundColor = DT::styleEqual(c("-", "Yes"), c('transparent', 'coral')) ) %>%
    DT::formatStyle( columns = colnames(fusion_annot_top.clean) %in% "Reported fusion", backgroundColor = DT::styleEqual( c("-", "Yes"), c('transparent', 'lightgreen')) )

pizzly.fusions.genomicView
}
```

```{r genomic_view_table_fusions_save, comment = NA, message=FALSE, warning=FALSE, eval = runSVsChunk}
##### Save the table as html file
if ( nrow(fusion_annot_top) > 0 && params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=pizzly.fusions.genomicView, file=paste(fusionsTableDir, "pizzly.fusions.genomicView.html", sep = "/"), selfcontained=TRUE)  
}
```

<details>
<summary>Table legend</summary>
<font size="2">
Cells in <span style="color:#ff0000">RED</span> indicate **DNA-supported** fusion genes (see [Structural variants] section), cells in <span style="color:#02d653">GREEN</span> indicate gene fusions **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"}**, cells in <span style="color:#0000ff">BLUE</span> indicate **highly abundant** fusion transcript(s), and those hihglighted in <span style="color:#767689">GREY</span> indicate fusions containing **[Cancer genes]**. Genes known to be involved in gene fusions are flagged based on information provided in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"} and [Cancer Genome Interpreter](https://www.cancergenomeinterpreter.org/biomarkers){target="_blank"} (CGI) databases. Fusion events are ordered by **genomic coordinates** of **Gene A** and then **Gene B**.

**DNA support (gene A/B)**: DNA-supported fusion gene(s) (see) [Structural variants] section)

**Reported fusion**: fusion event reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"}

**Abundant transcript(s)**: gene fusion events involving highly abundant transcript(s)

**Cancer gene(s)**: gene fusion events involving [Cancer genes]
</font>
</details>

***

### - Top hits {.tabset}

Expression profiles for 5 gene fusion events involving **DNA-supported fusion** genes (see [Structural variants] section), gene fusions **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"}**, **abundant transcripts** or **[Cancer genes]**, indicated in <span style="color:#02d653">green</span>, <span style="color:#ff0000">red</span>, <span style="color:#0000ff">blue</span> and <span style="color:#767689">grey</span> columns in the [Fusion genes] table, respectively, and with the highest *Split count* and *Pair count* values. 

<span style="color:#ff0000">NOTE</span>: the *Fusion genes visualisation* is not available for gene pairs for which no junctions were found by [clinker](https://github.com/Oshlack/Clinker){target="_blank"}.

#### `r if ( !is.na(pizzly.fusions$geneA.name[1]) ) { paste(pizzly.fusions$geneA.name[1], pizzly.fusions$geneB.name[1], sep="-") }`

##### Fusion genes visualisation 

```{r fusion_1_process, comment = NA, message=TRUE, warning=FALSE}
##### Convert the fusion image from pdf to png and present it in the report
targets <- ref_datasets.list[[tissue]][["sample_annot"]]
data <- ref_datasets.list[[tissue]][["combined_data_processed"]]

geneA <- pizzly.fusions$geneA.name[1]
geneB <- pizzly.fusions$geneB.name[1]

if ( !is.na(geneA) && !is.na(geneB) && geneA %in% rownames(data) && geneB %in% rownames(data) ) {
  
  runPizzlyChunk <- TRUE
} else {
  
  cat("Expression data is not available for one of the genes.")
  runPizzlyChunk <- FALSE
}

##### Check if clinker fusion plot exists. Skip this section if it doesn't
if ( file.exists(paste0(dataDir, "/clinker/", geneA, "_", geneB, ".pdf")) ) {
  
  ClinkerChunk <- TRUE
} else {
  ClinkerChunk <- FALSE
}

##### Create file listing fusion events for which Clinker plot is available
clinker_fusions <- ""
```

```{r fusion_1_plot, comment = NA, message=TRUE, warning=FALSE, eval=ClinkerChunk}
##### Check if clinker fusion plot exists. Skip this section if it doesn't
fusion_png(geneA, geneB, paste(dataDir, "clinker", sep="/") )
clinker_fusions <- c(clinker_fusions, paste0(geneA, "-", geneB))
```

```{r fusion_tables_1, comment = NA, message=TRUE, warning=FALSE, eval=FALSE}
##### Present a table with number of reads supporting this fusion
##### Check if the fusion has abundant transcript(s)
fusion_reads.top <- fusion_reads[ fusion_reads$geneA.name == geneA & fusion_reads$geneB.name == geneB, ]

if( nrow(fusion_reads.top) !=0 ) {
    kable(fusion_reads.top, row.names = FALSE, caption = paste0("Number of reads supporting ", paste(geneA, geneB, sep="-"), " fusion")) %>%
    kable_styling(font_size = 12, "striped", "bordered") %>%
    scroll_box(width = "100%")
}
```

***

##### Fusion genes expression {.tabset}

mRNA expression levels of fusion genes detected in patient's sample and their average mRNA expression (Z-score) in samples from cancer and healthy individuals.

```{r fusion_1_cdf_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 2.5, eval = runPizzlyChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
cdfPlot(gene = geneA, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode)
cdfPlot(gene = geneB, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

###### Z-scores

```{r fusion_1_gene_table, comment = NA, message=FALSE, warning=FALSE, eval = runPizzlyChunk}
fusion.df <- ref_datasets.list[[tissue]][["gene_annot"]]
fusion.df <- rbind(fusion.df[fusion.df$SYMBOL==geneA, ], fusion.df[fusion.df$SYMBOL==geneB, ])
genes = fusion.df$SYMBOL
  
exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "z")[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The **Patient vs `r cancer_group`** column illustrates the difference between Z-scores in patient sample and cohort of healthy individuals for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. TSG - tumour suppressor gene; SD - standard deviation across groups
</font>
</details>

***

###### Percentiles

```{r fusion_1_gene_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = runPizzlyChunk}
exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "perc")[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The **Patient vs `r cancer_group`** column illustrates the difference between percentiles in patient sample and cohort of healthy individuals for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. TSG - tumour suppressor gene; SD - standard deviation across groups
</font>
</details>

***

#### `r if ( !is.na(pizzly.fusions$geneA.name[2]) ) { paste(pizzly.fusions$geneA.name[2], pizzly.fusions$geneB.name[2], sep="-") }`

##### Fusion genes visualisation 

```{r fusion_2_process, comment = NA, message=TRUE, warning=FALSE}
##### Convert the fusion image from pdf to png and present it in the report
geneA <- pizzly.fusions$geneA.name[2]
geneB <- pizzly.fusions$geneB.name[2]

if ( !is.na(geneA) && !is.na(geneB) && geneA %in% rownames(data) && geneB %in% rownames(data) ) {
  
  runPizzlyChunk <- TRUE
} else {
  
  cat("Expression data is not available for one of the genes.")
  runPizzlyChunk <- FALSE
}

##### Check if clinker fusion plot exists. Skip this section if it doesn't
if ( file.exists(paste0(dataDir, "/clinker/", geneA, "_", geneB, ".pdf")) ) {
  
  ClinkerChunk <- TRUE
} else {
  ClinkerChunk <- FALSE
}
```

```{r fusion_2_plot, comment = NA, message=TRUE, warning=FALSE, eval=ClinkerChunk}
##### Check if clinker fusion plot exists. Skip this section if it doesn't
fusion_png(geneA, geneB, paste(dataDir, "clinker", sep="/") )
clinker_fusions <- c(clinker_fusions, paste0(geneA, "-", geneB))
```

```{r fusion_tables_2, comment = NA, message=TRUE, warning=FALSE, eval=FALSE}
##### Present a table with number of reads supporting this fusion
##### Check if the fusion has abundant transcript(s)
fusion_reads.top <- fusion_reads[ fusion_reads$geneA.name == geneA & fusion_reads$geneB.name == geneB, ]

if( nrow(fusion_reads.top) !=0 ) {
    kable(fusion_reads.top, row.names = FALSE, caption = paste0("Number of reads supporting ", paste(geneA, geneB, sep="-"), " fusion")) %>%
    kable_styling(font_size = 12, "striped", "bordered") %>%
    scroll_box(width = "100%")
}
```

***

##### Fusion genes expression {.tabset}

mRNA expression levels of fusion genes detected in patient's sample and their average mRNA expression (Z-score) in samples from cancer and healthy individuals.

```{r fusion_2_cdf_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 2.5, eval = runPizzlyChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
cdfPlot(gene = geneA, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode)
cdfPlot(gene = geneB, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

###### Z-scores

```{r fusion_2_gene_table, comment = NA, message=FALSE, warning=FALSE, eval = runPizzlyChunk}
fusion.df <- ref_datasets.list[[tissue]][["gene_annot"]]
fusion.df <- rbind(fusion.df[fusion.df$SYMBOL==geneA, ], fusion.df[fusion.df$SYMBOL==geneB, ])
genes = fusion.df$SYMBOL
  
exprTable( genes = genes, data = data, targets = targets, sampleName  = params$sample_name, normal  = normal_group, cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes  = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "z")[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The **Patient vs `r cancer_group`** column illustrates the difference between Z-scores in patient sample and cohort of healthy individuals for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. TSG - tumour suppressor gene; SD - standard deviation across groups
</font>
</details>

***

###### Percentiles

```{r fusion_2_gene_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = runPizzlyChunk}
exprTable( genes = genes, data = data, targets = targets, sampleName  = params$sample_name, normal  = normal_group, cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes  = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "perc")[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The **Patient vs `r cancer_group`** column illustrates the difference between percentiles in patient sample and cohort of healthy individuals for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. TSG - tumour suppressor gene; SD - standard deviation across groups
</font>
</details>

***

#### `r if ( !is.na(pizzly.fusions$geneA.name[3]) ) { paste(pizzly.fusions$geneA.name[3], pizzly.fusions$geneB.name[3], sep="-") }`

##### Fusion genes visualisation 

```{r fusion_3_process, comment = NA, message=TRUE, warning=FALSE}
##### Convert the fusion image from pdf to png and present it in the report
geneA <- pizzly.fusions$geneA.name[3]
geneB <- pizzly.fusions$geneB.name[3]

if ( !is.na(geneA) && !is.na(geneB) && geneA %in% rownames(data) && geneB %in% rownames(data) ) {
  
  runPizzlyChunk <- TRUE
} else {
  
  cat("Expression data is not available for one of the genes.")
  runPizzlyChunk <- FALSE
}

##### Check if clinker fusion plot exists. Skip this section if it doesn't
if ( file.exists(paste0(dataDir, "/clinker/", geneA, "_", geneB, ".pdf")) ) {
  
  ClinkerChunk <- TRUE
} else {
  ClinkerChunk <- FALSE
}
```

```{r fusion_3_plot, comment = NA, message=TRUE, warning=FALSE, eval=ClinkerChunk}
##### Check if clinker fusion plot exists. Skip this section if it doesn't
fusion_png(geneA, geneB, paste(dataDir, "clinker", sep="/") )
clinker_fusions <- c(clinker_fusions, paste0(geneA, "-", geneB))
```

```{r fusion_3_table, comment = NA, message=TRUE, warning=FALSE, eval=FALSE}
##### Present a table with number of reads supporting this fusion
##### Check if the fusion has abundant transcript(s)
fusion_reads.top <- fusion_reads[ fusion_reads$geneA.name == geneA & fusion_reads$geneB.name == geneB, ]

if( nrow(fusion_reads.top) !=0 ) {
    kable(fusion_reads.top, row.names = FALSE, caption = paste0("Number of reads supporting ", paste(geneA, geneB, sep="-"), " fusion")) %>%
    kable_styling(font_size = 12, "striped", "bordered") %>%
    scroll_box(width = "100%")
}
```

***

##### Fusion genes expression {.tabset}

mRNA expression levels of fusion genes detected in patient's sample and their average mRNA expression (Z-score) in samples from cancer and healthy individuals.

```{r fusion_3_cdf_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 2.5, eval = runPizzlyChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
cdfPlot(gene = geneA, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode)
cdfPlot(gene = geneB, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

###### Z-scores

```{r fusion_3_gene_table, comment = NA, message=FALSE, warning=FALSE, eval = runPizzlyChunk}
fusion.df <- ref_datasets.list[[tissue]][["gene_annot"]]
fusion.df <- rbind(fusion.df[fusion.df$SYMBOL==geneA, ], fusion.df[fusion.df$SYMBOL==geneB, ])
genes = fusion.df$SYMBOL
  
exprTable( genes = genes, data = data, targets = targets, sampleName  = params$sample_name, normal  = normal_group, cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes  = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "z")[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The **Patient vs `r cancer_group`** column illustrates the difference between Z-scores in patient sample and cohort of healthy individuals for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. TSG - tumour suppressor gene; SD - standard deviation across groups
</font>
</details>

***

###### Percentiles

```{r fusions_3_gene_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = runPizzlyChunk}
exprTable( genes = genes, data = data, targets = targets, sampleName  = params$sample_name, normal  = normal_group, cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes  = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "perc")[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The **Patient vs `r cancer_group`** column illustrates the difference between percentiles in patient sample and cohort of healthy individuals for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. TSG - tumour suppressor gene; SD - standard deviation across groups
</font>
</details>

***

#### `r if ( !is.na(pizzly.fusions$geneA.name[4]) ) { paste(pizzly.fusions$geneA.name[4], pizzly.fusions$geneB.name[4], sep="-") }`

##### Fusion genes visualisation 

```{r fusions_4_process, comment = NA, message=TRUE, warning=FALSE}
##### Convert the fusion image from pdf to png and present it in the report
geneA <- pizzly.fusions$geneA.name[4]
geneB <- pizzly.fusions$geneB.name[4]

if ( !is.na(geneA) && !is.na(geneB) && geneA %in% rownames(data) && geneB %in% rownames(data) ) {
  
  runPizzlyChunk <- TRUE
} else {
  
  cat("Expression data is not available for one of the genes.")
  runPizzlyChunk <- FALSE
}

##### Check if clinker fusion plot exists. Skip this section if it doesn't
if ( file.exists(paste0(dataDir, "/clinker/", geneA, "_", geneB, ".pdf")) ) {
  
  ClinkerChunk <- TRUE
} else {
  ClinkerChunk <- FALSE
}
```

```{r fusion_4_plot, comment = NA, message=TRUE, warning=FALSE, eval=ClinkerChunk}
##### Check if clinker fusion plot exists. Skip this section if it doesn't
fusion_png(geneA, geneB, paste(dataDir, "clinker", sep="/") )
clinker_fusions <- c(clinker_fusions, paste0(geneA, "-", geneB))
```

```{r fusion_4_table, comment = NA, message=TRUE, warning=FALSE, eval=FALSE}
##### Present a table with number of reads supporting this fusion
##### Check if the fusion has abundant transcript(s)
fusion_reads.top <- fusion_reads[ fusion_reads$geneA.name == geneA & fusion_reads$geneB.name == geneB, ]

if( nrow(fusion_reads.top) !=0 ) {
    kable(fusion_reads.top, row.names = FALSE, caption = paste0("Number of reads supporting ", paste(geneA, geneB, sep="-"), " fusion")) %>%
    kable_styling(font_size = 12, "striped", "bordered") %>%
    scroll_box(width = "100%")
}
```

***

##### Fusion genes expression {.tabset}

mRNA expression levels of fusion genes detected in patient's sample and their average mRNA expression (Z-score) in samples from cancer and healthy individuals.

```{r fusion_4_cdf_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 2.5, eval = runPizzlyChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
cdfPlot(gene = geneA, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode)
cdfPlot(gene = geneB, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

###### Z-scores

```{r fusion_4_gene_table, comment = NA, message=FALSE, warning=FALSE, eval = runPizzlyChunk}
fusion.df <- ref_datasets.list[[tissue]][["gene_annot"]]
fusion.df <- rbind(fusion.df[fusion.df$SYMBOL==geneA, ], fusion.df[fusion.df$SYMBOL==geneB, ])
genes = fusion.df$SYMBOL
  
exprTable( genes = genes, data = data, targets = targets, sampleName  = params$sample_name, normal  = normal_group, cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes  = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "z")[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The **Patient vs `r cancer_group`** column illustrates the difference between Z-scores in patient sample and cohort of healthy individuals for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. TSG - tumour suppressor gene; SD - standard deviation across groups
</font>
</details>

***

###### Percentiles

```{r fusion_4_gene_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = runPizzlyChunk}
exprTable( genes = genes, data = data, targets = targets, sampleName  = params$sample_name, normal  = normal_group, cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes  = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "perc")[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The **Patient vs `r cancer_group`** column illustrates the difference between percentile in patient sample and cohort of healthy individuals for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. TSG - tumour suppressor gene; SD - standard deviation across groups
</font>
</details>

***

#### `r if ( !is.na(pizzly.fusions$geneA.name[5]) ) { paste(pizzly.fusions$geneA.name[5], pizzly.fusions$geneB.name[5], sep="-") }`

##### Fusion genes visualisation 

```{r fusion_5_process, comment = NA, message=TRUE, warning=FALSE}
##### Convert the fusion image from pdf to png and present it in the report
geneA <- pizzly.fusions$geneA.name[5]
geneB <- pizzly.fusions$geneB.name[5]

if ( !is.na(geneA) && !is.na(geneB) && geneA %in% rownames(data) && geneB %in% rownames(data) ) {
  
  runPizzlyChunk <- TRUE
} else {
  
  cat("Expression data is not available for one of the genes.")
  runPizzlyChunk <- FALSE
}

##### Check if clinker fusion plot exists. Skip this section if it doesn't
if ( file.exists(paste0(dataDir, "/clinker/", geneA, "_", geneB, ".pdf")) ) {
  
  ClinkerChunk <- TRUE
} else {
  ClinkerChunk <- FALSE
}

##### Write list of fusion events for which Clinker plot is available into a file
write.table(prepare2write(clinker_fusions), file = paste0(params$report_dir, "/", params$sample_name,".clinker_fusions.txt"), sep="\t", quote=FALSE, row.names=FALSE, col.names=TRUE, append = FALSE )
```

```{r fusion_5_plot, comment = NA, message=TRUE, warning=FALSE, eval=ClinkerChunk}
##### Check if clinker fusion plot exists. Skip this section if it doesn't
fusion_png(geneA, geneB, paste(dataDir, "clinker", sep="/") )
clinker_fusions <- c(clinker_fusions, paste0(geneA, "-", geneB))
```

```{r fusion_5_table, comment = NA, message=TRUE, warning=FALSE, eval=FALSE}
##### Present a table with number of reads supporting this fusion
##### Check if the fusion has abundant transcript(s)
fusion_reads.top <- fusion_reads[ fusion_reads$geneA.name == geneA & fusion_reads$geneB.name == geneB, ]

if( nrow(fusion_reads.top) !=0 ) {
    kable(fusion_reads.top, row.names = FALSE, caption = paste0("Number of reads supporting ", paste(geneA, geneB, sep="-"), " fusion")) %>%
    kable_styling(font_size = 12, "striped", "bordered") %>%
    scroll_box(width = "100%")
}
```

***

##### Fusion genes expression {.tabset}

mRNA expression levels of fusion genes detected in patient's sample and their average mRNA expression (Z-score) in samples from cancer and healthy individuals.

```{r fusion_5_cdf_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 2.5, eval = runPizzlyChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
cdfPlot(gene = geneA, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode)
cdfPlot(gene = geneB, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = FALSE, plot_mode = params$plots_mode)

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

###### Z-scores

```{r fusion_5_gene_table, comment = NA, message=FALSE, warning=FALSE, eval = runPizzlyChunk}
fusion.df <- ref_datasets.list[[tissue]][["gene_annot"]]
fusion.df <- rbind(fusion.df[fusion.df$SYMBOL==geneA, ], fusion.df[fusion.df$SYMBOL==geneB, ])
genes = fusion.df$SYMBOL
  
  
exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "z")[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The **Patient vs `r cancer_group`** column illustrates the difference between Z-scores in patient sample and cohort of healthy individuals for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. TSG - tumour suppressor gene; SD - standard deviation across groups
</font>
</details>

***

###### Percentiles

```{r fusion_5_gene_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = runPizzlyChunk}
exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Germline") ], fusion_genes = unique(known_translocations$geneA, known_translocations$geneB ), ext_links = TRUE, type = "perc")[[1]]
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The **Patient vs `r cancer_group`** column illustrates the difference between percentiles in patient sample and cohort of healthy individuals for each fusion gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. TSG - tumour suppressor gene; SD - standard deviation across groups
</font>
</details>

***

## Structural variants

mRNA expression levels of genes located within detected structural variants (SVs), obtained from [Manta](https://github.com/Illumina/manta){target="_blank"} structural variant caller, in patient's sample and their average mRNA expression in samples from cancer and healthy individuals.

SVs information for this sample is **`r if ( runSVsChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**. 

### - Summary table {.tabset}

Out of the `r if ( runSVsChunk ) { length(unique(manta_sv$gene)) } ` genes affected by `r if ( runSVsChunk ) { nrow(manta_sv) }` SVs, the expression of **`r if ( runSVsChunk ) { length(which(unique(manta_sv$gene) %in% rownames(ref_datasets.list[[tissue]][["combined_data_processed"]]))) }`** was reliably measured in patient's sample. The remaining `r if ( runSVsChunk ) { length(which(unique(manta_sv$gene) %!in% rownames(ref_datasets.list[[tissue]][["combined_data_processed"]]))) }` genes are either not expressed or their expression level is too low to be detected (indicated in <span style="color:#808080">BLANK</span> cells with missing values).

#### Z-scores

```{r sv_genes_table, comment = NA, message=FALSE, warning=FALSE, eval = runSVsChunk}
##### Generate expression summary table for cancer genes from OncoKB and PMCC
targets <- ref_datasets.list[[tissue]][["sample_annot"]]
data <- ref_datasets.list[[tissue]][["combined_data_processed"]]

##### Consider only genes with mutations calssified within Tiers 1-3
genes <- unique(manta_sv$gene)

##### Deal with no genes
if ( length(genes) == 0 ) {
  
  genes <- NULL
}

sv_genes.expr.z <- exprTable( genes = genes, data = data, sv_data = manta_sv[ , names(manta_sv) %!in% "lof" ], targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "z")

##### Present the expression summary table
sv_genes.expr.z[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=sv_genes.expr.z[[1]], file=paste(exprTableDir, "sv_genes.expr.z.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The **Patient vs `r cancer_group`** column illustrates the difference between Z-scores in patient sample and cohort of healthy individuals for each gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **increasing SV score** and then by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. TSG - tumour suppressor gene; SD - standard deviation across groups

**Score**: SV priority score based on AstraZeneca [simple_sv_annotation.py](https://github.com/AstraZeneca-NGS/simple_sv_annotation/blob/master/simple_sv_annotation.py#L21-L36){target="_blank"} script; **1 = high** and **3 = low priority**

</font>
</details>

***

#### Percentiles

```{r sv_genes_table_perc, comment = NA, message=FALSE, warning=FALSE, eval = runSVsChunk}
##### Generate expression summary table for cancer genes from OncoKB and PMCC
sv_genes.expr.perc <- exprTable( genes = genes, data = data, sv_data = manta_sv[ , names(manta_sv) %!in% "lof" ], targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "perc")

##### Present the expression summary table
sv_genes.expr.perc[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=sv_genes.expr.perc[[1]], file=paste(exprTableDir, "sv_genes.expr.perc.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The **Patient vs `r cancer_group`** column illustrates the difference between percentiles in patient sample and cohort of healthy individuals for each gene. Genes considered to be oncogenes or tumour suppressor genes, according to [OncoKB](http://oncokb.org/#/cancerGenes){target="_blank"} database, are also indicated. Genes are ordered by **increasing SV score** and then by **decreasing** absolute values in the **Patient vs `r cancer_group`** columns. TSG - tumour suppressor gene; SD - standard deviation across groups

**Score**: SV priority score based on AstraZeneca [simple_sv_annotation.py](https://github.com/AstraZeneca-NGS/simple_sv_annotation/blob/master/simple_sv_annotation.py#L21-L36) script; *1 = high* and *3 = low priority*

</font>
</details>

***

### - Expression profiles {.tabset}

Expression profiles for 10 SVs-affected genes with the highest priority (low [score](https://github.com/AstraZeneca-NGS/simple_sv_annotation/blob/master/simple_sv_annotation.py#L21-L36){target="_blank"}) and demonstrating the greatest difference in standarised (Z-score) mRNA expression values between patient's sample and the average mRNA expression in samples from healthy individuals.

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[1]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[1] }`

```{r cdf_plot_sv_genes_1, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[1]

if ( !is.na(gene) && gene %in% rownames(data) ) {
  ##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[2]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[2] }`

```{r cdf_plot_sv_genes_2, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[2]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[3]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[3] }`

```{r cdf_plot_sv_genes_3, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[3]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[4]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[4] }`

```{r cdf_plot_sv_genes_4, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[4]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[5]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[5] }`

```{r cdf_plot_sv_genes_5, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[5]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[6]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[6] }`

```{r cdf_plot_sv_genes_6, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[6]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[7]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[7] }`

```{r cdf_plot_sv_genes_7, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[7]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[7]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[8] }`

```{r cdf_plot_sv_genes_8, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[8]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[9]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[9] }`

```{r cdf_plot_sv_genes_9, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[9]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r if ( runSVsChunk && !is.na(unique(sv_genes.expr.z[[2]]$SYMBOL)[10]) ) { unique(sv_genes.expr.z[[2]]$SYMBOL)[10] }`

```{r cdf_plot_sv_genes_10, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runSVsChunk}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- unique(sv_genes.expr.z[[2]]$SYMBOL)[10]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(unique(sv_genes.expr.z[[2]]$SYMBOL)), "genes affected by detected SVs!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

## CN altered genes

Section overlaying the mRNA expression data with per-gene somatic copy-number (CN) data (from [PURPLE](https://anaconda.org/bioconda/hmftools-purple){target="_blank"}) and mutation status, if available.

CN information this sample is **`r if ( runPurpleChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**.

### - Expression vs CN

Scatterplot comparing the per-gene difference in **mRNA expression** (Z-scores) between patient's sample and cancer individuals (*y-axis*), **CN values** (*x-axis*, from [PURPLE](https://anaconda.org/bioconda/hmftools-purple){target="_blank"}). If the mutation status information is available then the genes's colours correspond to the variant(s) consequence (from [PCGR](https://github.com/sigven/pcgr){target="_blank"}). Genes with CN values > 3 or < 0.5 are annotated. NOTE: only [Cancer genes], [Mutated genes] with [tier 1-3](https://pcgr.readthedocs.io/en/latest/tier_systems.html#tier-model-2-pcgr-acmg){target="_blank"} variants (if mutation information is available), genes involved in [Fusion genes] and [Structural variants] (if SV information is available) are presented.

```{r mut_cn_expr_data_plot, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
##### Generate scatterplot with per-gene expression values (y-axis), CN values (x-axis) and mutation status info (colours)
suppressMessages(library(plotly))

data <- ref_datasets.list[[tissue]][["expr_mut_cn_data"]]

##### Limit the data to include only cancer genes
cn_genes <- as.vector(data$Gene[ data$Gene %in% rownames(ref_genes.list[["genes_cancer"]]) ])

##### Add fusion genes
cn_genes <- c( unique(cn_genes, pizzly.fusions.cut$geneA.name) )
cn_genes <- c( unique(cn_genes, pizzly.fusions.cut$geneB.name) )
            
##### Add genes involved in SVs
cn_genes <- c( unique(cn_genes, unique(manta_sv$gene)) )

if ( runPcgrChunk && length(cn_genes) > 0 ) {
  
  ##### Add mutated genes with vatiants tier 1-3
  cn_genes <- c( unique(cn_genes, ref_genes.list[["pcgr"]][ ref_genes.list[["pcgr"]]$TIER %in% c("1", "2", "3" ), ]$SYMBOL) )
  data <- data[ data$Gene %in% cn_genes, ]
 
  mutCNexprPlot(data = data, mut_data = TRUE, cn_bottom = 0.5, cn_top = 3, cancer = cancer_group, plot_mode = params$plots_mode)
  
} else if ( length(cn_genes) > 0) {
  
  data <- data[ data$Gene %in% cn_genes, ]
  mutCNexprPlot(data = data, mut_data = FALSE, cn_bottom = 0.5, cn_top = 3, cancer = cancer_group, plot_mode = params$plots_mode)
  
} else {
  
  cn_genes <- NULL
  cat("None of the genes of interest are affected by changes in CN.")
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

### - Summary table {.tabset}

Out of the `r length(ref_datasets.list[[tissue]][["expr_mut_cn_data"]][,1])` genes within gained (CN values > `r params$cn_gain`) or lossed (CN values < `r params$cn_loss`) regions `r if (runPurpleChunk) { length(cn_genes) } else { length(NULL) }` are either [Cancer genes], [Mutated genes] with [tier 1-3](https://pcgr.readthedocs.io/en/latest/tier_systems.html#tier-model-2-pcgr-acmg){target="_blank"} variants (if mutation information is available) or are involved in [Fusion genes] or [Structural variants] (if SV information is available). The expression of **`r if (runPurpleChunk) { length(which(cn_genes %in% rownames(ref_datasets.list[[tissue]][["combined_data_processed"]]))) } else { length(NULL) }`** of these genes was reliably measured in patient's sample. The remaining `r if (runPurpleChunk) { length(which(cn_genes %!in% rownames(ref_datasets.list[[tissue]][["combined_data_processed"]]))) } else { length(NULL) }` genes are either not expressed or their expression level is too low to be detected (indicated in <span style="color:#808080">BLANK</span> cells with missing values).

#### Gains {.tabset}

Table summarising the **mRNA expression** values in normal, cancer and patient samples for genes with **CN** values > `r params$cn_gain` (**gains**), based on patient's genomic data (from [PURPLE](https://anaconda.org/bioconda/hmftools-purple){target="_blank"}), and mutation status if available (from [PCGR](https://github.com/sigven/pcgr){target="_blank"}).

##### Z-scores

```{r mut_cn_expr_data_table_gains, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
##### Generate expression summary table for per-gene expression values CN values and mutation status info (colours)
##### Keep only genes within CN gains
cn_data <- ref_datasets.list[[tissue]][["expr_mut_cn_data"]]
cn_data <- cn_data[ cn_data$CN > params$cn_gain, ]
cn_data <- cn_data[, "CN", drop=FALSE]
genes = cn_genes[ cn_genes %in% rownames(cn_data) ]

##### Get expression data
data <- ref_datasets.list[[tissue]][["combined_data_processed"]]

if ( runPcgrChunk && runPurpleChunk ) {
    
  mut_cn_expr_genes.expr.gains.z <- exprTable( genes = genes, data = data, cn_data = cn_data, cn_decrease = TRUE, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], mut_annot = ref_genes.list[["pcgr"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "z")
  
##### Generate expression summary table for per-gene expression values and CN values
} else if ( runPurpleChunk ) {
    
  mut_cn_expr_genes.expr.gains.z <- exprTable( genes = genes, data = data, cn_data = cn_data, cn_decrease = TRUE, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "z")
}
  
##### Present the expression, CN and mutation data summary table
mut_cn_expr_genes.expr.gains.z[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=mut_cn_expr_genes.expr.gains.z[[1]], file=paste(exprTableDir, "mut_cn_expr_genes.expr.gains.z.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Patient vs `r cancer_group`** column illustrates the difference between Z-scores in patient sample and cohort of healthy individuals for each gene. The **CN values** based on patient's genomic data are presented in *Patient (CN)* column with a horizontal blue bar indicating the CN value of each gene in the context of other genes. If mutation data is availbale, then the variants tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided on right-hand side based on information from [PCGR](https://github.com/sigven/pcgr){target="_blank"} report (similar to [Mutated genes] section). Genes are ordered by **Patient (CN)** and then by **decreasing** absolute values in the **Patient vs `r cancer_group`** columns. SD - standard deviation across groups; CN - copy-number
</font>
</details>

***

##### Percentiles

```{r mut_cn_expr_data_table_gains_perc, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Generate expression summary table for per-gene expression values CN values and mutation status info (colours)
if ( runPcgrChunk && runPurpleChunk ) {
    
  mut_cn_expr_genes.expr.gains.perc <- exprTable( genes = genes, data = data, cn_data = cn_data, cn_decrease = TRUE, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], mut_annot = ref_genes.list[["pcgr"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "perc")
  
##### Generate expression summary table for per-gene expression values and CN values
} else if ( runPurpleChunk ) {
  
  mut_cn_expr_genes.expr.gains.perc <- exprTable( genes = genes, data = data, cn_data = cn_data, cn_decrease = TRUE, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "perc")
}
  
##### Present the expression, CN and mutation data summary table
mut_cn_expr_genes.expr.gains.perc[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=mut_cn_expr_genes.expr.gains.perc[[1]], file=paste(exprTableDir, "mut_cn_expr_genes.expr.gains.perc.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Patient vs `r cancer_group`** column illustrates the difference between percentiles in patient sample and cohort of healthy individuals for each gene. The **CN values** based on patient's genomic data are presented in *Patient (CN)* column with a horizontal blue bar indicating the CN value of each gene in the context of other genes. If mutation data is availbale, then the variants tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided on right-hand side based on information from [PCGR](https://github.com/sigven/pcgr){target="_blank"} report (similar to [Mutated genes] section). Genes are ordered by **Patient (CN)** and then by **decreasing** absolute values in the **Patient vs `r cancer_group`** columns. SD - standard deviation across groups; CN - copy-number
</font>
</details>

***

#### Losses {.tabset}

Table summarising the **mRNA expression** values in normal, cancer and patient samples for genes with **CN** values < `r params$cn_loss` (**losses**), based on patient's genomic data (from [PURPLE](https://anaconda.org/bioconda/hmftools-purple){target="_blank"}), and mutation status if available (from [PCGR](https://github.com/sigven/pcgr){target="_blank"}).

##### Z-scores

```{r mut_cn_expr_data_table_losses, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Generate expression summary table for per-gene expression values CN values and mutation status info (colours)
##### Keep only genes within CN losses
cn_data <- ref_datasets.list[[tissue]][["expr_mut_cn_data"]]
cn_data <- cn_data[ cn_data$CN < params$cn_loss, ]
cn_data <- cn_data[, "CN", drop=FALSE]
genes = cn_genes[ cn_genes %in% rownames(cn_data) ]

##### Get expression data
data <- ref_datasets.list[[tissue]][["combined_data_processed"]]
    
if ( runPcgrChunk && runPurpleChunk ) {
    
  mut_cn_expr_genes.expr.losses.z <- exprTable( genes = genes, data = data, cn_data = cn_data, cn_decrease = FALSE, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], mut_annot = ref_genes.list[["pcgr"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "z")
  
##### Generate expression summary table for per-gene expression values and CN values
} else if ( runPurpleChunk ) {
    
  mut_cn_expr_genes.expr.losses.z <- exprTable( genes = genes, data = data, cn_data = cn_data, cn_decrease = FALSE, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "z")
}
  
##### Present the expression, CN and mutation data summary table
mut_cn_expr_genes.expr.losses.z[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=mut_cn_expr_genes.expr.losses.z[[1]], file=paste(exprTableDir, "mut_cn_expr_genes.expr.losses.z.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Patient vs `r cancer_group`** column illustrates the difference between Z-scores in patient sample and cohort of healthy individuals for each gene. The **CN values** based on patient's genomic data are presented in *Patient (CN)* column with a horizontal blue bar indicating the CN value of each gene in the context of other genes. If mutation data is availbale, then the variants tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided on right-hand side based on information from [PCGR](https://github.com/sigven/pcgr){target="_blank"} report (similar to [Mutated genes] section). Genes are ordered by **Patient (CN)** and then by **decreasing** absolute values in the **Patient vs `r cancer_group`** columns. SD - standard deviation across groups; CN - copy-number
</font>
</details>

***

##### Percentiles

```{r mut_cn_expr_data_table_losses_perc, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Generate expression summary table for per-gene expression values CN values and mutation status info (colours)
if ( runPcgrChunk && runPurpleChunk ) {
    
  mut_cn_expr_genes.expr.losses.perc <- exprTable( genes = genes, data = data, cn_data = cn_data, cn_decrease = FALSE, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], mut_annot = ref_genes.list[["pcgr"]][, c("SYMBOL", "TIER", "CONSEQUENCE", "VARIANT_CLASS", "AF_TUMOR", "GENOMIC_CHANGE", "PROTEIN_CHANGE")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "perc")
  
##### Generate expression summary table for per-gene expression values and CN values
} else if ( runPurpleChunk ) {
  
  mut_cn_expr_genes.expr.losses.perc <- exprTable( genes = genes, data = data, cn_data = cn_data, cn_decrease = FALSE, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], cancer_genes = ref_genes.list[["genes_cancer"]][, c("Oncogene", "TSG", "Fusion", "Germline") ], ext_links = TRUE, type = "perc")
}
  
##### Present the expression, CN and mutation data summary table
mut_cn_expr_genes.expr.losses.perc[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=mut_cn_expr_genes.expr.losses.perc[[1]], file=paste(exprTableDir, "mut_cn_expr_genes.expr.losses.perc.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Patient vs `r cancer_group`** column illustrates the difference between percentiles in patient sample and cohort of healthy individuals for each gene. The **CN values** based on patient's genomic data are presented in *Patient (CN)* column with a horizontal blue bar indicating the CN value of each gene in the context of other genes. If mutation data is availbale, then the variants tier, consequence, class and tumour allele freuqnecy (AF), as well as genomic and protein change are also provided on right-hand side based on information from [PCGR](https://github.com/sigven/pcgr){target="_blank"} report (similar to [Mutated genes] section). Genes are ordered by **Patient (CN)** and then by **decreasing** absolute values in the **Patient vs `r cancer_group`** columns. SD - standard deviation across groups; CN - copy-number
</font>
</details>

***

### - Expression profiles {.tabset}

Expression profiles for 5 genes with the highest (**gains**) and 5 genes with the lowest (**losses**) CN values and the greatest difference in standarised (Z-score) mRNA expression values between patient's sample and the average mRNA expression in samples from healthy individuals.

#### Gains {.tabset}

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL)[1]) ) { mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[1] }`

```{r cdf_plot_mut_cn_expr_gains_genes_1, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[1]
  
##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL), "genes mapped to detected gained regions!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL)[2]) ) { mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[2] }`

```{r cdf_plot_mut_cn_expr_gains_genes_2, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[2]
  
##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL), "genes mapped to detected gained regions!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL)[3]) ) { mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[3] }`

```{r cdf_plot_mut_cn_expr_gains_genes_3, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[3]
  
##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL), "genes mapped to detected gained regions!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL)[4]) ) { mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[4] }`

```{r cdf_plot_mut_cn_expr_gains_genes_4, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[4]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL), "genes mapped to detected gained regions!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL)[5]) ) { mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[5] }`

```{r cdf_plot_mut_cn_expr_gains_genes_5, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL[5]
  
##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL), "genes mapped to detected gained regions!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### Losses {.tabset}

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL)[1]) ) { mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[1] }`

```{r cdf_plot_mut_cn_expr_losses_genes_1, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[1]
  
##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL), "genes mapped to detected lossed regions!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL)[2]) ) { mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[2] }`

```{r cdf_plot_mut_cn_expr_losses_genes_2, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[2]
  
##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL), "genes mapped to detected lossed regions!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL)[3]) ) { mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[3] }`

```{r cdf_plot_mut_cn_expr_losses_genes_3, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[3]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL), "genes mapped to detected lossed regions!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL)[4]) ) { mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[4] }`

```{r cdf_plot_mut_cn_expr_losses_genes_4, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[4]
  
##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL), "genes mapped to detected lossed regions!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

##### `r if ( runPurpleChunk && !is.na(unique(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL)[5]) ) { mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[5] }`

```{r cdf_plot_mut_cn_expr_losses_genes_5, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3, eval = runPurpleChunk}
suppressMessages(library(plotly))

##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL[5]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL), "genes mapped to detected lossed regions!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

## Immune markers

Section presenting expression levels of immune markers to assess pre-existing anti-cancer immunity and likelihood of response to immunotherapy. Their mRNA expression levels are presented in patient's sample along their average mRNA expression in samples from cancer and healthy individuals.

Out of the `r length(unique(unlist(ref_genes.list[["genes_immune"]]$SYMBOL)))` immune markers the expression of **`r length(which(unique(unlist(ref_genes.list[["genes_immune"]]$SYMBOL)) %in% rownames(ref_datasets.list[[tissue]][["combined_data_processed"]])))`** was reliably measured in patient's sample. The remaining `r length(which(unique(unlist(ref_genes.list[["genes_immune"]]$SYMBOL)) %!in% rownames(ref_datasets.list[[tissue]][["combined_data_processed"]])))` genes are either not expressed or their expression level is too low to be detected (indicated in <span style="color:#808080">BLANK</span> cells with missing values).

### - Summary table {.tabset}

#### Z-scores

```{r immune_genes_table, comment = NA, message=FALSE, warning=FALSE}
##### Generate expression summary table for cancer genes from OncoKB and PMCC
targets <- ref_datasets.list[[tissue]][["sample_annot"]]
data <- ref_datasets.list[[tissue]][["combined_data_processed"]]
genes <- unique(unlist(ref_genes.list[["genes_immune"]]$SYMBOL))

##### Deal with no genes
if ( length(genes) == 0 ) {
  
  genes <- NULL
}

immune_genes.expr.z <- exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL", "Immune_Cycle_Role")], ext_links = TRUE, type = "z")

##### Present the expression summary table
immune_genes.expr.z[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=immune_genes.expr.z[[1]], file=paste(exprTableDir, "immune_genes.expr.z.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Patient vs `r cancer_group`** column illustrates the difference between Z-scores in patient sample and cohort of healthy individuals for each immune marker. Genes are ordered by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. SD - standard deviation across groups
</font>
</details>

***

#### Percentiles

```{r immune_genes_table_perc, comment = NA, message=FALSE, warning=FALSE}
##### Generate expression summary table for cancer genes from OncoKB and PMCC
immune_genes.expr.perc <- exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL", "Immune_Cycle_Role")], ext_links = TRUE, type = "perc")

##### Present the expression summary table
immune_genes.expr.perc[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=immune_genes.expr.perc[[1]], file=paste(exprTableDir, "immune_genes.expr.perc.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Patient vs `r cancer_group`** column illustrates the difference between percentiles in patient sample and cohort of healthy individuals for each immune marker. Genes are ordered by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. TSG - tumour suppressor gene; SD - standard deviation across groups
</font>
</details>

***

### - Expression profiles {.tabset}

Expression profiles for 10 immune markers with the greatest difference in standarised (Z-score) mRNA expression values between patient's sample and the average mRNA expression in samples from healthy individuals.

#### `r immune_genes.expr.z[[2]]$SYMBOL[1]`

```{r cdf_plot_immune_genes_1, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- immune_genes.expr.z[[2]]$SYMBOL[1]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(immune_genes.expr.z[[2]]$SYMBOL), "immune marker(s) detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r immune_genes.expr.z[[2]]$SYMBOL[2]`

```{r cdf_plot_immune_genes_2, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- immune_genes.expr.z[[2]]$SYMBOL[2]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(immune_genes.expr.z[[2]]$SYMBOL), "immune marker(s) detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}
##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r immune_genes.expr.z[[2]]$SYMBOL[3]`

```{r cdf_plot_immune_genes_3, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- immune_genes.expr.z[[2]]$SYMBOL[3]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(immune_genes.expr.z[[2]]$SYMBOL), "immune marker(s) detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r immune_genes.expr.z[[2]]$SYMBOL[4]`

```{r cdf_plot_immune_genes_4, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- immune_genes.expr.z[[2]]$SYMBOL[4]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(immune_genes.expr.z[[2]]$SYMBOL), "immune marker(s) detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r immune_genes.expr.z[[2]]$SYMBOL[5]`

```{r cdf_plot_immune_genes_5, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- immune_genes.expr.z[[2]]$SYMBOL[5]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(immune_genes.expr.z[[2]]$SYMBOL), "immune marker(s) detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r immune_genes.expr.z[[2]]$SYMBOL[6]`

```{r cdf_plot_immune_genes_6, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- immune_genes.expr.z[[2]]$SYMBOL[6]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(immune_genes.expr.z[[2]]$SYMBOL), "immune marker(s) detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r immune_genes.expr.z[[2]]$SYMBOL[7]`

```{r cdf_plot_immune_genes_7, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- immune_genes.expr.z[[2]]$SYMBOL[7]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(immune_genes.expr.z[[2]]$SYMBOL), "immune marker(s) detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r immune_genes.expr.z[[2]]$SYMBOL[8]`

```{r cdf_plot_immune_genes_8, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- immune_genes.expr.z[[2]]$SYMBOL[8]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)
  
} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(immune_genes.expr.z[[2]]$SYMBOL), "immune marker(s) detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r immune_genes.expr.z[[2]]$SYMBOL[9]`

```{r cdf_plot_immune_genes_9, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- immune_genes.expr.z[[2]]$SYMBOL[9]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(immune_genes.expr.z[[2]]$SYMBOL), "immune marker(s) detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

#### `r immune_genes.expr.z[[2]]$SYMBOL[10]`

```{r cdf_plot_immune_genes_10, comment = NA, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 3}
suppressMessages(library(plotly))
##### Generate empirical cumulative distribution function (ECDF) plot illustrating mRNA expression level the genes of interest in the context of the overall mRNA expression distribution
gene <- immune_genes.expr.z[[2]]$SYMBOL[10]

##### Generate CDF plot and add boxplot below to show the data variance for selected gene in individual groups
if ( !is.na(gene) && gene %in% rownames(data) ) {
  cdfPlot(gene = gene, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group, cancer = cancer_group, addBoxPlot = TRUE, plot_mode = params$plots_mode)

} else {
  if ( is.na(gene) ) {
    cat(paste("There are", length(immune_genes.expr.z[[2]]$SYMBOL), "immune marker(s) detected!", sep=" "))
  } else if ( gene %!in% rownames(data) ) {
    cat(paste("No expression data is available for", gene, "!", sep=" "))
  }
}

##### Detach plotly package. Otherwise it clashes with other graphics devices
detach("package:plotly", unload=FALSE)
```

***

## HRD genes

Section presenting expression levels of homologous recombination deficiency (HRD) genes to assess how many of these demonstrate low expression, which may indicate potential promoter methylation events. Their mRNA expression levels are presented in patient's sample along their average mRNA expression in samples from cancer and healthy individuals.

Out of the `r length(unique(unlist(ref_genes.list[["genes_hrd"]]$SYMBOL)))` hrd genes the expression of **`r length(which(unique(unlist(ref_genes.list[["genes_hrd"]]$SYMBOL)) %in% rownames(ref_datasets.list[[tissue]][["combined_data_processed"]])))`** was reliably measured in patient's sample. The remaining `r length(which(unique(unlist(ref_genes.list[["genes_hrd"]]$SYMBOL)) %!in% rownames(ref_datasets.list[[tissue]][["combined_data_processed"]])))` genes are either not expressed or their expression level is too low to be detected (indicated in <span style="color:#808080">BLANK</span> cells with missing values).

### - Summary table {.tabset}

#### Z-scores

```{r hrd_genes_table, comment = NA, message=FALSE, warning=FALSE}
##### Generate expression summary table for hrd genes from Richqrd
targets <- ref_datasets.list[[tissue]][["sample_annot"]]
data <- ref_datasets.list[[tissue]][["combined_data_processed"]]
genes <- unique(unlist(ref_genes.list[["genes_hrd"]]$SYMBOL))

##### Deal with no genes
if ( length(genes) == 0 ) {
  
  genes <- NULL
}

hrd_genes.expr.z <- exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], ext_links = TRUE, type = "z")

##### Present the expression summary table
hrd_genes.expr.z[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=hrd_genes.expr.z[[1]], file=paste(exprTableDir, "hrd_genes.expr.z.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (Z-score) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (Z-score) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Patient vs `r cancer_group`** column illustrates the difference between Z-scores in patient sample and cohort of healthy individuals for each HRD gene. Genes are ordered by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. SD - standard deviation across groups
</font>
</details>

***

#### Percentiles

```{r hrd_genes_table_perc, comment = NA, message=FALSE, warning=FALSE}
##### Generate expression summary table for hrd genes from Richard
hrd_genes.expr.perc <- exprTable( genes = genes, data = data, targets = targets, sampleName = params$sample_name, normal = normal_group , cancer = cancer_group, genes_annot = ref_datasets.list[[tissue]][["gene_annot_all"]][, c("SYMBOL", "ENSEMBL")], ext_links = TRUE, type = "perc")

##### Present the expression summary table
hrd_genes.expr.perc[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=hrd_genes.expr.perc[[1]], file=paste(exprTableDir, "hrd_genes.expr.perc.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
The <span style="color:#ff0000">RED</span> colour range indicate relatively **high expression** (percentile) values and <span style="color:#0000ff">BLUE</span> colour range indicate relatively **low expression** (percentile) values in individual sample group. The <span style="color:#808080">BLANK</span> cells with missing values indicate genes with **no/low expression**. The **Patient vs `r cancer_group`** column illustrates the difference between percentiles in patient sample and cohort of healthy individuals for each HRD gene. Genes are ordered by **decreasing** absolute values in the **Patient vs `r cancer_group`** column. TSG - tumour suppressor gene; SD - standard deviation across groups
</font>
</details>

***

## Drug matching

List of drugs targeting variants in detected [Mutated genes], dysregulated [Cancer genes], [Fusion genes], [Structural variants]-affected genes and [CN altered genes], which can be considered in the treatment decision making process. The clinically actionable aberrations are matched based on information provided by *[clinical interpretations of variants in Cancer](https://civicdb.org/home){target="_blank"}* (CIViC) ([Griffith et al. (2017)](https://www.ncbi.nlm.nih.gov/pubmed/28138153){target="_blank"}). The evidence pertaining to variants effect on therapeutic response is also provided.

### - Mutated genes

Mutation data for this sample is **`r if ( runPcgrChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**.

**`r length(unique(ref_genes.list[["pcgr"]][ ref_genes.list[["pcgr"]]$TIER %in% c("1", "2", "3" ), ]$SYMBOL))`** genes with PCGR [tier 1-3](https://pcgr.readthedocs.io/en/latest/tier_systems.html#tier-model-2-pcgr-acmg){target="_blank"} variants were screened for suitable drugs (see [Mutated genes] section).

```{r drugs_predictive_mut_genes, comment = NA, message=FALSE, warning=FALSE, eval = runPcgrChunk}
##### Generate table with drugs targeting mutated cancer genes
genes <- mut_genes.expr.z[[2]]$SYMBOL

drugsTable.mut_genes <- civicDrugTable(genes, civic_var_summaries = caner_genes_annot.list[["civic_var_summaries"]], civic_clin_evid = caner_genes_annot.list[["civic_clin_evid"]],  evid_type = "Predictive", var_type = "mutation")

drugsTable.mut_genes[[1]]

##### Create directory for tables
drugsTableDir <- paste(params$report_dir, "drugsTables", sep = "/")

if ( !file.exists(drugsTableDir) ) {

        dir.create(drugsTableDir, recursive=TRUE)
}

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=drugsTable.mut_genes[[1]], file=paste(drugsTableDir, "drugsTable.mut_genes.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
**[Evidence Level](https://civicdb.org/help/evidence/evidence-levels){target="_blank"}**

* **A - Validated association**: Proven/consensus association in human medicine
* **B - Clinical evidence**: Clinical trial or other primary patient data supports association
* **C - Case study**: Individual case reports from clinical journals
* **D - Preclinical evidence**: *In vivo* or *in vitro* models support association
* **E - Inferential association**: Indirect evidence

**[Trust Rating](https://civicdb.org/help/evidence/trust-ratings){target="_blank"}**

* **5**: Strong, well supported evidence from a lab or journal with respected academic standing. Experiments are well controlled, and results are clean and reproducible across multiple replicates. Evidence confirmed using independent methods. The study is statistically well powered
* **4**: Strong, well supported evidence. Experiments are well controlled, and results are convincing. Any discrepancies from expected results are well-explained and not concerning
* **3**: Evidence is convincing, but not supported by a breadth of experiments. May be smaller scale projects, or novel results without many follow-up experiments. Discrepancies from expected results are explained and not concerning
* **2**: Evidence is not well supported by experimental data, and little follow-up data is available. Publication is from a journal with low academic impact. Experiments may lack proper controls, have small sample size, or are not statistically convincing
* **1**: Claim is not supported well by experimental evidence. Results are not reproducible, or have very small sample size. No follow-up is done to validate novel claims

**[Actionability Score ](https://civicdb.org/help/variants/actionability-score){target="_blank"}**

* [CIViC Actionability Score](https://civicdb.org/help/variants/actionability-score){target="_blank"} allows to assess the accumulation of evidence for each variant. It is calculated by adding all Evidence Item Scores for each variant. The Evidence Item Score is calculated by multiplying the evidence level (A=10 points, B=5 points, C=3 points, D=1 point, E=0.25 points) by the trust rating (each Star = 1 point).
</font> 
</details>

***

### - Cancer genes

**50** cancer genes with the greatest difference in standarised (Z-score) mRNA expression values between patient's sample and the average mRNA expression in samples from healthy individuals were screened for suitable drugs (see [Cancer genes] section).

```{r drugs_predictive_cancer_genes, comment = NA, message=FALSE, warning=FALSE}
##### Generate table with drugs targeting dysregulated cancer genes
data <- ref_datasets.list[[tissue]][["combined_data_processed"]]
genes <- cancer_genes.expr.z[[2]]$SYMBOL[1:50]

drugsTable.cancer_genes <- civicDrugTable(genes, civic_var_summaries  = caner_genes_annot.list[["civic_var_summaries"]], civic_clin_evid  = caner_genes_annot.list[["civic_clin_evid"]],  evid_type = "Predictive", var_type = "expression")

drugsTable.cancer_genes[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=drugsTable.cancer_genes[[1]], file=paste(drugsTableDir, "drugsTable.cancer_genes.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
**[Evidence Level](https://civicdb.org/help/evidence/evidence-levels){target="_blank"}**

* **A - Validated association**: Proven/consensus association in human medicine
* **B - Clinical evidence**: Clinical trial or other primary patient data supports association
* **C - Case study**: Individual case reports from clinical journals
* **D - Preclinical evidence**: *In vivo* or *in vitro* models support association
* **E - Inferential association**: Indirect evidence

**[Trust Rating](https://civicdb.org/help/evidence/trust-ratings){target="_blank"}**

* **5**: Strong, well supported evidence from a lab or journal with respected academic standing. Experiments are well controlled, and results are clean and reproducible across multiple replicates. Evidence confirmed using independent methods. The study is statistically well powered
* **4**: Strong, well supported evidence. Experiments are well controlled, and results are convincing. Any discrepancies from expected results are well-explained and not concerning
* **3**: Evidence is convincing, but not supported by a breadth of experiments. May be smaller scale projects, or novel results without many follow-up experiments. Discrepancies from expected results are explained and not concerning
* **2**: Evidence is not well supported by experimental data, and little follow-up data is available. Publication is from a journal with low academic impact. Experiments may lack proper controls, have small sample size, or are not statistically convincing
* **1**: Claim is not supported well by experimental evidence. Results are not reproducible, or have very small sample size. No follow-up is done to validate novel claims

**[Actionability Score ](https://civicdb.org/help/variants/actionability-score){target="_blank"}**

* [CIViC Actionability Score](https://civicdb.org/help/variants/actionability-score){target="_blank"} allows to assess the accumulation of evidence for each variant. It is calculated by adding all Evidence Item Scores for each variant. The Evidence Item Score is calculated by multiplying the evidence level (A=10 points, B=5 points, C=3 points, D=1 point, E=0.25 points) by the trust rating (each Star = 1 point).
</font> 
</details>

***

### - Fusion genes {.tabset}

<span style="color:#ff0000">**`r nrow(pizzly.fusions.cut[ pizzly.fusions.cut$geneA_dna_support == "Yes" | pizzly.fusions.cut$geneB_dna_support == "Yes" , ])`**</span> involving **DNA-supported** fusion genes (see [Structural variants] section) and <span style="color:#02d653">**`r nrow(pizzly.fusions.cut[ pizzly.fusions.cut$reported_fusion == "Yes" , ])`**</span> gene fusions **reported in [FusionGDB](https://ccsm.uth.edu/FusionGDB){target="_blank"}** were screened for suitable drugs.

```{r drugs_predictive_fusion_genes, comment = NA, message=FALSE, warning=FALSE}
##### Generate table with drugs targeting fusion genes
data <- ref_datasets.list[[tissue]][["combined_data_processed"]]
genesA <- as.vector(pizzly.fusions[ fusion_annot$reported_fusion == "Yes" | fusion_annot$geneA_dna_support == "Yes" | fusion_annot$geneB_dna_support == "Yes", ]$geneA.name)
genesB <- as.vector(pizzly.fusions[ fusion_annot$reported_fusion == "Yes" | fusion_annot$geneA_dna_support == "Yes" | fusion_annot$geneB_dna_support == "Yes", ]$geneB.name)

drugsTable.fusion_genes <- civicDrugTable(genes = unique(c(genesA, genesB)), civic_var_summaries  = caner_genes_annot.list[["civic_var_summaries"]], civic_clin_evid  = caner_genes_annot.list[["civic_clin_evid"]],  evid_type = "Predictive", var_type = "fusion")

drugsTable.fusion_genes[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=drugsTable.fusion_genes[[1]], file=paste(drugsTableDir, "drugsTable.fusion_genes.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
**[Evidence Level](https://civicdb.org/help/evidence/evidence-levels){target="_blank"}**

* **A - Validated association**: Proven/consensus association in human medicine
* **B - Clinical evidence**: Clinical trial or other primary patient data supports association
* **C - Case study**: Individual case reports from clinical journals
* **D - Preclinical evidence**: *In vivo* or *in vitro* models support association
* **E - Inferential association**: Indirect evidence

**[Trust Rating](https://civicdb.org/help/evidence/trust-ratings){target="_blank"}**

* **5**: Strong, well supported evidence from a lab or journal with respected academic standing. Experiments are well controlled, and results are clean and reproducible across multiple replicates. Evidence confirmed using independent methods. The study is statistically well powered
* **4**: Strong, well supported evidence. Experiments are well controlled, and results are convincing. Any discrepancies from expected results are well-explained and not concerning
* **3**: Evidence is convincing, but not supported by a breadth of experiments. May be smaller scale projects, or novel results without many follow-up experiments. Discrepancies from expected results are explained and not concerning
* **2**: Evidence is not well supported by experimental data, and little follow-up data is available. Publication is from a journal with low academic impact. Experiments may lack proper controls, have small sample size, or are not statistically convincing
* **1**: Claim is not supported well by experimental evidence. Results are not reproducible, or have very small sample size. No follow-up is done to validate novel claims

**[Actionability Score ](https://civicdb.org/help/variants/actionability-score){target="_blank"}**

* [CIViC Actionability Score](https://civicdb.org/help/variants/actionability-score){target="_blank"} allows to assess the accumulation of evidence for each variant. It is calculated by adding all Evidence Item Scores for each variant. The Evidence Item Score is calculated by multiplying the evidence level (A=10 points, B=5 points, C=3 points, D=1 point, E=0.25 points) by the trust rating (each Star = 1 point).
</font> 
</details>

***

### - Structural variants

SVs information for this sample is **`r if ( runSVsChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**. 

**`r if ( runSVsChunk ) { length(unique(manta_sv$gene)) } else { length(NULL) }`** genes affected by structural variants (SVs) were screened for suitable drugs (see [Structural variants] section).

```{r drugs_predictive_sv_genes, comment = NA, message=FALSE, warning=FALSE, eval = runSVsChunk}
##### Generate table with drugs targeting dysregulated cancer genes
data <- ref_datasets.list[[tissue]][["combined_data_processed"]]
genes <- unique(manta_sv$gene)

drugsTable.sv_genes <- civicDrugTable(genes, civic_var_summaries  = caner_genes_annot.list[["civic_var_summaries"]], civic_clin_evid  = caner_genes_annot.list[["civic_clin_evid"]],  evid_type = "Predictive", var_type = NULL)

drugsTable.sv_genes[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=drugsTable.sv_genes[[1]], file=paste(drugsTableDir, "drugsTable.sv_genes.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
**[Evidence Level](https://civicdb.org/help/evidence/evidence-levels){target="_blank"}**

* **A - Validated association**: Proven/consensus association in human medicine
* **B - Clinical evidence**: Clinical trial or other primary patient data supports association
* **C - Case study**: Individual case reports from clinical journals
* **D - Preclinical evidence**: *In vivo* or *in vitro* models support association
* **E - Inferential association**: Indirect evidence

**[Trust Rating](https://civicdb.org/help/evidence/trust-ratings){target="_blank"}**

* **5**: Strong, well supported evidence from a lab or journal with respected academic standing. Experiments are well controlled, and results are clean and reproducible across multiple replicates. Evidence confirmed using independent methods. The study is statistically well powered
* **4**: Strong, well supported evidence. Experiments are well controlled, and results are convincing. Any discrepancies from expected results are well-explained and not concerning
* **3**: Evidence is convincing, but not supported by a breadth of experiments. May be smaller scale projects, or novel results without many follow-up experiments. Discrepancies from expected results are explained and not concerning
* **2**: Evidence is not well supported by experimental data, and little follow-up data is available. Publication is from a journal with low academic impact. Experiments may lack proper controls, have small sample size, or are not statistically convincing
* **1**: Claim is not supported well by experimental evidence. Results are not reproducible, or have very small sample size. No follow-up is done to validate novel claims

**[Actionability Score ](https://civicdb.org/help/variants/actionability-score){target="_blank"}**

* [CIViC Actionability Score](https://civicdb.org/help/variants/actionability-score){target="_blank"} allows to assess the accumulation of evidence for each variant. It is calculated by adding all Evidence Item Scores for each variant. The Evidence Item Score is calculated by multiplying the evidence level (A=10 points, B=5 points, C=3 points, D=1 point, E=0.25 points) by the trust rating (each Star = 1 point).
</font> 
</details>

***

### - CN altered genes {.tabset}

CN information for this sample is **`r if ( runPurpleChunk ) { c("AVAILABLE") } else { c("NOT AVAILABLE") }`**.

**`r if ( runPurpleChunk ) { length(cn_genes) } else { length(NULL) }`** genes with CN values > `r params$cn_gain` (**gains**) or < `r params$cn_loss` (**losses**, see [CN altered genes] section), and reported as either [Cancer genes], [Mutated genes] with [tier 1-3](https://pcgr.readthedocs.io/en/latest/tier_systems.html#tier-model-2-pcgr-acmg){target="_blank"} variants (if mutation information is available) or involved in [Fusion genes] or [Structural variants] (if SV information is available) were screened for suitable drugs.

#### Gains

```{r drugs_predictive_CN_altered_genes_gains, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Generate table with drugs targeting CN altered genes
genes <- mut_cn_expr_genes.expr.gains.z[[2]]$SYMBOL

drugsTable.CN_altered_genes_gains <- civicDrugTable(genes, civic_var_summaries  = caner_genes_annot.list[["civic_var_summaries"]], civic_clin_evid  = caner_genes_annot.list[["civic_clin_evid"]],  evid_type = "Predictive", var_type = "copy_gain")

drugsTable.CN_altered_genes_gains[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=drugsTable.CN_altered_genes_gains[[1]], file=paste(drugsTableDir, "drugsTable.CN_altered_genes_gains.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
**[Evidence Level](https://civicdb.org/help/evidence/evidence-levels){target="_blank"}**

* **A - Validated association**: Proven/consensus association in human medicine
* **B - Clinical evidence**: Clinical trial or other primary patient data supports association
* **C - Case study**: Individual case reports from clinical journals
* **D - Preclinical evidence**: *In vivo* or *in vitro* models support association
* **E - Inferential association**: Indirect evidence

**[Trust Rating](https://civicdb.org/help/evidence/trust-ratings){target="_blank"}**

* **5**: Strong, well supported evidence from a lab or journal with respected academic standing. Experiments are well controlled, and results are clean and reproducible across multiple replicates. Evidence confirmed using independent methods. The study is statistically well powered
* **4**: Strong, well supported evidence. Experiments are well controlled, and results are convincing. Any discrepancies from expected results are well-explained and not concerning
* **3**: Evidence is convincing, but not supported by a breadth of experiments. May be smaller scale projects, or novel results without many follow-up experiments. Discrepancies from expected results are explained and not concerning
* **2**: Evidence is not well supported by experimental data, and little follow-up data is available. Publication is from a journal with low academic impact. Experiments may lack proper controls, have small sample size, or are not statistically convincing
* **1**: Claim is not supported well by experimental evidence. Results are not reproducible, or have very small sample size. No follow-up is done to validate novel claims

**[Actionability Score ](https://civicdb.org/help/variants/actionability-score){target="_blank"}**

* [CIViC Actionability Score](https://civicdb.org/help/variants/actionability-score){target="_blank"} allows to assess the accumulation of evidence for each variant. It is calculated by adding all Evidence Item Scores for each variant. The Evidence Item Score is calculated by multiplying the evidence level (A=10 points, B=5 points, C=3 points, D=1 point, E=0.25 points) by the trust rating (each Star = 1 point).
</font> 
</details>

***

#### Losses

```{r drugs_predictive_CN_altered_genes_losses, comment = NA, message=FALSE, warning=FALSE, eval = runPurpleChunk}
##### Generate table with drugs targeting CN altered genes
genes <- mut_cn_expr_genes.expr.losses.z[[2]]$SYMBOL

drugsTable.CN_altered_genes_losses <- civicDrugTable(genes, civic_var_summaries  = caner_genes_annot.list[["civic_var_summaries"]], civic_clin_evid  = caner_genes_annot.list[["civic_clin_evid"]],  evid_type = "Predictive", var_type = "copy_loss")

drugsTable.CN_altered_genes_losses[[1]]

##### Save the expression table as html file
if ( params$plots_mode == "interactive" ) {
  DT::saveWidget(widget=drugsTable.CN_altered_genes_losses[[1]], file=paste(drugsTableDir, "drugsTable.CN_altered_genes_losses.html", sep = "/"), selfcontained=TRUE)
}
```

<details>
<summary>Table legend</summary>
<font size="2">
**[Evidence Level](https://civicdb.org/help/evidence/evidence-levels){target="_blank"}**

* **A - Validated association**: Proven/consensus association in human medicine
* **B - Clinical evidence**: Clinical trial or other primary patient data supports association
* **C - Case study**: Individual case reports from clinical journals
* **D - Preclinical evidence**: *In vivo* or *in vitro* models support association
* **E - Inferential association**: Indirect evidence

**[Trust Rating](https://civicdb.org/help/evidence/trust-ratings){target="_blank"}**

* **5**: Strong, well supported evidence from a lab or journal with respected academic standing. Experiments are well controlled, and results are clean and reproducible across multiple replicates. Evidence confirmed using independent methods. The study is statistically well powered
* **4**: Strong, well supported evidence. Experiments are well controlled, and results are convincing. Any discrepancies from expected results are well-explained and not concerning
* **3**: Evidence is convincing, but not supported by a breadth of experiments. May be smaller scale projects, or novel results without many follow-up experiments. Discrepancies from expected results are explained and not concerning
* **2**: Evidence is not well supported by experimental data, and little follow-up data is available. Publication is from a journal with low academic impact. Experiments may lack proper controls, have small sample size, or are not statistically convincing
* **1**: Claim is not supported well by experimental evidence. Results are not reproducible, or have very small sample size. No follow-up is done to validate novel claims

**[Actionability Score ](https://civicdb.org/help/variants/actionability-score){target="_blank"}**

* [CIViC Actionability Score](https://civicdb.org/help/variants/actionability-score){target="_blank"} allows to assess the accumulation of evidence for each variant. It is calculated by adding all Evidence Item Scores for each variant. The Evidence Item Score is calculated by multiplying the evidence level (A=10 points, B=5 points, C=3 points, D=1 point, E=0.25 points) by the trust rating (each Star = 1 point).
</font> 
</details>

***

## Addendum

<details>
<summary>Parameters</summary>
<font size="2">

```{r params_info, comment = NA}
for ( i in 1:length(params) ) {

  cat(paste("Parameter: ", names(params)[i], "\nValue: ", paste(unlist(params[i]), collapse = ","), "\n\n", sep=""))
}
```

</font>
</details>

<details>
<summary>Session info</summary>
<font size="2">

```{r sessioninfo, comment = NA}
devtools::session_info()
```

</font>
</details>
